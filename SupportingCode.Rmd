---
title: "Numerical analyses code for"
description: |
  Animal-vectored nutrient flow along different resource gradients influences the nature of local and meta-ecosystem functioning
author:
  - name: Matteo Rizzuto 
    url: https://matteorizzuto.github.io
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/
    orcid_id: 0000-0003-3065-9140
  - name: Shawn J. Leroux
    url: https://shawnleroux.wixsite.com/lerouxlab
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/  
    orcid_id: 0000-0001-9580-0294
  - name: Oswald J. Schmitz
    url: http://schmitz.environment.yale.edu
    affiliation: School of the Environment, Yale University
    affiliation_url: https://environment.yale.edu
    orcid_id: 0000-0003-1515-2667
  - name: Eric Vander Wal
    url: http://weel.gitlab.io
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/
    orcid_id: 0000-0002-8534-4317
  - name: Yolanda F. Wiersma
    url: https://nllandscapeecology.com
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/
    orcid_id: 0000-0003-4604-9240
  - name: Travis R. Heckford
    url: https://www.researchgate.net/profile/Travis-Heckford
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/
    orcid_id: 0000-0002-3993-6450
date: "`r Sys.Date()`"
bibliography: ../Manuscripts/Rizzuto_ActiveNutrientTransport.bib
output:
  distill::distill_article:
    toc: true
    code_folding: true
    fig_caption: true
    highlight: default
    self_contained: true
    includes:
      after_body: footer.html
editor_options: 
  chunk_output_type: console
---

# Introduction

This notebook contains the code used to numerically analyze the behaviour of a 
meta-ecosystem model in which consumers move across ecosystem (or 'patches') in 
a _non-diffusive_ fashion. Here, we use _non-diffusive_ to indicate movement 
that happens *against* a natural resource gradient---e.g., nutrient 
availability, primary production, etc. When they leave an ecosystem, organisms 
do not immediately enter another one, but rather spend a significant amount of 
time looking for a suitable one [@Weisser1996]. Models of organismal movement in 
meta-ecosystems should account for this time spent outside ecosystem borders, 
in the so-called 'unsuitable matrix' [@Gounand2018], as it may leads to loss of 
biomass and nutrients from the system. We model this type of movement by 
adopting the framework developed by @Weisser1996. Briefly, in their model of 
host-parasitoid dynamics, they introduce a dispersers' pool connecting two 
ecosystems, so that individuals move first to the dispersers' pool and then to 
a different ecosystem from there. This approach has the advantage of decoupling 
the local ecosystem dynamics from the movement process---effectively making 
them two separate events. Furthermore, these separate events happen at 
different times scales, as basic plant and wildlife biology tells us that plant 
growth takes place over the course of months to years, whereas movement of 
animals can happen on the scale of minutes to hours. To analyze this new model, 
we use _time scales separation_, a mathematical technique that explicitly 
accounts for difference in the _speed_ of different ecological processes by 
letting _fast_ ones reach a **quasi-equilibrium** while holding _slow_ ones 
constant, and then plug this **quasi-equilibrium** into the _slow_ processes' 
equations [@OttoDay2011].

Here, we simulate the behaviour of a system comprising 2 ecosystems connected by 
unidirectional movement between the two consumers pools, mediated by a 
dispersers' pool. The model includes a simple version of recycling within each 
ecosystem. The model includes four state variables and 19 parameters, listed in
the table below:

Variable       Description                                   Units     Range
-------------  --------------------------------------------- --------- -----
N~i~           Nutrients stocks in patch _i_                 g         >0
P~i~           Producers stocks in patch _i_                 g         >0
C~i~           Consumers stocks in patch _i_                 g         >0
Q              Dispersers' Pool                              g         >0  
-------------  --------------------------------------------- --------- -----
Parameter      Description                                   Units     Range
-------------  --------------------------------------------- --------- -----
I~i~           Inorganic nutrient input rate into patch _i_  g*t^-1^   >0
l              Inorganic nutrient output rate                t^-1^	   >0
u~i~           Producer uptake rate in patch _i_             (g*t)^-1^ >0  
a~i~           Consumer attack rate in patch _i_             (g*t)^-1^ >0
$\epsilon$~i~  Consumer assimilation efficiency in patch _i_ unitless  [0,1]
h~i~           Biomass loss rate from P~i~                   t^-1^     >0
d~i~           Biomass loss rate from C~i~                   t^-1^     >0
g              Movement rate from C~i~ to Q                  t^-1^     >0
m              Movement rate from Q to C~i~                  t^-1^     >0
c              Biomass loss rate from Q                      t^-1^     >0
-------------  --------------------------------------------- --------- -----

Derivation and proofs for the model can be found in the 
MovementModel.docx, ModelingMethods.docx, DisperserPool.nb, and 
EcosystemMetrics.nb files in the ModellingCh3 folder.

Before moving on to the simulations, the code chunk below loads the necessary R 
packages.

```{r setup, echo=TRUE, tidy=TRUE}
library(rmarkdown)
library(tidyverse)
library(plotrix)
library(lhs)
library(ggpubr)
library(ggpol)
library(deSolve)
library(patchwork)
library(gt)
library(scales)
```

# Simulating model behavior at equilibrium

Let's begin to generate two sets of randomly-drawn parameter values, one for 
parameters with values scaled between 0 and 10 and another one for parameters 
with values scaled between 0 and 1. Note that we will use these randomly-drawn
values for all simulations in this document.

```{r disp-pool-setParams, echo=TRUE, tidy=TRUE}
# Here we set values for parameters that we will not vary during the simulations
# Nutrients input rate in each patch
I1 = 10
I2 = 10
# Patch leaching rate/soil loss rate
l = 0.1

# Below, instead, we generated random values for those parameters that will vary
# during the simulations: attack rates, efficiency, death rates, and movement 
# rates

DATA1 <- NULL
# Run 2000 iterations of 100 numbers (in 100 bins between 0 to 1)
for(i in seq(1,100,1)){
  
  # Use lhs function in R. 100 bins, 11 iterations - one for each parameter that is scaled between 0 and 10.
  loop_1 <- randomLHS(100, 11)
  
  # Use rbind to stack each iteration on top of the other to create a one column list of 100000 samples with equal distribution in 100 bins.
  # Multiplied by 10 to get range of data from 0 to 10
  DATA1 <- rbind(DATA1, data.frame(i=i, Result=loop_1*10))
  
  # print the i value so you can track progress
  # print(i)
  # Close the loop
}

# This is for 2 parameters that is scaled 0 to 1.
DATA2 <- NULL
# Run 2000 iterations of 100 numbers (in 100 bins between 0 to 1)
for(i in seq(1,100,1)){

# Use lhs function in R. 100 bins, 2 iterations.
loop_2 <- randomLHS(100, 2)

# Use rbind to stack each iteration on top of the other to create a one column list of 200000 samples with equal distribution in 100 bins.
# Multiplied by 10 to get range of data from 0 to 10
DATA2 <- rbind(DATA2, data.frame(i=i, Result=loop_2))

# print the i value so you can track progress
# print(i)
# Close the loop
}
```

Now, let's allocate an empty dataframe to contain the data that we will draw
from the two datasets produced above at each iteration. This dataframe will also
host the resulting state variable biomass values and we will name it `PRED`.

```{r empty-df-allocation,echo=TRUE,tidy=TRUE}
# Allocate an empty data frame to save the data in
PRED <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PRED <-rbind(PRED, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))
```

Now for the simulations. The code chunk below contains a `for` loop that, over 
a 1000 time steps, iterates the model's equilibria to calculate stocks of
Nutrients (`N1`, `N2`), Producers (`P1`, `P2`), and Consumers (`C1`, `C2`) in 
the two ecosystems. As well, it calculates the stock for the Dispersers' Pool 
(`Q`), the recycling flux for each biotic compartment in both ecosystems 
(`FLUX_X`, where `X` is the compartment), and each ecosystem's own total 
recycling flux (`FLUX_Eco_1`, `FLUX_Eco_2`). At each time step, 
we draw a random value for each parameter listed in the above table from either
the `DATA1` or `DATA2` datasets---depending on whether the parameter is scaled 
0--10 or 0--1, respectively. Then, we plug these values into the model's 
equilibria and recycling flux formulas as derived using Mathematica 
("DispeserPool_Recycl_ProdUptake.nb" notebook), and finally populate rows of 
values in `PRED` with the randomly drawn parameter values and trophic 
compartment stock values thus calculated.

> `r format(Sys.time(), '%d %B, %Y')`---Note: the model's feasibility 
conditions are too complex to resolve  analytically. Hence, we are not checking 
that the randomly-drawn parameters values satisfy them. 

After running the simulations' code, we calculate meta-ecosystem productivity for
each trophic compartment. That is, the sum of a trophic level's biomass 
production in ecosystem 1 and of its counterpart in ecosystem 2. 
These quantities, `Ntot`, `Ptot`, and `Ctot`, provide clues as to whether any 
effect of consumer movement in the local ecosystems can also be detected when 
considering the meta-ecosystem as a whole. Furthermore, we manually calculate
each ecosystem's own total recycling flux as the sum of the flux of its 2 biotic
compartments, as a check on the Mathematica-derived formulas. Finally, we 
calculate the meta-ecosystem flux (`MetaEcoFlux`) as the sum of the two 
ecosystems' total flux.

```{r dispPool-simuls, echo=TRUE,tidy=TRUE}
# We want to start simulations at 0
i1 = 0

for (i in seq(0,999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
# producers uptake rates
u1 = DATA1[i1,2] # in ecosystem 1
u2 = DATA1[i1,3] # in ecosystem 2
# consumers attack rates
a1 = DATA1[i1,4]
a2 = DATA1[i1,5]
# death rates (= recycling rate)
h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
c = DATA1[i1,10] # death rate in the disperser's pool Q
# movement rate to the Disperser's pool Q
g = DATA1[i1,11]
# movement rate from the Disperser's pool Q
m = DATA1[i1,12]
# efficiency of consumers 
e1 = DATA2[i1,2] # in ecosystem 1
e2 = DATA2[i1,3] # in ecosystem 2

PRED[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
               ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (d1 + g)/(a1*e1),
               (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
               (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
               (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*h1)/(a1*e1),
               (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
               )
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem biomass
PRED$Ntot <- PRED$N1+PRED$N2
PRED$Ptot <- PRED$P1+PRED$P2
PRED$Ctot <- PRED$C1+PRED$C2

# now calculate recycling flux for the local ecosystem
PRED$FLUX_Eco1_check <- PRED$FLUX_P1 + PRED$FLUX_C1
PRED$FLUX_Eco2_check <- PRED$FLUX_P2 + PRED$FLUX_C2

# and the meta-ecosystem recycling flux
PRED$FLUX_Ptot <- PRED$FLUX_P1 + PRED$FLUX_P2
PRED$FLUX_Ctot <- PRED$FLUX_C1 + PRED$FLUX_C2
PRED$MetaEcoFlux <- PRED$FLUX_Eco_1 + PRED$FLUX_Eco_2 - PRED$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PRED <- dplyr::mutate(PRED, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PRED <- dplyr::mutate(PRED, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDpos <- filter(PRED, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)

# sample PRED to only use 1000 random simulation results
# PRED_sample1000 <- PRED[sample(nrow(PRED),size=1000),]
```

We now have a dataset containing 1000 variations of the model's results. In 
the chunk below, we first remove those stock sets in which any of the 
compartments is $\leq0$---as these values do not make biological sense. Then,
we use boxplots to investigate how the presence of unidirectional, non-diffusive 
consumer movement influences the meta-ecosystem's behaviour.

```{r simulbplot,echo=TRUE,tidy=TRUE, fig.cap="Biomass stock values at equilibrium for local and meta-ecosystem scale. Ecosystem 1 and 2 include a tri-trophic food chain (Nutrient, Producers, Consumers) each. Consumers move from ecosystem 1 to ecosystem 2 via a Dispersers' Pool (Q). The two ecosystems and the dispersers' pool together form the meta-ecosystem. Point-down triangles identify outliers; labels on top of the compartments' boxplots report median values for the full set of simulations. Values on the y-axis are limited between [0, 100] to zoom in on the variation in the results."}
# pivot the dataset to longer format for boxplot plotting
PRED_biomass_long <- select(PREDpos, N1:Q, Ntot:Ctot) %>% pivot_longer(., names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers Pool", "Meta-ecosystem"))))

PRED_biomass_long$Compartment <- as_factor(PRED_biomass_long$Compartment)
PRED_biomass_long$Ecosystem <- as_factor(PRED_biomass_long$Ecosystem)

comparts_medians <- PRED_biomass_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data = PRED_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")

#ggsave(filename = "../Results/ModelEq_base.png", device = "png", dpi = 300, height = 5)
```

The graph above show a classic trophic cascade, albeit one that acts across 
ecosystem borders. In ecosystem 2, the influx of consumers from ecosystem 1 
increases the consumer biomass, in turn depressing the producers' abundance 
and releasing the nutrient stock from the producers' trophic pressure. 
Conversely, in ecosystem 1, consumers' numbers fall steadily---due to the 
combined action of mortality and emigration towards ecosystem 2---thus 
releasing the producers from the trophic pressure exerted by consumers. In 
turn, this lets producers grow unchecked, depressing the nutrient stocks in 
ecosystem 1.

```{r g-change, echo=TRUE,tidy=TRUE,fig.cap="Change in biomass of the two ecosystems' compartment, the dispersers' pool, and the meta-ecostystem with change in the value of the rate of immigration into the disperser pool (g)---i.e., the rate at which consumers leave ecosystem 1. Each facet presents results for a single trophic compartment, with color identifying levels of biological organization. Lines are regression lines with 95% CI (grey shaded areas), drawn using the full range of values. Note the base-10 logarithmic scale on the ordinates (y-axis)."}

eco_levels <- c("N1" = "Nutrient", "P1" = "Producers", "C1" = "Consumers",
                "N2" = "Nutrient", "P2" = "Producers", "C2" = "Consumers",
                "Q" = "Dispersers", "Ntot" = "Nutrient",
                "Ptot" = "Producers", "Ctot" = "Consumers")

# pivot the dataset to longer format for boxplot plotting
PRED_long <- pivot_longer(PREDpos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers", "Meta-ecosystem"))))

PRED_long$Compartment <- as_factor(PRED_long$Compartment)
PRED_long$Ecosystem <- as_factor(PRED_long$Ecosystem)

ggplot(PRED_long, aes(g, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.15) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

```{r m-change, echo=TRUE,tidy=TRUE,fig.cap="Change in biomass of the two ecosystems' compartment, the dispersers' pool, and the meta-ecostystem with change in the value of the rate of emigration from the disperser pool (m).---i.e., the rate at which consumers enter ecosystem 2. All other specifications as in Figure 2."}

ggplot(PRED_long, aes(m, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.15) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

```{r c-change, echo=TRUE,tidy=TRUE,fig.cap="Change in biomass of the two ecosystems' compartment, the dispersers' pool, and the meta-ecostystem with change in the value of the consumer death rate while in the dispersers' pool (c). This could represent predation risk, but also environmental hazards and stochastic events such as crossing a dangerous linear feature of the landscape---e.g., a busy highway. All other specifications as in Figure 2."}

ggplot(PRED_long, aes(c, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.15) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

After taking a look at the productivity of the system by checking stock graphs,
let's take a look at the system's recycling flux. In the graphs below, we will
start by taking a look at recycling flux values in each ecosystem and in the 
meta-ecosystem for each iteration of the model. First, we will extract the flux 
columns (see above) from the `PRED` dataframe into a new one which we will call 
`FluxPRED`. We will then pivot this dataframe from wide to long format, using 
function `pivot_longer` from package `tidyr`.

```{r flux-graphs-prep, echo=TRUE,tidy=TRUE}
FluxPRED <- PREDpos %>% dplyr::select(TIME:c,FLUX_P1:FLUX_C2, FLUX_Ptot:MetaEcoFlux) %>% tidyr::pivot_longer(., names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(., Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2", "Recipient", "Meta-ecosystem")))
```

Now, let's take a look at a summary boxplot of recycling flux in the
local and meta-ecosystem.

```{r nut-flux-equal-I, echo=TRUE,tidy=TRUE,fig.cap="Recycling flux at local and meta-ecosystem scales when consumers move from ecosystem 1 to 2. Note that, in this case, the two ecosystems have the same fertility---i.e., basal inorganic input values are the same. Point-down triangles identify outliers; labels on top of the compartments’ boxplots report median values for the full set of simulations. The y-axis is constrained between [0, 500] to show the variation in the results."}
FluxPRED$Scale <- as.factor(FluxPRED$Scale)
FluxPRED$Compartment <- as.factor(FluxPRED$Compartment)

comparts_medians <- FluxPRED %>% dplyr::group_by(Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPRED %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Ptot", "FLUX_P2", "FLUX_C2", "FLUX_Ctot", "MetaEcoFlux"))) %>% 
  dplyr::mutate(., Scale = fct_relevel(Scale, c("Donor", "Recipient", "Meta-ecosystem"))) %>%
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.25, outlier.shape = 25, jitter.shape = 21) +
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Scale, scales = "free") + scale_x_discrete(labels = c("FLUX_C1" = "C", "FLUX_P1" = "P", "FLUX_Ptot" = "P", "FLUX_C2" = "C", "FLUX_P2" = "P", "FLUX_Ctot" = "C", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 500)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none", axis.title.x = element_blank())
```

# Influence of consumers' movement rates on the model's behaviour

Here, we investigate the behaviour of the system when one of the two parameters 
regulating movement to/from the dispersers' pool is set to 0. That is, when 
movement is still part of the system but does not connect the two ecosystems 
under scrutiny.

### Lack of Consumer influx to Ecosystem 2 (m = 0)
We begin with the case of `m = 0`, and `g = [0, 10]`. The chunk below performs 
the dataframe allocation and simulation, using parameter values drawn from 
`DATA1` and `DATA2` previously allocated. Results are shown in Figure 
\@ref(fig:simuls-m0) below.

```{r simuls-m0,echo=TRUE,tidy=TRUE,fig.cap="Biomass stock values at equilibrium for local and meta-ecosystem scale, when the rate of movement from the dispersers' pool (m) to ecosystem 2 is set to 0. This results in a smaller consumers stock in ecosystem 2, in turn allowing Producers to grow more biomass and depress Nutrient stocks. All other specifications as in Figure 1."}
# Allocate an empty data frame to save the data in
PREDm0 <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDm0 <-rbind(PREDm0, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
# producers uptake rates
u1 = DATA1[i1,2] # in ecosystem 1
u2 = DATA1[i1,3] # in ecosystem 2
# consumers attack rates
a1 = DATA1[i1,4]
a2 = DATA1[i1,5]
# death rates (= recycling rate)
h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
c = DATA1[i1,10] # death rate in the disperser's pool Q
# movement rate to the Disperser's pool Q
g = DATA1[i1,11]
# movement rate from the Disperser's pool Q
m = 0
# efficiency of consumers 
e1 = DATA2[i1,2] # in ecosystem 1
e2 = DATA2[i1,3] # in ecosystem 2

PREDm0[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
               ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (d1 + g)/(a1*e1),
               (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
               (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2))
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDm0$Ntot <- PREDm0$N1 + PREDm0$N2
PREDm0$Ptot <- PREDm0$P1 + PREDm0$P2
PREDm0$Ctot <- PREDm0$C1 + PREDm0$C2

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDm0pos <- subset(PREDm0, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0)
# PREDm0_sample1000 <- PRED[sample(nrow(PREDm0pos),size=1000),]

# pivot the 
PREDm0_long <- pivot_longer(PREDm0pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", "Meta-ecosystem")))

PREDm0_long$Compartment <- as_factor(PREDm0_long$Compartment)
PREDm0_long$Ecosystem <- as_factor(PREDm0_long$Ecosystem)

comparts_medians <- PREDm0_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data=PREDm0_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

While the difference in the relative biomass stocks among the trophic 
compartments in Ecosystem 2 is small compared to Figure 1, 
there is no trophic cascade in Ecosystem 2 in this scenario and the system is 
strongly bottom-up controlled. Conversely, in Ecosystem 1, Consumers are still 
reduced to minimal abundance over time, while Producers are free to depress 
Nutrients and grow.

```{r echo=TRUE,tidy=TRUE,fig.cap="Change in biomass of the two ecosystems’ compartment, the dispersers’ pool, and the meta-ecostystem with change in the value of the rate of the rate of immigration into the disperser pool (g)---i.e., the rate at which consumers leave ecosystem 1. All other specifications as in Figure 2.", fig.show='asis'}

ggplot(PRED_long, aes(g, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.15) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

```{r echo=TRUE,tidy=TRUE,fig.cap="Change in biomass of the two ecosystems’ compartment, the dispersers’ pool, and the meta-ecostystem with change in the value of the rate of the consumer death rate while in the dispersers' pool (c). All other specifications as in Figure 2.", fig.show='asis'}

ggplot(PRED_long, aes(c, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.15) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

### Lack of immigration into the Dispersers' Pool from Ecosystem 1 (g = 0)

Now, for the case in which Consumers from Ecosystem 1 do not emigrate to the 
Dispersers' Pool. In this scenario, we will set `g = 0` from the start of the 
simulations, and draw `m` values from `DATA1` as all other parameters scaled 
$\in [0,1]$. Results are shown in Figure \@ref(fig:simuls-g0) below.

```{r simuls-g0,echo=TRUE,tidy=TRUE,fig.cap="Biomass stock values at equilibrium for local and meta-ecosystem scale, when the rate of movement from ecosystem 1 to the dispersers' pool (g) is set to 0. This establishes bottom-up control in both ecosystems. All other specifications as in Figure 1."}
# Allocate an empty data frame to save the data in
PREDg0 <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDg0 <-rbind(PREDg0, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
# producers uptake rates
u1 = DATA1[i1,2] # in ecosystem 1
u2 = DATA1[i1,3] # in ecosystem 2
# consumers attack rates
a1 = DATA1[i1,4]
a2 = DATA1[i1,5]
# death rates (= recycling rate)
h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
c = DATA1[i1,10] # death rate in the disperser's pool Q
# movement rate to the Disperser's pool Q
g = 0
# movement rate from the Disperser's pool Q
m = DATA1[i1,11]
# efficiency of consumers 
e1 = DATA2[i1,2] # in ecosystem 1
e2 = DATA2[i1,3] # in ecosystem 2

PREDg0[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
               ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (d1 + g)/(a1*e1),
               (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
               (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2))
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDg0$Ntot <- PREDg0$N1 + PREDg0$N2
PREDg0$Ptot <- PREDg0$P1 + PREDg0$P2
PREDg0$Ctot <- PREDg0$C1 + PREDg0$C2

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDg0pos <- subset(PREDg0, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0)
# PREDg0_sample1000 <- PRED[sample(nrow(PREDg0pos),size=1000),]

# pivot the 
PREDg0_long <- pivot_longer(PREDg0pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", "Meta-ecosystem")))

PREDg0_long$Compartment <- as_factor(PREDg0_long$Compartment)
PREDg0_long$Ecosystem <- as_factor(PREDg0_long$Ecosystem)

comparts_medians <- PREDg0_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data=PREDg0_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.16, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

In this case, the lack of movement from the Consumer trophic compartment to 
the Dispersers' Pools establishes a classic bottom-up control in both 
ecosystems. As there is no movement through the dispersers' pool Q, we will not
show scatterplots like Figures \@ref(fig:g-change), \@ref(fig:m-change), or 
\@ref(fig:c-change) above.

```{r echo=TRUE,tidy=TRUE, fig.cap="Change in biomass of the two ecosystems’ and the meta-ecostystemtrophic compartments with change in the value of the rate of the rate of emigration from the disperser pool (m). NOte that Q is not shown as there is no immigration into it. All other specifications as in Figure 2.", fig.show='asis'}

ggplot(PREDg0_long, aes(m, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.1) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

```{r echo=TRUE,tidy=TRUE,fig.cap="Change in biomass of the two ecosystems’ and the meta-ecostystem trophic compartments with change in the value of the rate of the consumer death rate while in the dispersers' pool (c). Note that Q is not shown as there is not immigration into it. All other specifications as in Figure 2.", fig.show='asis'}

ggplot(PREDg0_long, aes(c, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.1) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

### Sampling `g` from a set of values

Here we run the model using a set value of `m` (= 0) and drawing `g` from a 
set of [0,10] values. To do this, we will use a nested for loop. In the outer 
loop, we will sequentially draw a value for `g`. We will then use this value to 
run the model in the inner loop. Here, we create object `gvar`, to store the 
values for `g`: these are values between 0 and 10, in 0.5 increments.

```{r gvar-values, echo=TRUE, tidy=TRUE}
gvar <- seq(0, 10, 0.5)
```

Now, we run the model.

```{r simuls-gvar,echo=TRUE,tidy=TRUE,fig.cap="Biomass stock values at equilibrium for local and meta-ecosystem scale when m is held constant, g is allowed to vary, and the other parameters are randomly drawn. The consumers' collapse in ecosystem 1, and consequent increase in producer biomass, is even more evident than in previous scenarios. Ecosystem 2 is largely untouched by this situation. Parameter values and ranges: m = 0, g = [0,10]. All other specifications as in Figure 1. "}
# Allocate an empty data frame to save the data in
PREDgvar <- NULL

for (j in 1:length(gvar)) {
  # movement rate to the Disperser's pool Q
  g = gvar[j]
  # movement rate from the Disperser's pool Q
  m = 0
  
  PREDtemp <- NULL
  
  PREDtemp <- rbind(PREDtemp, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1)))
  
  # We want to start simulations at 0
  i1 = 0

  for (i in seq(0,199,1)){
  	# go to the next row
  	i1 = i1 + 1
  
  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate)
  h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
  h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDtemp[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                 ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2))
  }
  PREDgvar <- rbind(PREDgvar, PREDtemp)
  rm(PREDtemp)
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDgvar$Ntot <- PREDgvar$N1 + PREDgvar$N2
PREDgvar$Ptot <- PREDgvar$P1 + PREDgvar$P2
PREDgvar$Ctot <- PREDgvar$C1 + PREDgvar$C2

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDgvarpos <- subset(PREDgvar, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0)
# PRED_sample100 <- PRED[sample(nrow(PRED),size=100),]

# pivot the 
PREDgvar_long <- pivot_longer(PREDgvarpos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", "Meta-ecosystem")))

PREDgvar_long$Compartment <- as_factor(PREDgvar_long$Compartment)
PREDgvar_long$Ecosystem <- as_factor(PREDgvar_long$Ecosystem)

comparts_medians <- PREDgvar_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data=PREDgvar_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.1, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) +
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r echo=TRUE,tidy=TRUE, fig.cap="Change in biomass of the two ecosystems’ compartment, the dispersers’ pool, and the meta-ecostystem as g increases from 0 to 10, in increments of 0.5. THe value of m is held constant at 0. All other specifications as in Figure 2.", fig.show='asis'}

ggplot(data = PREDgvar_long, aes(x = g, y = log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.1) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

```{r echo=TRUE,tidy=TRUE,fig.cap="Change in biomass of the two ecosystems’ compartment, the dispersers’ pool, and the meta-ecostystem with change in the value of the consumer death rate while in the dispersers' pool (c) when g varies between 0 and 10. All specificatons as in Figure 2.", fig.show='asis'}

ggplot(PREDgvar_long, aes(c, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.1) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(.~Compartment) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 11))
```

### Potential Interaction between `g` and `m`

Inspecting the above results, it seems there may be an interaction between `g` 
and `m`, the two parameters that regulate movement to and from the Dispersers' 
Pool (Q), respectively. Here, we try to disentangle this interactions, by 
randomly drawing `m` from a [0,10] distribution like before, but instead 
fixing the value of `g`. We will run three such simulations, with `g = 0`, 
`g = 5`, and `g = 9`. 

```{r simuls-gm-interact,echo=TRUE,tidy=TRUE,fig.cap="Comparison of biomass stock values at equilibrium for local and meta-ecosystem scale for three cases of increasing g values; low (g = 0), medium (g = 5), and high (g = 9), respectively. All other parameters values, including m, are randomly drawn. In all scenarios, consumers collapse in ecosystem 1 following movement to the dispersers pool, leading to the establishment of a spatial trophic cascade at the meta-ecosystem scale. Simulations were ran for 1000 time steps for each value of g. All other specifications as in Figure 1."}

gset <- c(0, 5, 9)

# Allocate an empty data frame to save the data in
PREDint <- NULL

for (j in 1:length(gset)) {
  # movement rate to the Disperser's pool Q
  g = gset[j]
  
  PREDtemp <- NULL
  
  PREDtemp <- rbind(PREDtemp, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1)))
  
  # We want to start simulations at 0
  i1 = 0

  for (i in seq(0,999,1)){
  	# go to the next row
  	i1 = i1 + 1
  
  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate)
  h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
  h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,11]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDtemp[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                 ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2))
  }
  PREDint<- rbind(PREDint, PREDtemp)
  rm(PREDtemp)
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDint$Ntot <- PREDint$N1 + PREDint$N2
PREDint$Ptot <- PREDint$P1 + PREDint$P2
PREDint$Ctot <- PREDint$C1 + PREDint$C2

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDintpos <- subset(PREDint, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0)
# PRED_sample100 <- PRED[sample(nrow(PRED),size=100),]

# pivot the 
PREDint_long <- pivot_longer(PREDintpos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", "Meta-ecosystem")))

PREDint_long$Compartment <- as_factor(PREDint_long$Compartment)
PREDint_long$Ecosystem <- as_factor(PREDint_long$Ecosystem)
PREDint_long$g <- as_factor(PREDint_long$g)

comparts_medians <- PREDint_long %>% dplyr::group_by(Compartment, Ecosystem, g) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

g_levels <- c("0" = "g = 0", "5" = "g = 5", "9" = "g = 9")

ggplot(data=PREDint_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.1, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) +
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(g~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-5, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r gm-int-stock, echo=TRUE,tidy=TRUE, fig.cap="Change in biomass stock values over change in the rate of consumer movement from the dispersers' pool to ecosystem 2 (m), when the rate of consumer movememnt to the dispersers' pool from ecosystem 1 (g) is drawn from three alternative values: low (g = 0), medium (g = 5), and high (g = 9). All other specifications as in Figure 2.", fig.show='asis'}

ggplot(data=PREDint_long, aes(x = m, y = log10(Stock), fill = Ecosystem, col = Ecosystem)) + geom_point(alpha = 0.1) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(g~Compartment, scales = "free", labeller = labeller(g = g_levels)) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 10))
```

```{r echo=TRUE,tidy=TRUE,fig.cap="Change in biomass stock values with change in the value of the consumer death rate while in the dispersers' pool (c), when g is either low (g = 0), medium (g = 5), and high (g = 9). All other specifications as in Figure 2.", fig.show='asis'}

ggplot(PREDint_long, aes(c, log10(Stock), col = Ecosystem)) + geom_point(alpha = 0.15) + geom_smooth(method = "lm", col = "black", alpha = 1, se = T, lwd = 0.5) + facet_grid(g~Compartment, scale = "free", labeller = labeller(g = g_levels)) + theme_pubr() + guides(colour = guide_legend(override.aes = list(alpha = 1))) + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8), text = element_text(size = 10))
```

# Different environmental fertility conditions in local ecosystems

Here, we investigate the influence of environmental fertility conditions on the 
productivity and nutrient flux at local and meta-ecosystem scales, when 
consumers move from ecosystem 1 to ecosystem 2. We will 
investigate two scenarios: higher environmental fertility in the donor ecosystem 
and higher environmental fertility in the recipient ecosystem  Note that 
the environmental leaching rate of each ecosystem (`l`)---i.e., the rate at 
which nutrient leave local ecosystems independently from trophic process---is 
invariant and equal between the two ecosystems.

**Note**: in the graphs below, we will not be showing values for the dispersers'
pool, `Q`, as these tend to be negligible compared to the local and 
meta-ecosystem values for all ecosystem functions.

### Higher environmental fertility in donor ecosystem 

We begin by simulating a meta-ecosystem where the local donor ecosystem, 
ecosystem 1, has higher environmental fertility than the recipient ecosystem 
(ecosystem 2). Consumers move from ecosystem 1 to ecosystem 2 so that, in this 
case, our model is simulating _diffusive_ organismal movement using a different 
approach than previous studies [e.g., @Gravel2010a].

```{r simuls-I2small,echo=TRUE,tidy=TRUE,fig.cap="In the case of larger inorganic inputs into ecosystem 1, consumers movement is diffusive. The magnitude of the producers' release following consumers' collapse in ecosystem 1 is larger than in the case when I~1~ = I~2~ (confront this figure with Figure 1). I~1~ = 18, I~2~ = 2. All other specifications as in Figure 1."}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 > I2
I1=18
I2=2

# Leaching does not change as is still equal across ecosystems
l = 0.1

# Allocate an empty data frame to save the data in
PREDI2 <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDI2 <-rbind(PREDI2, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
# producers uptake rates
u1 = DATA1[i1,2] # in ecosystem 1
u2 = DATA1[i1,3] # in ecosystem 2
# consumers attack rates
a1 = DATA1[i1,4]
a2 = DATA1[i1,5]
# death rates (= recycling rate)
h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
c = DATA1[i1,10] # death rate in the disperser's pool Q
# movement rate to the Disperser's pool Q
g = DATA1[i1,11]
# movement rate from the Disperser's pool Q
m = DATA1[i1,12]
# efficiency of consumers 
e1 = DATA2[i1,2] # in ecosystem 1
e2 = DATA2[i1,3] # in ecosystem 2

PREDI2[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
               ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (d1 + g)/(a1*e1),
               (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
               (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
               (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*h1)/(a1*e1),
               (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
               )
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDI2$Ntot <- PREDI2$N1 + PREDI2$N2
PREDI2$Ptot <- PREDI2$P1 + PREDI2$P2
PREDI2$Ctot <- PREDI2$C1 + PREDI2$C2

# now calculate recycling flux for the local ecosystem
PREDI2$FLUX_Eco1_check <- PREDI2$FLUX_P1 + PREDI2$FLUX_C1
PREDI2$FLUX_Eco2_check <- PREDI2$FLUX_P2 + PREDI2$FLUX_C2

# and the meta-ecosystem recycling flux
PREDI2$FLUX_Ptot <- PREDI2$FLUX_P1 + PREDI2$FLUX_P2
PREDI2$FLUX_Ctot <- PREDI2$FLUX_C1 + PREDI2$FLUX_C2
PREDI2$MetaEcoFlux <- PREDI2$FLUX_Eco_1 + PREDI2$FLUX_Eco_2 - PREDI2$FLUX_Q

# Finally, calculate the production for each compartment at the meta-ecosystem scale
PREDI2 <- dplyr::mutate(PREDI2, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDI2 <- dplyr::mutate(PREDI2, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDI2pos <- subset(PREDI2, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
# PRED_sample100 <- PRED[sample(nrow(PRED),size=100),]

# pivot the 
PREDI2_biomass_long <- pivot_longer(PREDI2pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment =="Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::mutate(., Ecosystem = fct_relevel(Ecosystem, "Donor", "Recipient", "Meta-ecosystem")) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDI2_biomass_long$Compartment <- as_factor(PREDI2_biomass_long$Compartment)
PREDI2_biomass_long$Ecosystem <- as_factor(PREDI2_biomass_long$Ecosystem)

comparts_medians <- PREDI2_biomass_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

I2bm <- ggplot(data=PREDI2_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")

I2bm
```

```{r I2small-flux,echo=TRUE,tidy=TRUE,fig.cap="With a higher fertility in the donor ecosystem---i.e., I~1~ >> I~2~---recycling flux in ecosystem 1 increases, mostly through the increased producers' biomass. Conversely, ecosystem 2 shows lower and less variable levels of nutrient flux. At the meta-ecosystem scale, recycling flux is higher than in either local ecosystems but lower than in the case of equal local ecosystem environmental fertility (Figure 5). I~1~ = 18, I~2~ = 2. All other specifications as in Figure 5."}
FluxPREDI2 <- PREDI2pos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDI2$Scale <- as.factor(FluxPREDI2$Scale)
FluxPREDI2$Compartment <- as.factor(FluxPREDI2$Compartment)

comparts_medians <- FluxPREDI2 %>% dplyr::group_by(Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

I2nf <- FluxPREDI2 %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Scale, scales = "free") + 
  coord_cartesian(y = c(0, 300)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())

I2nf

I2all <- I2bm + I2nf + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") + plot_layout(ncol = 1, nrow = 2)

#ggsave(I2all, filename = "../Results/LowI2BmNf.png", device = "png", dpi = 300, width = 8, height = 6)
```

### Higher environmental fertility in recipient ecosystem 

Figure \@ref(fig:simuls-I1small) below reports the results of a scenario in 
which environmental fertility in ecosystem 1 is smaller than that of 
ecosystem 2. In this case, consumer movement is _non-diffusive_, as it takes 
place against the resource availability (= fertility) gradient. The resulting 
spatial trophic cascade involving the local ecosystem is much stronger than 
in the scenario of equal fertility conditions (Figure \@ref(fig:simulbplot)).

```{r simuls-I1small,echo=TRUE,tidy=TRUE,fig.cap="Movement of consumer against the environmental fertility gradient leads to a strong reduction of the nutrients stock in ecosystem 1---i.e., the source of consumer on the move---stemming from the release of local primary producers from consumer control. In ecosystem 2, the recipient of consumers movement and more fertility ecosystem, the nutrients stock increases beyond the level of enrichment seen in Figure 1, as local and immigrant consumer strongly suppress the local primary producers.  All other specifications as in Figure 1. I~1~ = 2, I~2~ = 18."}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 < I2
I1=2
I2=18

# leaching rate
l = 0.1

# Allocate an empty data frame to save the data in
PREDI1 <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDI1 <-rbind(PREDI1, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
# producers uptake rates
u1 = DATA1[i1,2] # in ecosystem 1
u2 = DATA1[i1,3] # in ecosystem 2
# consumers attack rates
a1 = DATA1[i1,4]
a2 = DATA1[i1,5]
# death rates (= recycling rate)
h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
c = DATA1[i1,10] # death rate in the disperser's pool Q
# movement rate to the Disperser's pool Q
g = DATA1[i1,11]
# movement rate from the Disperser's pool Q
m = DATA1[i1,12]
# efficiency of consumers 
e1 = DATA2[i1,2] # in ecosystem 1
e2 = DATA2[i1,3] # in ecosystem 2

PREDI1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
               ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (d1 + g)/(a1*e1),
               (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
               (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
               (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*h1)/(a1*e1),
               (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
               )
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDI1$Ntot <- PREDI1$N1 + PREDI1$N2
PREDI1$Ptot <- PREDI1$P1 + PREDI1$P2
PREDI1$Ctot <- PREDI1$C1 + PREDI1$C2

# now calculate recycling flux for the local ecosystem
PREDI1$FLUX_Eco1_check <- PREDI1$FLUX_P1 + PREDI1$FLUX_C1
PREDI1$FLUX_Eco2_check <- PREDI1$FLUX_P2 + PREDI1$FLUX_C2
# and the meta-ecosystem recycling flux
PREDI1$FLUX_Ptot <- PREDI1$FLUX_P1 + PREDI1$FLUX_P2
PREDI1$FLUX_Ctot <- PREDI1$FLUX_C1 + PREDI1$FLUX_C2
PREDI1$MetaEcoFlux <- PREDI1$FLUX_Eco_1 + PREDI1$FLUX_Eco_2 - PREDI1$FLUX_Q

# Finally, calculate the compartment production at meta-ecosystem scale
PREDI1 <- dplyr::mutate(PREDI1, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDI1 <- dplyr::mutate(PREDI1, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDI1pos <- subset(PREDI1, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
# PRED_sample100 <- PRED[sample(nrow(PRED),size=100),]

# pivot the 
PREDI1_biomass_long <- pivot_longer(PREDI1pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::mutate(., Ecosystem = fct_relevel(Ecosystem, "Donor", "Recipient", "Meta-ecosystem")) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDI1_biomass_long$Compartment <- as_factor(PREDI1_biomass_long$Compartment)
PREDI1_biomass_long$Ecosystem <- as_factor(PREDI1_biomass_long$Ecosystem)

comparts_medians <- PREDI1_biomass_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

I1bm <- ggplot(data=PREDI1_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")

I1bm
```

Following from the stronger trophic cascades, nutrient flux is also affected at
both local and meta-ecosystem scales when consumer movement happens against the
local fertility gradient. Here, median nutrient flux in the recipient, and more 
fertile, ecosystem 2 is more than double the median flux in the case of 
diffusive consumer movement (Figure \@ref(fig:I2small-flux)). Furthermore, it is
also higher than in the case of equal local environmental fertility---i.e., lack 
of a fertility gradient (Figure \@ref(fig:nut-flux-equal-I)). Likewise, median 
nutrient flux at the meta-ecosystem scale is higher than in either the 
along-gradient (Figure \@ref(fig:I2small-flux)) and no-gradient 
(Figure \@ref(fig:nut-flux-equal-I)) cases.

```{r I1small-flux, echo=TRUE,tidy=TRUE,fig.cap="Nutrient flux more than doubles in ecosystem 2, when this is the more fertile of the two ecosystem and is also the recipient of consumer movement. In turn, this leads to an overall increase in the nutrient flux at the meta-ecosystem scale, compared to scenarios where environmental fertility is equal among local ecosystem (Figure 5) or is higher in the donor ecosystem (Figure 19). I~1~ = 2, I~2~ = 18."}
FluxPREDI1 <- PREDI1pos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDI1$Scale <- as.factor(FluxPREDI1$Scale)
FluxPREDI1$Compartment <- as.factor(FluxPREDI1$Compartment)

comparts_medians <- FluxPREDI1 %>% dplyr::group_by(Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

I1nf <- FluxPREDI1 %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 400)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())

I1nf

I1all <- I1bm + I1nf + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") + plot_layout(ncol = 1, nrow = 2)

#ggsave(I1all, filename = "../Results/LowI1BmNf.png", device = "png", dpi = 300, width = 8, height = 6)
```

# Model behaviour with different producers' recycling rates

How does non-diffusive organismal movement interact with other local and 
meta-ecosystem processes? We have shown above that non-diffusive, 
against-gradient consumer movement can influence local and meta-ecosystem 
productivity and lead to the establishment spatial trophic cascades 
(Figures \@ref(fig:simulbplot), \@ref(fig:simuls-I2small), 
\@ref(fig:simuls-I1small); @Knight2005, @Massol2017). 
Indeed, nutrient flux at both local and meta-ecosystem scales reflects this 
(Figures \@ref(fig:nut-flux-equal-I), \@ref(fig:I2small-flux), 
\@ref(fig:I1small-flux)). However, multiple parameters influence ecosystem 
processes like productivity and nutrient flux, both in our model and in the real
world. Here we focus on primary producers recycling rate and investigate how the
effects of non-diffusive consumer movement on primary productivity and nutrient 
flux change when we consider a meta-ecosystem in which primary producers in the 
local ecosystem differ in their recycling rates. As we are modeling 
unidirectional non-diffusive consumer movement, we will consider three cases: 

1. equal autotrophs' recycling rates in both local ecosystems,
2. higher autotroph recycling rate in ecosystem 1 than in ecosystem 2, and 
3. the opposite case of higher primary producer recycling rate in ecosystem 2.

We will evaluate these three cases in each one of the three environmental 
fertility scenarios simulated above---i.e., equal, higher in donor, and higher 
in recipient fertility.

### Equal environmental fertility conditions

#### Equal primary producers recycling rates

We begin by simulating model behavior when recycling rates of primary producers 
in the two local ecosystems are equal---i.e., h~1~ = h~2~---in equal 
environmental fertility conditions. This will help set a baseline for 
other combinations of environmental fertility and producers recycling rates 
scenarios. The code, in this case, is much the same as in previous 
simulations, with the important difference that---for each simulation---we are 
drawing the values for h~1~ and h~2~ from the same column of dataframe `DATA1`.

```{r eq-I-recrates-sim, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 = I2
I1=10
I2=10

# leaching rate
l = 0.1

# Allocate an empty data frame to save the data in
PREDeqrecrates <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDeqrecrates <-rbind(PREDeqrecrates, data.frame(TIME=seq(0,100,1), hDIFF = seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
# producers uptake rates
u1 = DATA1[i1,2] # in ecosystem 1
u2 = DATA1[i1,3] # in ecosystem 2
# consumers attack rates
a1 = DATA1[i1,4]
a2 = DATA1[i1,5]
# death rates (= recycling rate) for producers---in this scenario these are equal
h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 1---NOTE: it is equal to h2
h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2---NOTE: it is equal to h1
# death rates (= recycling rate) for consumers
d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
c = DATA1[i1,10] # death rate in the disperser's pool Q
# movement rate to the Disperser's pool Q
g = DATA1[i1,11]
# movement rate from the Disperser's pool Q
m = DATA1[i1,12]
# efficiency of consumers 
e1 = DATA2[i1,2] # in ecosystem 1
e2 = DATA2[i1,3] # in ecosystem 2

PREDeqrecrates[i1,] <- c(i1, (h1 - h2), I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
               ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (d1 + g)/(a1*e1),
               (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
               (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
               (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*h1)/(a1*e1),
               (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
               )
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDeqrecrates$Ntot <- PREDeqrecrates$N1 + PREDeqrecrates$N2
PREDeqrecrates$Ptot <- PREDeqrecrates$P1 + PREDeqrecrates$P2
PREDeqrecrates$Ctot <- PREDeqrecrates$C1 + PREDeqrecrates$C2

# now calculate recycling flux for the local ecosystem
PREDeqrecrates$FLUX_Eco1_check <- PREDeqrecrates$FLUX_P1 + PREDeqrecrates$FLUX_C1
PREDeqrecrates$FLUX_Eco2_check <- PREDeqrecrates$FLUX_P2 + PREDeqrecrates$FLUX_C2
# and the meta-ecosystem recycling flux
PREDeqrecrates$FLUX_Ptot <- PREDeqrecrates$FLUX_P1 + PREDeqrecrates$FLUX_P2
PREDeqrecrates$FLUX_Ctot <- PREDeqrecrates$FLUX_C1 + PREDeqrecrates$FLUX_C2
PREDeqrecrates$MetaEcoFlux <- PREDeqrecrates$FLUX_Eco_1 + PREDeqrecrates$FLUX_Eco_2 - PREDeqrecrates$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDeqrecrates <- dplyr::mutate(PREDeqrecrates, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDeqrecrates <- dplyr::mutate(PREDeqrecrates, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDeqrecratespos <- subset(PREDeqrecrates, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

The graph below shows the variation in nutrient stock and median biomass 
values for all trophic compartments at local and meta-ecosystem scales. 

```{r eq-I-recrates-bm, echo=TRUE, tidy=TRUE, fig.cap="Nutrient stock and biomass values at local and meta-ecosystem scales when h~1~ = h~2~, and environmental fertility is the same in both local ecosystems. The median values are virtually indistinguishable from those in Figure 1."}
# pivot the data frame containing the predictions
PREDeqrecrates_biomass_long <- pivot_longer(PREDeqrecratespos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDeqrecrates_biomass_long$Compartment <- as_factor(PREDeqrecrates_biomass_long$Compartment)
PREDeqrecrates_biomass_long$Ecosystem <- as_factor(PREDeqrecrates_biomass_long$Ecosystem)

comparts_medians <- PREDeqrecrates_biomass_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

eqIbm <- ggplot(data=PREDeqrecrates_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")

eqIbm
```

Nutrient flux in both local and meta-ecosystem when h~1~ = h~2~ (Figure 
\@ref(fig:eq-I-recrates-flux))  does not appear to differ from the above 
simulations in which h~1~ and h~2~ were both randomly drawn from a uniform 
distribution scaled between [0,10] (Figure \@ref(fig:nut-flux-equal-I)). 

```{r eq-I-recrates-flux, echo=TRUE,tidy=TRUE,fig.cap="Nutrient flux median values in all trophic compartment at the two scales of interest, local and meta-ecosystem. There is a small increase in the values of nutrient flux for producers and consumers, in the recipient ecosystem, and for the whole meta-ecosystem. Curiously, while individual trophic compartments in ecosystem 2 show higher flux values comapred to Figure 5, nutrient flux for the whole recipient ecosystem is slightly lower than in Figure 5."}
FluxPREDeqrecrates <- PREDeqrecratespos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem")))

FluxPREDeqrecrates$Scale <- as.factor(FluxPREDeqrecrates$Scale)
FluxPREDeqrecrates$Compartment <- as.factor(FluxPREDeqrecrates$Compartment)

comparts_medians <- FluxPREDeqrecrates %>% dplyr::group_by(Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

eqInf <- FluxPREDeqrecrates %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 350)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())

eqInf

eqIall <- eqIbm + eqInf + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") + plot_layout(ncol = 1, nrow = 2)

#ggsave(eqIall, filename = "../Results/BM_eqIeqh.png", device = "png", dpi = 300, width = 8, height = 6)
```

#### Higher producers' recycling rate in the donor ecosystem

To investigate the effects of higher recycling rate in the donor ecosystem, we 
will simulate the model's behavior using differences of increasing magnitude. 
We will start with a 10% difference in the producers' recycling rate in donor 
ecosystem compared to the recipient ecosystem and then move on from there to 
test larger differences. The mathematical formula that we will use to apply the 
increase is $h_1 = h_2 + (h_2 \cdot x)$, where $x$ varies from 10% up to 90% 
by 20% increments.

First, we store the increasing $x$ values in a new vector, `hdiff`.

```{r hdiff-values, echo=TRUE, tidy=TRUE}
hdiff <- seq(0.1, 0.9, 0.2)
```

Then, we again use a nested loop to run the simulations with each element in 
`hdiff`.

```{r high-h1, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 = I2
I1=10
I2=10

# leaching rate
l = 0.1

# allocate empty dataframe to store simulations results
PREDhigh_h1 <- NULL

for (j in 1:length(hdiff)) {
  # Allocate a temporary empty data frame to save the data in
  PREDtemp <- NULL
  # Allocate some rows and columns. We will replace the current numbers with results below
  # Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)
  
  PREDtemp <-rbind(PREDtemp, data.frame(TIME = seq(0,100,1), hDIFF = seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))
  
  # We want to start simulations at 0
  i1 = 0
  
  for (i in seq(0,999,1)){
  	# go to the next row
  	i1 = i1 + 1
  
  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate) for producers---h1 > h2
  h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2
  h1 = h2 + (h2*hdiff[j]) # death (=recycling) rate for producers in ecosystem 1
  # death rates (= recycling rate) for consumers
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Disperser's pool Q
  g = DATA1[i1,11]
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,12]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDtemp[i1,] <- c(i1, hdiff[j], I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g,
                     m, c, e1, e2, 
                     ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                     (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*h1)/(a1*e1),
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
  }
  
  # store the results from the j-th round of simulations into the persistent dataframe
  PREDhigh_h1 <- rbind(PREDhigh_h1,PREDtemp)
  
  # print the percentage used in this round of simulations
  # # print(hdiff[j])
  
  # remove the temporary dataframe
  rm(PREDtemp)
  # browser()
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDhigh_h1$Ntot <- PREDhigh_h1$N1 + PREDhigh_h1$N2
PREDhigh_h1$Ptot <- PREDhigh_h1$P1 + PREDhigh_h1$P2
PREDhigh_h1$Ctot <- PREDhigh_h1$C1 + PREDhigh_h1$C2

# now calculate recycling flux for the local ecosystem
PREDhigh_h1$FLUX_Eco1_check <- PREDhigh_h1$FLUX_P1 + PREDhigh_h1$FLUX_C1
PREDhigh_h1$FLUX_Eco2_check <- PREDhigh_h1$FLUX_P2 + PREDhigh_h1$FLUX_C2
# and the meta-ecosystem recycling flux
PREDhigh_h1$FLUX_Ptot <- PREDhigh_h1$FLUX_P1 + PREDhigh_h1$FLUX_P2
PREDhigh_h1$FLUX_Ctot <- PREDhigh_h1$FLUX_C1 + PREDhigh_h1$FLUX_C2
PREDhigh_h1$MetaEcoFlux <- PREDhigh_h1$FLUX_Eco_1 + PREDhigh_h1$FLUX_Eco_2 - PREDhigh_h1$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDhigh_h1 <- dplyr::mutate(PREDhigh_h1, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDhigh_h1 <- dplyr::mutate(PREDhigh_h1, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDhigh_h1pos <- subset(PREDhigh_h1, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

```{r highh1-bmplot, echo=TRUE, tidy=TRUE, fig.cap="At higher producers recycling rates in the donor ecosystem, compared to the recipient ecosystems, correspond higher median nutrient stocks in the donor ecosystem. Grey labels above the graphs show the scale of investigation (local, meta-ecosystems). Grey labels on the right-hand side of the graphs indicate the increase in h~1~ compared to h~2~ ($x$). All specifications as in Figure 1.", fig.show='asis'}
# pivot the data frame containing the predictions
PREDhigh_h1_biomass_long <- pivot_longer(PREDhigh_h1pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDhigh_h1_biomass_long$Compartment <- as_factor(PREDhigh_h1_biomass_long$Compartment)
PREDhigh_h1_biomass_long$Ecosystem <- as_factor(PREDhigh_h1_biomass_long$Ecosystem)
PREDhigh_h1_biomass_long$hDIFF <- as_factor(PREDhigh_h1_biomass_long$hDIFF)

comparts_medians <- PREDhigh_h1_biomass_long %>% dplyr::group_by(hDIFF, Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data = PREDhigh_h1_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.15, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-15, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r eq-I-highh1-flux, echo=TRUE,tidy=TRUE,fig.cap="As for biomass and stocks, differences in producers recycling rates between local ecosystem influence nutrient flux at both local and meta-ecosystem scales. Here the increase in the median value for nutrient flux in both producers trophic compartment and the donor ecosystem (Ecosystem 1) overall is clearly visible, as it is at the meta-ecosystem scale.", fig.show='asis'}
FluxPREDhigh_h1 <- PREDhigh_h1pos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDhigh_h1$Scale <- as.factor(FluxPREDhigh_h1$Scale)
FluxPREDhigh_h1$Compartment <- as.factor(FluxPREDhigh_h1$Compartment)
FluxPREDhigh_h1$hDIFF <- as.factor(FluxPREDhigh_h1$hDIFF)

comparts_medians <- FluxPREDhigh_h1 %>% dplyr::group_by(hDIFF, Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPREDhigh_h1 %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-20, 350)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())
```

#### Higher producers' recycling rates in the recipient ecosystem

Here, we reverse the scenario above, investigating how primary productivity and 
nutrient flux vary at local and meta-ecosystem scales when the producers' 
recycling rate in the donor ecosystem is lower than in the recipient ecosystem. 
As above, we will use a set of five threshold differences in these simulations 
(object `hdiff`).

```{r high-h2, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 = I2
I1=10
I2=10

# leaching rate
l = 0.1

# allocate empty dataframe to store simulations results
PREDhigh_h2 <- NULL

for (j in 1:length(hdiff)) {
  # Allocate a temporary empty data frame to save the data in
  PREDtemp <- NULL
  # Allocate some rows and columns. We will replace the current numbers with results below
  # Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)
  
  PREDtemp <-rbind(PREDtemp, data.frame(TIME = seq(0,100,1), hDIFF = seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))
  
  # We want to start simulations at 0
  i1 = 0
  
  for (i in seq(0,999,1)){
  	# go to the next row
  	i1 = i1 + 1
  
  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate) for producers---h1 < h2
  h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2
  h1 = h2 - (h2*hdiff[j]) # death (=recycling) rate for producers in ecosystem 1
  # death rates (= recycling rate) for consumers
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Disperser's pool Q
  g = DATA1[i1,11]
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,12]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDtemp[i1,] <- c(i1, hdiff[j], I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g,
                     m, c, e1, e2, 
                     ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                     (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*h1)/(a1*e1),
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
  }
  
  # store the results from the j-th round of simulations into the persistent dataframe
  PREDhigh_h2 <- rbind(PREDhigh_h2,PREDtemp)
  
  # print the percentage used in this round of simulations
  # print(hdiff[j])
  
  # remove the temporary dataframe
  rm(PREDtemp)
  # browser()
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDhigh_h2$Ntot <- PREDhigh_h2$N1 + PREDhigh_h2$N2
PREDhigh_h2$Ptot <- PREDhigh_h2$P1 + PREDhigh_h2$P2
PREDhigh_h2$Ctot <- PREDhigh_h2$C1 + PREDhigh_h2$C2

# now calculate recycling flux for the local ecosystem
PREDhigh_h2$FLUX_Eco1_check <- PREDhigh_h2$FLUX_P1 + PREDhigh_h2$FLUX_C1
PREDhigh_h2$FLUX_Eco2_check <- PREDhigh_h2$FLUX_P2 + PREDhigh_h2$FLUX_C2
# and the meta-ecosystem recycling flux
PREDhigh_h2$FLUX_Ptot <- PREDhigh_h2$FLUX_P1 + PREDhigh_h2$FLUX_P2
PREDhigh_h2$FLUX_Ctot <- PREDhigh_h2$FLUX_C1 + PREDhigh_h2$FLUX_C2
PREDhigh_h2$MetaEcoFlux <- PREDhigh_h2$FLUX_Eco_1 + PREDhigh_h2$FLUX_Eco_2 - PREDhigh_h2$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDhigh_h2 <- dplyr::mutate(PREDhigh_h2, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDhigh_h2 <- dplyr::mutate(PREDhigh_h2, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDhigh_h2pos <- subset(PREDhigh_h2, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

```{r highh2-bmplot, echo=TRUE, tidy=TRUE, fig.cap="Nutrients stocks and biomass values when h~1~ is increasingly smaller than h~2~. The reduction in producers recycling rates in the donor ecosystem, compared to the recipient, leads to a strong decrease of the median value of nutrients stock in this patch. In turn, this leads to a lower nutrient availability at the meta-ecosystem scale.", fig.show='asis'}
# pivot the data frame containing the predictions
PREDhigh_h2_biomass_long <- pivot_longer(PREDhigh_h2pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDhigh_h2_biomass_long$Compartment <- as_factor(PREDhigh_h2_biomass_long$Compartment)
PREDhigh_h2_biomass_long$Ecosystem <- as_factor(PREDhigh_h2_biomass_long$Ecosystem)
PREDhigh_h2_biomass_long$hDIFF <- as_factor(PREDhigh_h2_biomass_long$hDIFF)

comparts_medians <- PREDhigh_h2_biomass_long %>% dplyr::group_by(hDIFF, Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data = PREDhigh_h2_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.15, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-15, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r eq-I-highh2-flux, echo=TRUE,tidy=TRUE,fig.cap="Median nutrient flux falls in the donor ecosystem (ecosystem 1) as a consequence of the lower producers' recycling rate in it, compared to ecosystem 2 (the recipient). In turn, this leads to an overall reduction of nutrient flux when considering the whole meta-ecosystem.", fig.show='asis'}
FluxPREDhigh_h2 <- PREDhigh_h2pos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDhigh_h2$Scale <- as.factor(FluxPREDhigh_h2$Scale)
FluxPREDhigh_h2$Compartment <- as.factor(FluxPREDhigh_h2$Compartment)
FluxPREDhigh_h2$hDIFF <- as.factor(FluxPREDhigh_h2$hDIFF)

comparts_medians <- FluxPREDhigh_h2 %>% dplyr::group_by(hDIFF, Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPREDhigh_h2 %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines")) + 
  facet_grid(hDIFF~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-35, 350)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())
```

Below, we simulate the behaviour of the model when environmental fertility 
conditions differ among local ecosystems. Let's start with the case of higher 
environmental fertility in the donor ecosystem.

### Higher environmental fertility in the donor ecosystem

We begin by increasing the environmental fertility in the donor 
ecosystem, so that $I_1 > I_2$. As before, we will simulate three 
scenarios for producers' recycling rates: equal, higher in ecosystem 1, 
and higher in ecosystem 2.

#### Equal primary producers recycling rates

```{r I1-recrates-sim, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 < I2
I1=18
I2=2

# leaching rate
l = 0.1

# Allocate an empty data frame to save the data in
PREDI1recrates <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDI1recrates <-rbind(PREDI1recrates, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
# producers uptake rates
u1 = DATA1[i1,2] # in ecosystem 1
u2 = DATA1[i1,3] # in ecosystem 2
# consumers attack rates
a1 = DATA1[i1,4]
a2 = DATA1[i1,5]
# death rates (= recycling rate) for producers---in this scenario these are equal
h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 1---NOTE: it is equal to h2
h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2---NOTE: it is equal to h1
# death rates (= recycling rate) for consumers
d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
c = DATA1[i1,10] # death rate in the disperser's pool Q
# movement rate to the Disperser's pool Q
g = DATA1[i1,11]
# movement rate from the Disperser's pool Q
m = DATA1[i1,12]
# efficiency of consumers 
e1 = DATA2[i1,2] # in ecosystem 1
e2 = DATA2[i1,3] # in ecosystem 2

PREDI1recrates[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
               ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (d1 + g)/(a1*e1),
               (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
               (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
               (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*h1)/(a1*e1),
               (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
               )
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDI1recrates$Ntot <- PREDI1recrates$N1 + PREDI1recrates$N2
PREDI1recrates$Ptot <- PREDI1recrates$P1 + PREDI1recrates$P2
PREDI1recrates$Ctot <- PREDI1recrates$C1 + PREDI1recrates$C2

# now calculate recycling flux for the local ecosystem
PREDI1recrates$FLUX_Eco1_check <- PREDI1recrates$FLUX_P1 + PREDI1recrates$FLUX_C1
PREDI1recrates$FLUX_Eco2_check <- PREDI1recrates$FLUX_P2 + PREDI1recrates$FLUX_C2
# and the meta-ecosystem recycling flux
PREDI1recrates$FLUX_Ptot <- PREDI1recrates$FLUX_P1 + PREDI1recrates$FLUX_P2
PREDI1recrates$FLUX_Ctot <- PREDI1recrates$FLUX_C1 + PREDI1recrates$FLUX_C2
PREDI1recrates$MetaEcoFlux <- PREDI1recrates$FLUX_Eco_1 + PREDI1recrates$FLUX_Eco_2 - PREDI1recrates$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDI1recrates <- dplyr::mutate(PREDI1recrates, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDI1recrates <- dplyr::mutate(PREDI1recrates, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDI1recratespos <- subset(PREDI1recrates, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

```{r I1-recrates-bm, echo=TRUE, tidy=TRUE, fig.cap="Differing primary producers' recycling rates do not appreciably change the median nutrient stock and median biomass values at either local or meta-ecosystem scale (compare with Figure 18).", fig.show='asis'}
# pivot the data frame containing the predictions
PREDI1recrates_biomass_long <- pivot_longer(PREDI1recratespos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDI1recrates_biomass_long$Compartment <- as_factor(PREDI1recrates_biomass_long$Compartment)
PREDI1recrates_biomass_long$Ecosystem <- as_factor(PREDI1recrates_biomass_long$Ecosystem)

comparts_medians <- PREDI1recrates_biomass_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data=PREDI1recrates_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.15, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r I1-recrates-flux, echo=TRUE,tidy=TRUE,fig.cap="Nutrient flux median values in all trophic compartment at the two scales of interest, local and meta-ecosystem. When h~1~ = h~2~ and consumers move from a more to a less fertile ecosystem, nutrient flux at the meta-ecosystem scale is much lower than in the corresponding case when local fertility is equivalent between donor and recipient ecosystem (Figure 23).", fig.show='asis'}
FluxPREDI1recrates <- PREDI1recratespos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDI1recrates$Scale <- as.factor(FluxPREDI1recrates$Scale)
FluxPREDI1recrates$Compartment <- as.factor(FluxPREDI1recrates$Compartment)

comparts_medians <- FluxPREDI1recrates %>% dplyr::group_by(Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPREDI1recrates %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 350)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())
```

#### Higher producers' recycling rate in the donor ecosystem

Here, we will use the same set of increasing percentage stored in 
`hdiff` to investigate how productivity and nutrient flux vary at local 
and meta-ecosystem scale when material lost from producers in ecosystem 
1 is more recycling-available than in ecosystem 2. 

```{r high-I1h1, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 > I2
I1=18
I2=2

# leaching rate
l = 0.1

# allocate empty dataframe to store simulations results
PREDhigh_I1h1 <- NULL

for (j in 1:length(hdiff)) {
  # Allocate a temporary empty data frame to save the data in
  PREDtemp <- NULL
  # Allocate some rows and columns. We will replace the current numbers with results below
  # Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)
  
  PREDtemp <-rbind(PREDtemp, data.frame(TIME = seq(0,100,1), hDIFF = seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))
  
  # We want to start simulations at 0
  i1 = 0
  
  for (i in seq(0,999,1)){
  	# go to the next row
  	i1 = i1 + 1
  
  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate) for producers---h1 > h2
  h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2
  h1 = h2 + (h2*hdiff[j]) # death (=recycling) rate for producers in ecosystem 1
  # death rates (= recycling rate) for consumers
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Disperser's pool Q
  g = DATA1[i1,11]
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,12]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDtemp[i1,] <- c(i1, hdiff[j], I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g,
                     m, c, e1, e2, 
                     ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                     (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*h1)/(a1*e1),
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
  }
  
  # store the results from the j-th round of simulations into the persistent dataframe
  PREDhigh_I1h1 <- rbind(PREDhigh_I1h1,PREDtemp)
  
  # print the percentage used in this round of simulations
  # print(hdiff[j])
  
  # remove the temporary dataframe
  rm(PREDtemp)
  # browser()
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDhigh_I1h1$Ntot <- PREDhigh_I1h1$N1 + PREDhigh_I1h1$N2
PREDhigh_I1h1$Ptot <- PREDhigh_I1h1$P1 + PREDhigh_I1h1$P2
PREDhigh_I1h1$Ctot <- PREDhigh_I1h1$C1 + PREDhigh_I1h1$C2

# now calculate recycling flux for the local ecosystem
PREDhigh_I1h1$FLUX_Eco1_check <- PREDhigh_I1h1$FLUX_P1 + PREDhigh_I1h1$FLUX_C1
PREDhigh_I1h1$FLUX_Eco2_check <- PREDhigh_I1h1$FLUX_P2 + PREDhigh_I1h1$FLUX_C2
# and the meta-ecosystem recycling flux
PREDhigh_I1h1$FLUX_Ptot <- PREDhigh_I1h1$FLUX_P1 + PREDhigh_I1h1$FLUX_P2
PREDhigh_I1h1$FLUX_Ctot <- PREDhigh_I1h1$FLUX_C1 + PREDhigh_I1h1$FLUX_C2
PREDhigh_I1h1$MetaEcoFlux <- PREDhigh_I1h1$FLUX_Eco_1 + PREDhigh_I1h1$FLUX_Eco_2 - PREDhigh_I1h1$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDhigh_I1h1 <- dplyr::mutate(PREDhigh_I1h1, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDhigh_I1h1 <- dplyr::mutate(PREDhigh_I1h1, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDhigh_I1h1pos <- subset(PREDhigh_I1h1, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

```{r highI1h1-bmplot, echo=TRUE, tidy=TRUE, fig.cap="As h~1~ increases compared to h~2~, median nutrient stock in ecosystem 1 does too. In turn, this leads to a higher median nutrient stock value at the meta-ecosystem scale.", fig.show='asis'}
# pivot the data frame containing the predictions
PREDhigh_I1h1_biomass_long <- pivot_longer(PREDhigh_I1h1pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool") 

PREDhigh_I1h1_biomass_long$Compartment <- as_factor(PREDhigh_I1h1_biomass_long$Compartment)
PREDhigh_I1h1_biomass_long$Ecosystem <- as_factor(PREDhigh_I1h1_biomass_long$Ecosystem)
PREDhigh_I1h1_biomass_long$hDIFF <- as_factor(PREDhigh_I1h1_biomass_long$hDIFF)

comparts_medians <- PREDhigh_I1h1_biomass_long %>% dplyr::group_by(hDIFF, Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data = PREDhigh_I1h1_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.15, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-15, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r highI1h1-flux, echo=TRUE,tidy=TRUE,fig.cap="As producers' recycling rate increase, so does median nutrient flux in ecosystem 1. In turn, the whole meta-ecosystem experiences heightened median values of nutrient flux.", fig.show='asis'}
FluxPREDhigh_I1h1 <- PREDhigh_I1h1pos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDhigh_I1h1$Scale <- as.factor(FluxPREDhigh_I1h1$Scale)
FluxPREDhigh_I1h1$Compartment <- as.factor(FluxPREDhigh_I1h1$Compartment)
FluxPREDhigh_I1h1$hDIFF <- as.factor(FluxPREDhigh_I1h1$hDIFF)

comparts_medians <- FluxPREDhigh_I1h1 %>% dplyr::group_by(hDIFF, Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPREDhigh_I1h1 %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-20, 350)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())
```

#### Higher producers' recycling rates in the recipient ecosystem

Here, when environmental fertility is higher in ecosystem 1, producers 
are less recycling-available and recycling of lost producers biomass is 
easier in ecosystem 2 (the recipient).

```{r high-I1h2, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 = I2
I1=18
I2=2

# leaching rate
l = 0.1

# allocate empty dataframe to store simulations results
PREDhigh_I1h2 <- NULL

for (j in 1:length(hdiff)) {
  # Allocate a temporary empty data frame to save the data in
  PREDtemp <- NULL
  # Allocate some rows and columns. We will replace the current numbers with results below
  # Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)
  
  PREDtemp <-rbind(PREDtemp, data.frame(TIME = seq(0,100,1), hDIFF = seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))
  
  # We want to start simulations at 0
  i1 = 0
  
  for (i in seq(0,999,1)){
  	# go to the next row
  	i1 = i1 + 1
  
  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate) for producers---h1 < h2
  h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2
  h1 = h2 - (h2*hdiff[j]) # death (=recycling) rate for producers in ecosystem 1
  # death rates (= recycling rate) for consumers
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Disperser's pool Q
  g = DATA1[i1,11]
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,12]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDtemp[i1,] <- c(i1, hdiff[j], I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g,
                     m, c, e1, e2, 
                     ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                     (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*h1)/(a1*e1),
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
  }
  
  # store the results from the j-th round of simulations into the persistent dataframe
  PREDhigh_I1h2 <- rbind(PREDhigh_I1h2,PREDtemp)
  
  # print the percentage used in this round of simulations
  # print(hdiff[j])
  
  # remove the temporary dataframe
  rm(PREDtemp)
  # browser()
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDhigh_I1h2$Ntot <- PREDhigh_I1h2$N1 + PREDhigh_I1h2$N2
PREDhigh_I1h2$Ptot <- PREDhigh_I1h2$P1 + PREDhigh_I1h2$P2
PREDhigh_I1h2$Ctot <- PREDhigh_I1h2$C1 + PREDhigh_I1h2$C2

# now calculate recycling flux for the local ecosystem
PREDhigh_I1h2$FLUX_Eco1_check <- PREDhigh_I1h2$FLUX_P1 + PREDhigh_I1h2$FLUX_C1
PREDhigh_I1h2$FLUX_Eco2_check <- PREDhigh_I1h2$FLUX_P2 + PREDhigh_I1h2$FLUX_C2
# and the meta-ecosystem recycling flux
PREDhigh_I1h2$FLUX_Ptot <- PREDhigh_I1h2$FLUX_P1 + PREDhigh_I1h2$FLUX_P2
PREDhigh_I1h2$FLUX_Ctot <- PREDhigh_I1h2$FLUX_C1 + PREDhigh_I1h2$FLUX_C2
PREDhigh_I1h2$MetaEcoFlux <- PREDhigh_I1h2$FLUX_Eco_1 + PREDhigh_I1h2$FLUX_Eco_2 - PREDhigh_I1h2$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDhigh_I1h2 <- dplyr::mutate(PREDhigh_I1h2, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDhigh_I1h2 <- dplyr::mutate(PREDhigh_I1h2, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDhigh_I1h2pos <- subset(PREDhigh_I1h2, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

```{r highI1h2-bmplot, echo=TRUE, tidy=TRUE, fig.cap="Reduced recycling rates for producers in ecosystem 1 lead a decrease un nutrient stocks at both local and meta-ecosystem scales.", fig.show='asis'}
# pivot the data frame containing the predictions
PREDhigh_I1h2_biomass_long <- pivot_longer(PREDhigh_I1h2pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDhigh_I1h2_biomass_long$Compartment <- as_factor(PREDhigh_I1h2_biomass_long$Compartment)
PREDhigh_I1h2_biomass_long$Ecosystem <- as_factor(PREDhigh_I1h2_biomass_long$Ecosystem)
PREDhigh_I1h2_biomass_long$hDIFF <- as_factor(PREDhigh_I1h2_biomass_long$hDIFF)

comparts_medians <- PREDhigh_I1h2_biomass_long %>% dplyr::group_by(hDIFF, Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data = PREDhigh_I1h2_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.15, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-15, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r highI1h2-flux, echo=TRUE,tidy=TRUE,fig.cap="Producers' nutrient flux in ecosystem 1 decreases following reduced recycling rates, compared to ecosystem 2. In turn, this leads to a reduction of nutrient flux at both local and meta-ecosystem scales.", fig.show='asis'}
FluxPREDhigh_I1h2 <- PREDhigh_I1h2pos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDhigh_I1h2$Scale <- as.factor(FluxPREDhigh_I1h2$Scale)
FluxPREDhigh_I1h2$Compartment <- as.factor(FluxPREDhigh_I1h2$Compartment)
FluxPREDhigh_I1h2$hDIFF <- as.factor(FluxPREDhigh_I1h2$hDIFF)

comparts_medians <- FluxPREDhigh_I1h2 %>% dplyr::group_by(hDIFF, Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPREDhigh_I1h2 %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines")) + 
  facet_grid(hDIFF~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-35, 350)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())
```

### Higher environmental fertility in recipient ecosystem

Here, we investigate how varying the relative magnitude of producers' 
recycling rates (h~i~, i $\in [1,1]$) in the local ecosystems influences 
local and meta-ecosystem functions, when the recipient ecosystem is more 
fertile than the donor. Hence, this is a test of the interaction between 
producers' recycling rates and non-diffusive, against-gradient consumer 
movememt. As in previous simulations, we begin by testing the case of equal 
h~i~, then the case of h~1~ > h~2~, and finally the case of h~1~ < h~2~.

#### Equal primary producers recycling rates

As a baseline case, here we simulate the case of h~1~ = h~2~ while environmental
fertility is much higher in the recipient ecosystem compared to the donor.

```{r I2-recrates-sim, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 < I2
I1=2
I2=18

# leaching rate
l = 0.1

# Allocate an empty data frame to save the data in
PREDI2recrates <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDI2recrates <-rbind(PREDI2recrates, data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
# producers uptake rates
u1 = DATA1[i1,2] # in ecosystem 1
u2 = DATA1[i1,3] # in ecosystem 2
# consumers attack rates
a1 = DATA1[i1,4]
a2 = DATA1[i1,5]
# death rates (= recycling rate) for producers---in this scenario these are equal
h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 1---NOTE: it is equal to h2
h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2---NOTE: it is equal to h1
# death rates (= recycling rate) for consumers
d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
c = DATA1[i1,10] # death rate in the disperser's pool Q
# movement rate to the Disperser's pool Q
g = DATA1[i1,11]
# movement rate from the Disperser's pool Q
m = DATA1[i1,12]
# efficiency of consumers 
e1 = DATA2[i1,2] # in ecosystem 1
e2 = DATA2[i1,3] # in ecosystem 2

PREDI2recrates[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
               ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (d1 + g)/(a1*e1),
               (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
               (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
               (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*h1)/(a1*e1),
               (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
               (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
               (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
               )
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDI2recrates$Ntot <- PREDI2recrates$N1 + PREDI2recrates$N2
PREDI2recrates$Ptot <- PREDI2recrates$P1 + PREDI2recrates$P2
PREDI2recrates$Ctot <- PREDI2recrates$C1 + PREDI2recrates$C2

# now calculate recycling flux for the local ecosystem
PREDI2recrates$FLUX_Eco1_check <- PREDI2recrates$FLUX_P1 + PREDI2recrates$FLUX_C1
PREDI2recrates$FLUX_Eco2_check <- PREDI2recrates$FLUX_P2 + PREDI2recrates$FLUX_C2
# and the meta-ecosystem recycling flux
PREDI2recrates$FLUX_Ptot <- PREDI2recrates$FLUX_P1 + PREDI2recrates$FLUX_P2
PREDI2recrates$FLUX_Ctot <- PREDI2recrates$FLUX_C1 + PREDI2recrates$FLUX_C2
PREDI2recrates$MetaEcoFlux <- PREDI2recrates$FLUX_Eco_1 + PREDI2recrates$FLUX_Eco_2 - PREDI2recrates$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDI2recrates <- dplyr::mutate(PREDI2recrates, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDI2recrates <- dplyr::mutate(PREDI2recrates, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDI2recratespos <- subset(PREDI2recrates, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

```{r I2-recrates-bm, echo=TRUE, tidy=TRUE, fig.cap="Equal recycling rates for primary producers in the local ecosystems lead to environmental fertility playing the larger role in determining local and meta-ecosystem stocks of nutrients and biomass, as seen in Figure 34 above.", fig.show='asis'}
# pivot the data frame containing the predictions
PREDI2recrates_biomass_long <- pivot_longer(PREDI2recratespos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDI2recrates_biomass_long$Compartment <- as_factor(PREDI2recrates_biomass_long$Compartment)
PREDI2recrates_biomass_long$Ecosystem <- as_factor(PREDI2recrates_biomass_long$Ecosystem)

comparts_medians <- PREDI2recrates_biomass_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data=PREDI2recrates_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.15, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r I2-recrates-flux, echo=TRUE,tidy=TRUE,fig.cap="Nutrient flux in local and meta-ecosystem, when producers have equal recycling rates and the recipient ecosystem (ecosystem 2) is much more fertile than the donor ecosystem.", fig.show='asis'}
FluxPREDI2recrates <- PREDI2recratespos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDI2recrates$Scale <- as.factor(FluxPREDI2recrates$Scale)
FluxPREDI2recrates$Compartment <- as.factor(FluxPREDI2recrates$Compartment)

comparts_medians <- FluxPREDI2recrates %>% dplyr::group_by(Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPREDI2recrates %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(.~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(0, 550)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())
```

#### Higher producers' recycling rate in the donor ecosystem

Here, we investigate the case of higher recycling rate for producers in the 
donor ecosystem compared to the recipient, when fertility is higher in the 
latter. As above, we use the formula $h_1 = h_2 + (h_2 \cdot x)$, with 
$x \in [0.1, 0.9]$, to calculate the difference between the recycling rates. 

```{r high-I2h1, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 < I2
I1=2
I2=18

# leaching rate
l = 0.1

# allocate empty dataframe to store simulations results
PREDhigh_I2h1 <- NULL

for (j in 1:length(hdiff)) {
  # Allocate a temporary empty data frame to save the data in
  PREDtemp <- NULL
  # Allocate some rows and columns. We will replace the current numbers with results below
  # Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)
  
  PREDtemp <-rbind(PREDtemp, data.frame(TIME = seq(0,100,1), hDIFF = seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))
  
  # We want to start simulations at 0
  i1 = 0
  
  for (i in seq(0,999,1)){
  	# go to the next row
  	i1 = i1 + 1
  
  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate) for producers---h1 > h2
  h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2
  h1 = h2 + (h2*hdiff[j]) # death (=recycling) rate for producers in ecosystem 1
  # death rates (= recycling rate) for consumers
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Disperser's pool Q
  g = DATA1[i1,11]
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,12]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDtemp[i1,] <- c(i1, hdiff[j], I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g,
                     m, c, e1, e2, 
                     ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                     (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*h1)/(a1*e1),
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
  }
  
  # store the results from the j-th round of simulations into the persistent dataframe
  PREDhigh_I2h1 <- rbind(PREDhigh_I2h1,PREDtemp)
  
  # print the percentage used in this round of simulations
  # print(hdiff[j])
  
  # remove the temporary dataframe
  rm(PREDtemp)
  # browser()
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDhigh_I2h1$Ntot <- PREDhigh_I2h1$N1 + PREDhigh_I2h1$N2
PREDhigh_I2h1$Ptot <- PREDhigh_I2h1$P1 + PREDhigh_I2h1$P2
PREDhigh_I2h1$Ctot <- PREDhigh_I2h1$C1 + PREDhigh_I2h1$C2

# now calculate recycling flux for the local ecosystem
PREDhigh_I2h1$FLUX_Eco1_check <- PREDhigh_I2h1$FLUX_P1 + PREDhigh_I2h1$FLUX_C1
PREDhigh_I2h1$FLUX_Eco2_check <- PREDhigh_I2h1$FLUX_P2 + PREDhigh_I2h1$FLUX_C2
# and the meta-ecosystem recycling flux
PREDhigh_I2h1$FLUX_Ptot <- PREDhigh_I2h1$FLUX_P1 + PREDhigh_I2h1$FLUX_P2
PREDhigh_I2h1$FLUX_Ctot <- PREDhigh_I2h1$FLUX_C1 + PREDhigh_I2h1$FLUX_C2
PREDhigh_I2h1$MetaEcoFlux <- PREDhigh_I2h1$FLUX_Eco_1 + PREDhigh_I2h1$FLUX_Eco_2 - PREDhigh_I2h1$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDhigh_I2h1 <- dplyr::mutate(PREDhigh_I2h1, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDhigh_I2h1 <- dplyr::mutate(PREDhigh_I2h1, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDhigh_I2h1pos <- subset(PREDhigh_I2h1, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

```{r highI2h1-bmplot, echo=TRUE, tidy=TRUE, fig.cap="As h~1~ increases, compared to h~2~, median nutrient stock in the donor ecosystem increases, and so does at the meta-ecosystem scale. Interestingly, we note a small but constant increase in median consumers' biomass in ecosystem 2 happening alongside the nutrient stock increase in ecosystem, which similarly leads to a smalll increase in consumers biomass at the meta-ecosystem scale.", fig.show='asis'}
# pivot the data frame containing the predictions
PREDhigh_I2h1_biomass_long <- pivot_longer(PREDhigh_I2h1pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool") 

PREDhigh_I2h1_biomass_long$Compartment <- as_factor(PREDhigh_I2h1_biomass_long$Compartment)
PREDhigh_I2h1_biomass_long$Ecosystem <- as_factor(PREDhigh_I2h1_biomass_long$Ecosystem)
PREDhigh_I2h1_biomass_long$hDIFF <- as_factor(PREDhigh_I2h1_biomass_long$hDIFF)

comparts_medians <- PREDhigh_I2h1_biomass_long %>% dplyr::group_by(hDIFF, Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data = PREDhigh_I2h1_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.15, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-15, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r highI2h1-flux, echo=TRUE,tidy=TRUE,fig.cap=" ", fig.show='asis'}
FluxPREDhigh_I2h1 <- PREDhigh_I2h1pos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDhigh_I2h1$Scale <- as.factor(FluxPREDhigh_I2h1$Scale)
FluxPREDhigh_I2h1$Compartment <- as.factor(FluxPREDhigh_I2h1$Compartment)
FluxPREDhigh_I2h1$hDIFF <- as.factor(FluxPREDhigh_I2h1$hDIFF)

comparts_medians <- FluxPREDhigh_I2h1 %>% dplyr::group_by(hDIFF, Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPREDhigh_I2h1 %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-20, 350)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())
```

#### Higher producers' recycling rates in the recipient ecosystem

Finally, we investigate the case in which the recipient ecosystem (ecosystem 2) 
benefits from both higher environmental fertility and higher primary producers' 
recycling rates. As before, we calculate the higher h~2~ in ecosystem 2 as
$h_1 = h_2 - (h_2 \cdot x)$, with $x \in [0.1, 0.9]$.

```{r high-I2h2, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 < I2
I1=2
I2=18

# leaching rate
l = 0.1

# allocate empty dataframe to store simulations results
PREDhigh_I2h2 <- NULL

for (j in 1:length(hdiff)) {
  # Allocate a temporary empty data frame to save the data in
  PREDtemp <- NULL
  # Allocate some rows and columns. We will replace the current numbers with results below
  # Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)
  
  PREDtemp <-rbind(PREDtemp, data.frame(TIME = seq(0,100,1), hDIFF = seq(0,100,1), I1 = I1,  I2 = I2, l = l, u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))
  
  # We want to start simulations at 0
  i1 = 0
  
  for (i in seq(0,999,1)){
  	# go to the next row
  	i1 = i1 + 1
  
  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate) for producers---h1 < h2
  h2 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystem 2
  h1 = h2 - (h2*hdiff[j]) # death (=recycling) rate for producers in ecosystem 1
  # death rates (= recycling rate) for consumers
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Disperser's pool Q
  g = DATA1[i1,11]
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,12]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDtemp[i1,] <- c(i1, hdiff[j], I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g,
                     m, c, e1, e2, 
                     ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                     (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*h1)/(a1*e1),
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
               (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
               ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
               (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
  }
  
  # store the results from the j-th round of simulations into the persistent dataframe
  PREDhigh_I2h2 <- rbind(PREDhigh_I2h2,PREDtemp)
  
  # print the percentage used in this round of simulations
  # print(hdiff[j])
  
  # remove the temporary dataframe
  rm(PREDtemp)
  # browser()
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDhigh_I2h2$Ntot <- PREDhigh_I2h2$N1 + PREDhigh_I2h2$N2
PREDhigh_I2h2$Ptot <- PREDhigh_I2h2$P1 + PREDhigh_I2h2$P2
PREDhigh_I2h2$Ctot <- PREDhigh_I2h2$C1 + PREDhigh_I2h2$C2

# now calculate recycling flux for the local ecosystem
PREDhigh_I2h2$FLUX_Eco1_check <- PREDhigh_I2h2$FLUX_P1 + PREDhigh_I2h2$FLUX_C1
PREDhigh_I2h2$FLUX_Eco2_check <- PREDhigh_I2h2$FLUX_P2 + PREDhigh_I2h2$FLUX_C2
# and the meta-ecosystem recycling flux
PREDhigh_I2h2$FLUX_Ptot <- PREDhigh_I2h2$FLUX_P1 + PREDhigh_I2h2$FLUX_P2
PREDhigh_I2h2$FLUX_Ctot <- PREDhigh_I2h2$FLUX_C1 + PREDhigh_I2h2$FLUX_C2
PREDhigh_I2h2$MetaEcoFlux <- PREDhigh_I2h2$FLUX_Eco_1 + PREDhigh_I2h2$FLUX_Eco_2 - PREDhigh_I2h2$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PREDhigh_I2h2 <- dplyr::mutate(PREDhigh_I2h2, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDhigh_I2h2 <- dplyr::mutate(PREDhigh_I2h2, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.
PREDhigh_I2h2pos <- subset(PREDhigh_I2h2, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0 & Q>0)
```

```{r highI2h2-bmplot, echo=TRUE, tidy=TRUE, fig.cap="Higher fertility and primary producers recycling rates in the recipient ecosystem lead to reductions in the nutrient stocks and producers biomass of the donor ecosystem. As well, we note a limited inrease in the biomass of consumers in the recipient ecosystem.", fig.show='asis'}
# pivot the data frame containing the predictions
PREDhigh_I2h2_biomass_long <- pivot_longer(PREDhigh_I2h2pos, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDhigh_I2h2_biomass_long$Compartment <- as_factor(PREDhigh_I2h2_biomass_long$Compartment)
PREDhigh_I2h2_biomass_long$Ecosystem <- as_factor(PREDhigh_I2h2_biomass_long$Ecosystem)
PREDhigh_I2h2_biomass_long$hDIFF <- as_factor(PREDhigh_I2h2_biomass_long$hDIFF)

comparts_medians <- PREDhigh_I2h2_biomass_long %>% dplyr::group_by(hDIFF, Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

ggplot(data = PREDhigh_I2h2_biomass_long, aes(x = Compartment, y = Stock, fill = Compartment, col = Compartment)) + 
  geom_boxjitter(alpha = 0.15, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) + 
# stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines"), label.size = 0.15) + 
  facet_grid(hDIFF~Ecosystem, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-15, 100)) + # limits range of y-axis without affecting stats in plot
  theme(legend.position = "none")
```

```{r highI2h2-flux, echo=TRUE,tidy=TRUE,fig.cap="For nutrient flux, the combination of higher fertility and primary producers recycling rates in the recipient ecosystem translate in an reduction at both local and meta-ecosystem scales.", fig.show='asis'}
FluxPREDhigh_I2h2 <- PREDhigh_I2h2pos %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDhigh_I2h2$Scale <- as.factor(FluxPREDhigh_I2h2$Scale)
FluxPREDhigh_I2h2$Compartment <- as.factor(FluxPREDhigh_I2h2$Compartment)
FluxPREDhigh_I2h2$hDIFF <- as.factor(FluxPREDhigh_I2h2$hDIFF)

comparts_medians <- FluxPREDhigh_I2h2 %>% dplyr::group_by(hDIFF, Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPREDhigh_I2h2 %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>% 
  ggplot(., aes(x = Compartment, y = Flux)) + 
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) + 
  # stat_summary(aes(label=round(..y..,2)), fun=median, geom="text", color = "black") + # sanity check on median calculations above
  geom_label(data = comparts_medians, aes(y = median, label = round(median,2)), col = "black", size = 3, fill = "#FFFFFF", alpha = 0.75, nudge_x = -0.18, label.padding = unit(0.15, "lines")) + 
  facet_grid(hDIFF~Scale, scales = "free") + 
  theme_pubr() + 
  coord_cartesian(y = c(-35, 350)) + # limits range of y-axis without affecting stats in plot
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) + 
  theme_pubr() + 
  theme(legend.position = "none", axis.title.x = element_blank())
```

# Visual Deliverables

Here we summarize the above results. First, we summarize the results we obtained
from varying only the environmental fertility conditions of local ecosystems. We
then do the same for the case where we vary both environmental fertility and
primary producers recycling rates. 

We present figures for both the raw data and the log response ratio (LRR) of 
state variable standing stock (henceforth, "stock"), nutrient flux, and primary 
and secondary productivity (henceforth, "productivity"). Our reference for 
calculating the LRR will be the results for the first scenario we ran, 
[Simulating model behavior at equilibrium] (henceforth, _baseline_). In the 
_baseline_ scenario, environmental fertility is homogeneous between local 
ecosystems (i.e., I~1~ = I~2~ = 10) and values for all other parameters in the 
model are selected at random (see above for details). 

Mathematically, the ratio's formula is:

$\displaystyle LRR = log_{10} \biggl(\frac{X_{i, I_1 \neq I_2, h_1 \neq h_2}}{X_{i, I_1 = I_2}}\biggr)$

where $X \in [N, P, C]$ is the trophic compartment of interest, $i$ 
is either the local or meta-ecosystem, and $I_1 \neq I_2$ and 
$h_1 \neq h_2$ represent the relationships between environmental fertility 
conditions and primary producers recycling rates across local ecosystems, 
respectively. 

A value of $LRR = 0$ indicates that the ecosystem function values for scenario in 
question and those for the _baseline_ scenario are perfectly matched. Values 
above 0 indicate that the ecosystem function values for the scenario of interest 
are larger than those of the _baseline_ one. Vice versa, values of $LRR < 0$ 
indicates that the _baseline_ ecosystem function values are larger than those for 
the scenario of interest.

## Environmental Fertility summary

We are working with the `PRED`, `PREDI2`, and `PREDI1` datasets we produced 
above (sections [Simulating model behavior at equilibrium] and 
[Different environmental fertility conditions in local ecosystems]). 
First, we will join them into a new object, `EnvFert_res`. We then select the columns of interest and exclude negative instances of compartment stock values. Finally, we transform the dataset from wide to long format.

```{r envfert-rawdata-df, echo=TRUE,tidy=TRUE}
EnvFert_res <- bind_rows("Equal" = PRED, "Along" = PREDI2, "Against" = PREDI1, .id = "Fertility") %>% select(., Fertility:I2, N1:C2, Ntot:Ctot, FLUX_P1:FLUX_C2, FLUX_Ptot:FLUX_Ctot, PROD_P1:PROD_Ctot)

EnvFert_respos <- subset(EnvFert_res, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0)
```

We now transform this new dataset to a long-format one, for ease of use in
producing the plots. We also add two categorical variables: `Function` and 
`Scale`. `Function` captures the information of the ecosystem function being 
measured. `Scale` captures instead the information of whether the function 
is being measured at the local or meta-ecosystem scale.

```{r envfert-rawdata-wrangling, echo=TRUE,tidy=TRUE}
EnvFert_long <- pivot_longer(EnvFert_respos, cols = N1:PROD_Ctot, names_to = "EcoFunction", values_to = "Value") %>% 
  dplyr::mutate(., Function = if_else(EcoFunction == "N1" | EcoFunction == "N2" | EcoFunction == "P1" | EcoFunction == "P2" | EcoFunction == "C1" | EcoFunction == "C2" | EcoFunction == "Ntot" | EcoFunction == "Ptot" | EcoFunction == "Ctot", "Stock", if_else(EcoFunction == "FLUX_P1" | EcoFunction == "FLUX_P2" | EcoFunction == "FLUX_C1" | EcoFunction == "FLUX_C2" | EcoFunction == "FLUX_Ptot" | EcoFunction == "FLUX_Ctot", "Nutrient Flux", "Trophic Productivity"))) %>% 
  dplyr::mutate(., Scale = if_else(EcoFunction == "N1" | EcoFunction == "P1" | EcoFunction == "C1" | EcoFunction == "FLUX_P1" | EcoFunction == "FLUX_C1" | EcoFunction == "PROD_P1" | EcoFunction == "PROD_C1", "Ecosystem 1", if_else(EcoFunction == "N2" | EcoFunction == "P2" | EcoFunction == "C2" | EcoFunction == "FLUX_P2" | EcoFunction == "FLUX_C2" | EcoFunction == "PROD_P2" | EcoFunction == "PROD_C2", "Ecosystem 2", "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), Function = factor(Function), Scale = factor(Scale), EcoFunction = factor(EcoFunction))

str(EnvFert_long)
```

Now that we have a dataset ready for plotting, we produce the graphs.

```{r envfert-rawdata-fig, echo=TRUE,tidy=TRUE}
StockSumm <- EnvFert_long %>% filter(., Function == "Stock") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, N = "N1", N = "N2", N = "Ntot", P = "P1", P = "P2", P = "Ptot", C = "C1", C = "C2", C = "Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, "N", "P", "C")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Equal", "Along", "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 10, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) +
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "Higher in Donor", "Higher in Recipient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Stock and Biomass") +
  ylab(" ") +
  xlab(" ") +
  coord_cartesian(ylim = c(0, 75)) +
  theme_pubr() +
  theme(legend.position = "right")

FluxSumm <- EnvFert_long %>% filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, P = "FLUX_P1", P = "FLUX_P2", P = "FLUX_Ptot", C = "FLUX_C1", C = "FLUX_C2", C = "FLUX_Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, "P", "C")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Equal", "Along", "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "Higher in Donor", "Higher in Recipient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Flux") +
  ylab(" ") +
  xlab(" ") +
  coord_cartesian(ylim = c(0, 350)) +
  theme_pubr() +
  theme(legend.position = "right")

ProdSumm <- EnvFert_long %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, P = "PROD_P1", P = "PROD_P2", P = "PROD_Ptot", C = "PROD_C1", C = "PROD_C2", C = "PROD_Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, "P", "C")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Equal", "Along", "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "Higher in Donor", "Higher in Recipient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Trophic Compartment Productivity") +
  ylab(" ") +
  xlab("Compartment") +
  coord_cartesian(ylim = c(0, 500)) +
  theme_pubr() +
  theme(legend.position = "right")

FuncAll <- StockSumm + FluxSumm + ProdSumm+ plot_layout(ncol = 1, nrow = 3, guides = "collect") + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")")

# FuncAll

# ggsave(FuncAll, filename = "../Results/FunctionSummary.png", device = "png", dpi = 600, width = 10, height = 8)
```

Now, we produce a log10 response ratio figure. First, we are going to create 
new dataframes (`PREDI2rr` and `PREDI1rr1`) that contain only the response 
ratio values for stock, nutrient flux, and production of all state 
variables. These dataframes will also contain information about the 
fertility conditions under which we measure each ecosystem function. We then 
merge them together in a single dataframe, `EnvFertRR`. Note that we only 
consider instances in which all state variables exists (i.e., are >0) at 
equilibrium.

**_How to interpret the graphs below_**

In the LRR graphs below, the area below 0 indicates that the denominator of the 
ratio---i.e., the value of a given ecosystem function in the _control_ 
scenario---is larger than the numerator. Hence, the effect of our manipulation of 
primary producers recycling rates effectively **reduces** the metric of interest. Vice versa, the area above
0 indicates a larger numerator and an **increase** in the value of the metric of 
interest as a consequence of our manipulation of primary producers recycling 
rates. 

```{r envfert-lrr-df, echo=TRUE,tidy=TRUE}
# need to keep raw data in the same df as the ratio to select the >0 cases 
# for state variables

PREDI2rr <- PREDI2 %>%  
  # we are going to batch-create new response ratio versions of each variable
  # we start with the "stock" group of variables
  dplyr::mutate(., N1rr = N1/PRED$N1, P1rr = P1/PRED$P1, C1rr = C1/PRED$C1, N2rr = N2/PRED$N2, P2rr = P2/PRED$P2, C2rr = C2/PRED$C2, Nrr = Ntot/PRED$Ntot, Prr = Ptot/PRED$Ptot, Crr = Ctot/PRED$Ctot) %>%
  # next, we work on the "flux" group of variables
  dplyr::mutate(., FLUX_P1rr = FLUX_P1/PRED$FLUX_P1, FLUX_C1rr = FLUX_C1/PRED$FLUX_C1, FLUX_P2rr = FLUX_P2/PRED$FLUX_P2, FLUX_C2rr = FLUX_C2/PRED$FLUX_C2, FLUX_Prr = FLUX_Ptot/PRED$FLUX_Ptot, FLUX_Crr = FLUX_Ctot/PRED$FLUX_Ctot) %>%
  # finally, we work on the "productivity" group of variables
  dplyr::mutate(., PROD_P1rr = PROD_P1/PRED$PROD_P1, PROD_C1rr = PROD_C1/PRED$PROD_C1, PROD_P2rr = PROD_P2/PRED$PROD_P2, PROD_C2rr = PROD_C2/PRED$PROD_C2, PROD_Prr = PROD_Ptot/PRED$PROD_Ptot, PROD_Crr = PROD_Ctot/PRED$PROD_Ctot) %>%
  # and now let's subset the dataframe to include only the resp ratio columns
  dplyr::select(., TIME:I2, N1:C2, N1rr:PROD_Crr)

# repeat, but for PREDI1

PREDI1rr <- PREDI1 %>%  
  # we are going to batch-create new response ratio versions of each variable
  # we start with the "stock" group of variables
  dplyr::mutate(., N1rr = N1/PRED$N1, P1rr = P1/PRED$P1, C1rr = C1/PRED$C1, N2rr = N2/PRED$N2, P2rr = P2/PRED$P2, C2rr = C2/PRED$C2, Nrr = Ntot/PRED$Ntot, Prr = Ptot/PRED$Ptot, Crr = Ctot/PRED$Ctot) %>%
  # next, we work on the "flux" group of variables
  dplyr::mutate(., FLUX_P1rr = FLUX_P1/PRED$FLUX_P1, FLUX_C1rr = FLUX_C1/PRED$FLUX_C1, FLUX_P2rr = FLUX_P2/PRED$FLUX_P2, FLUX_C2rr = FLUX_C2/PRED$FLUX_C2, FLUX_Prr = FLUX_Ptot/PRED$FLUX_Ptot, FLUX_Crr = FLUX_Ctot/PRED$FLUX_Ctot) %>%
  # finally, we work on the "productivity" group of variables
  dplyr::mutate(., PROD_P1rr = PROD_P1/PRED$PROD_P1, PROD_C1rr = PROD_C1/PRED$PROD_C1, PROD_P2rr = PROD_P2/PRED$PROD_P2, PROD_C2rr = PROD_C2/PRED$PROD_C2, PROD_Prr = PROD_Ptot/PRED$PROD_Ptot, PROD_Crr = PROD_Ctot/PRED$PROD_Ctot) %>%
  # and now let's subset the dataframe to include only the resp ratio columns
  dplyr::select(., TIME:I2, N1:C2, N1rr:PROD_Crr)

EnvFertRR <- bind_rows("Along" = PREDI2rr, "Against" = PREDI1rr, .id = "Fertility") %>% 
  dplyr::filter(., N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0) %>%
  dplyr::select(., Fertility:I2, N1rr:PROD_Crr)
# now build the graph, first by pivoting to longer format, then graphing
```

Now, we build the graphs. FIrst, pivot the `EnvFertRR` dataframe from wide to
long format.

```{r envfert-lrr-wrangling, echo=TRUE,tidy=TRUE}
EnvFertRR_long <- pivot_longer(EnvFertRR, cols = N1rr:PROD_Crr, names_to = "Compartment", values_to = "RespRatio") %>% 
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1rr" | Compartment == "FLUX_P2rr" | Compartment == "FLUX_C1rr" | Compartment == "FLUX_C2rr" | Compartment == "FLUX_Prr" | Compartment == "FLUX_Crr", "Nutrient Flux", if_else(Compartment == "PROD_P1rr" | Compartment == "PROD_C1rr" | Compartment == "PROD_P2rr" | Compartment == "PROD_C2rr" | Compartment == "PROD_Prr" | Compartment == "PROD_Crr", "Trophic Productivity", "Stock"))) %>% 
  dplyr::mutate(., Scale = if_else(Compartment == "N1rr" | Compartment == "P1rr" | Compartment == "C1rr" | Compartment == "FLUX_P1rr" | Compartment == "FLUX_C1rr" | Compartment == "PROD_P1rr" | Compartment == "PROD_C1rr", "Ecosystem 1", if_else(Compartment == "N2rr" | Compartment == "P2rr" | Compartment == "C2rr" | Compartment == "FLUX_P2rr" | Compartment == "FLUX_C2rr" | Compartment == "PROD_P2rr" | Compartment == "PROD_C2rr", "Ecosystem 2", "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), Function = factor(Function), Scale = factor(Scale), Compartment = factor(Compartment))
```

Then subset and graph each ecosystem function individually, before putting
them together with package `patchwork`. Note that we are going to graph the
`log10` transformed response ratio (LRR) against the 

```{r envfert-lrr-fig, echo=TRUE,tidy=TRUE}
EFstockLRR <- EnvFertRR_long %>% filter(., Function == "Stock") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, N = "N1rr", N = "N2rr", N = "Nrr", P = "P1rr", P = "P2rr", P = "Prr", C = "C1rr", C = "C2rr", C = "Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "N", "P", "C")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Along", "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(RespRatio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) +
  scale_color_hue(direction = -1, h.start = 90, labels = c("Higher in Donor", "Higher in Recipient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Stock and Biomass") +
  ylab(" ") +
  theme_pubr() +
  theme(legend.position = "right")

EFfluxLRR <- EnvFertRR_long %>% filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, P = "FLUX_P1rr", P = "FLUX_P2rr", P = "FLUX_Prr", C = "FLUX_C1rr", C = "FLUX_C2rr", C = "FLUX_Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Along", "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(RespRatio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) +
  scale_color_hue(direction = -1, h.start = 90, labels = c("Higher in Donor", "Higher in Recipient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Flux") +
  ylab(" ") +
  theme_pubr() +
  theme(legend.position = "right")

EFprodLRR <- EnvFertRR_long %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, P = "PROD_P1rr", P = "PROD_P2rr", P = "PROD_Prr", C = "PROD_C1rr", C = "PROD_C2rr", C = "PROD_Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Along", "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(RespRatio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) +
  scale_color_hue(direction = -1, h.start = 90, labels = c("Higher in Donor", "Higher in Recipient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Trophic Compartment Productivity") +
  ylab(" ") +
  theme_pubr() +
  theme(legend.position = "right")

EFallLRR <- EFstockLRR + EFfluxLRR + EFprodLRR + plot_layout(ncol = 1, nrow = 3, guides = "collect") + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")")

# ggsave(EFallLRR, filename = "../Results/FunctionSummary_LRR.png", device = "png", dpi = 600, width = 10, height = 8)
```

## Fertility and Recycling Rates summary

Here we are working with two different sets of dataframes as, on top of the 
differences in environmental fertility conditions, we are also considering the 
differences in primary producers recycling rates. We will indicate which 
dataframes we are working with in each section below. 

The procedure to generate the summary graphs is the same as above. Note that we
focus on the case where $\Delta h = 0.9$---that is, the recycling rate of primary 
producers in one ecosystem is 90% larger than in the other ecosystem. In the 
graphs below, we will produce three boxplots for each trophic compartment: one 
for $h_1 = h_2 = 0$ (blue), one for $h_1 > h_2$ (green), and one for $h_1 < h_2$ 
(red). 

#### Along gradient movement

Here we work with the `PREDeqrecrates`, `PREDhigh_I1h1`, and `PREDhigh_I1h2` 
dataframes. This set of simulation data captures the scenarios of high 
environmental fertility conditions in the donor ecosystem, and of higher 
recycling rates in the donor or recipient ecosystem. The code chunk below 
combines these dataframes into a new one called `AlongEF`.

```{r alongEF-df-combine,echo=TRUE,tidy=TRUE}
# Combine the dataframes for the case of h1 > h2, irrespective of ∆I, then 
# retain only certain columns, then create a new column for the fertility condition
AlongEF <- bind_rows("Equal h" = PREDeqrecrates, "High h1" = PREDhigh_I1h1, "High h2" = PREDhigh_I1h2, .id = "PPRec") %>% dplyr::mutate(., PPRec = factor(PPRec)) %>% group_by(., PPRec, hDIFF) %>% select(., PPRec:I2, N1:C2, Ntot:Ctot, FLUX_P1:FLUX_C2, FLUX_Ptot:FLUX_Ctot, PROD_P1:PROD_C2, PROD_Ptot:PROD_Ctot)
```

Now we produce the graphs for the raw data, starting by pivoting `AlongEF` to 
long format. We subset the resulting `AlongEF_long` dataframe to produce a graph 
each for stock, nutrient flux, and primary and  secondary productivity. We then 
combine them using the `patchwork` package.

```{r alongEF-raw-plot-gen, echo=TRUE,tidy=TRUE}
AlongEF_long <- dplyr::filter(AlongEF, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0) %>%
  pivot_longer(., names_to = "Compartment", values_to = "Value", cols = N1:PROD_Ctot) %>% 
  # create Scale column, capturing local vs regional (=meta-eco) spatial extent
  dplyr::mutate(., Scale = if_else(Compartment == "N1" | Compartment == "P1" | Compartment == "C1" | Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "PROD_P1" | Compartment == "PROD_C1", "Ecosystem 1", if_else(Compartment == "N2" | Compartment == "P2" | Compartment == "C2" | Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "PROD_P2" | Compartment == "PROD_C2", "Ecosystem 2", "Meta-ecosystem"))) %>%
  # create Function column, capturing different ecosystem functions measured
  # i.e., trophic compartment Stock, Nutrient Flux, Production
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_P2" | Compartment == "FLUX_C1" | Compartment == "FLUX_C2" | Compartment == "FLUX_Ptot" | Compartment == "FLUX_Ctot", "Nutrient Flux", if_else(Compartment == "PROD_P1" | Compartment == "PROD_C1" | Compartment == "PROD_P2" | Compartment == "PROD_C2" | Compartment == "PROD_Ptot" | Compartment == "PROD_Ctot", "Trophic Productivity", "Stock"))) %>% 
  # transform columns of interest to factors 
  dplyr::mutate(., PPRec = factor(PPRec), hDIFF = factor(hDIFF), Scale = factor(Scale), Compartment = factor(Compartment)) %>% 
  # subset dataframe to include only no diff, 10% diff, and 90% diff in primary
  # producers recycling rates (h_i) between local ecosystems
  dplyr::filter(., hDIFF == "0" | hDIFF == "0.9") %>%
  # remove unused levels from hDIFF column
  dplyr::mutate(., hDIFF = fct_drop(hDIFF))

AlongEFStock <- AlongEF_long %>% dplyr::filter(., Function == "Stock") %>%
  dplyr::mutate(., Compartment = fct_recode(Compartment, "N" = "N1", "N"= "N2", "N" = "Ntot", "P" = "P1", "P" = "P2", "P" = "Ptot", "C" = "C1", "C" = "C2", "C" = "Ctot")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "N", "P", "C")) %>%
  ggplot(., aes(x = Compartment, y = Value)) + 
  geom_hline(yintercept = 10, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = " ", color = "P recycling rate", 
       title = "Nutrient Stock and Biomass") + 
  scale_color_hue(direction = -1, h.start = 90, 
                  labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  coord_cartesian(ylim=c(0,100)) +
  theme_pubr() + theme(legend.position = "right")

AlongEFFlux <- AlongEF_long %>% dplyr::filter(., Function == "Nutrient Flux") %>%
  dplyr::mutate(., Compartment = fct_recode(Compartment, "P" = "FLUX_P1", "P" = "FLUX_P2", "P" = "FLUX_Ptot", "C" = "FLUX_C1", "C" = "FLUX_C2", "C" = "FLUX_Ctot")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>%
  ggplot(., aes(x = Compartment, y = Value)) + 
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = " ", color = "P recycling rate", title = "Nutrient Flux") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  coord_cartesian(ylim=c(0,350)) +
  theme_pubr() + theme(legend.position = "right")

AlongEFProd <- AlongEF_long %>% dplyr::filter(., Function == "Trophic Productivity") %>%
  dplyr::mutate(., Compartment = fct_recode(Compartment, "P" = "PROD_P1", "P" = "PROD_P2", "P" = "PROD_Ptot", "C" = "PROD_C1", "C" = "PROD_C2", "C" = "PROD_Ctot")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>%
  ggplot(., aes(x = Compartment, y = Value)) + 
  geom_hline(yintercept = 100, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = "Compartment", color = "P recycling rate", title = "Trophic Compartmet Productivity") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  coord_cartesian(ylim=c(0,500)) +
  theme_pubr() + theme(legend.position = "right")

AlongEFall <- AlongEFStock + AlongEFFlux + AlongEFProd + plot_layout(ncol = 1, nrow = 3, guides = "collect") + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")", title = "Consumer move along-gradient from high to low environmental fertility")

# ggsave(AlongEFall, filename = "../Results/FunctSumm_AlongEFraw.png", device = "png", dpi = 300, width = 12, height = 8)
```

Below, we produce a log response ratio version of the same plot. We begin by 
calculating the log response ratio. This is accomplished by dividing every data 
column in the dataframe by the corresponding one in our _baseline_ condition 
dataframe, i.e. `PRED`.

```{r alongEF-LRR-calc,echo=TRUE,tidy=TRUE}
# now, group the resulting dataframe, then calculate the experiment:control ratio for each trophic compartment
AlongEFlrr <- AlongEF %>% 
  # we are going to batch-create new response ratio versions of each variable
  # we start with the "stock" group of variables
  dplyr::mutate(., N1rr = N1/PRED$N1, P1rr = P1/PRED$P1, C1rr = C1/PRED$C1, N2rr = N2/PRED$N2, P2rr = P2/PRED$P2, C2rr = C2/PRED$C2, Nrr = Ntot/PRED$Ntot, Prr = Ptot/PRED$Ptot, Crr = Ctot/PRED$Ctot) %>%
  # next, we work on the "flux" group of variables
  dplyr::mutate(., FLUX_P1rr = FLUX_P1/PRED$FLUX_P1, FLUX_C1rr = FLUX_C1/PRED$FLUX_C1, FLUX_P2rr = FLUX_P2/PRED$FLUX_P2, FLUX_C2rr = FLUX_C2/PRED$FLUX_C2, FLUX_Prr = FLUX_Ptot/PRED$FLUX_Ptot, FLUX_Crr = FLUX_Ctot/PRED$FLUX_Ctot) %>%
  # finally, we work on the "productivity" group of variables
  dplyr::mutate(., PROD_P1rr = PROD_P1/PRED$PROD_P1, PROD_C1rr = PROD_C1/PRED$PROD_C1, PROD_P2rr = PROD_P2/PRED$PROD_P2, PROD_C2rr = PROD_C2/PRED$PROD_C2, PROD_Prr = PROD_Ptot/PRED$PROD_Ptot, PROD_Crr = PROD_Ctot/PRED$PROD_Ctot) %>% filter(., N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0)
```

Now that we have the log response ratio for each ecosystem function, we subset 
the dataframe to include only those and create a new dataframe, 
`AlongEFlrr_long`, with which we will be working. The workflow is the same as 
above.

```{r alongEF-LRRplot-gen,echo=TRUE,tidy=TRUE,fig.cap="."}
# now select only the metadata and ratios columns and pivot to a long dataframe,
# then create a Scale column
AlongEFlrr_long <- select(AlongEFlrr, PPRec:I2, N1rr:PROD_Crr) %>% 
  # pivot to longer format after selecting only columns of interest
  pivot_longer(., names_to = "Compartment", values_to = "Ratio", cols = N1rr:PROD_Crr) %>% 
  # create Scale column, capturing local vs regional (=meta-eco) spatial extent
  dplyr::mutate(., Scale = if_else(Compartment == "N1rr" | Compartment == "P1rr" | Compartment == "C1rr" | Compartment == "FLUX_P1rr" | Compartment == "FLUX_C1rr" | Compartment == "PROD_P1rr" | Compartment == "PROD_C1rr", "Ecosystem 1", if_else(Compartment == "N2rr" | Compartment == "P2rr" | Compartment == "C2rr" | Compartment == "FLUX_P2rr" | Compartment == "FLUX_C2rr" | Compartment == "PROD_P2rr" | Compartment == "PROD_C2rr", "Ecosystem 2", "Meta-ecosystem"))) %>%
  # create Function column, capturing different ecosystem functions measured
  # i.e., trophic compartment Stock, Nutrient Flux, Production
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1rr" | Compartment == "FLUX_P2rr" | Compartment == "FLUX_C1rr" | Compartment == "FLUX_C2rr" | Compartment == "FLUX_Prr" | Compartment == "FLUX_Crr", "Nutrient Flux", if_else(Compartment == "PROD_P1rr" | Compartment == "PROD_C1rr" | Compartment == "PROD_P2rr" | Compartment == "PROD_C2rr" | Compartment == "PROD_Prr" | Compartment == "PROD_Crr", "Trophic Productivity", "Stock"))) %>% 
  # transform columns of interest to factors 
  dplyr::mutate(., PPRec = factor(PPRec), hDIFF = factor(hDIFF), Scale = factor(Scale), Compartment = factor(Compartment)) %>% 
  # subset dataframe to include only no diff, 10% diff, and 90% diff in primary
  # producers recycling rates (h_i) between local ecosystems
  dplyr::filter(., hDIFF == "0" | hDIFF == "0.9") %>%
  # remove unused levels from hDIFF column
  dplyr::mutate(., hDIFF = fct_drop(hDIFF))

# trophic compartment stock graph
AlongEFlrrStock <- AlongEFlrr_long %>% 
  dplyr::filter(., Function == "Stock") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "N" = "N1rr", "N" = "N2rr", "N" = "Nrr", "P" = "P1rr", "P" = "P2rr", "P" = "Prr", "C" = "C1rr", "C" = "C2rr", "C" = "Crr")) %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "N", "P", "C")) %>% 
  ggplot(., aes(x = Compartment, y = log10(Ratio))) + 
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = " ", color = "P recycling rate", title = "Nutrient Stock and Biomass") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  # coord_cartesian(ylim=c(-1,1)) +
  theme_pubr() + theme(legend.position = "right")

# trophic compartment nutrient flux graph
AlongEFlrrFlux <- AlongEFlrr_long %>% 
  dplyr::filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "P" = "FLUX_P1rr", "P" = "FLUX_P2rr", "P" = "FLUX_Prr", "C" = "FLUX_C1rr", "C" = "FLUX_C2rr", "C" = "FLUX_Crr")) %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>% 
  ggplot(., aes(x = Compartment, y = log10(Ratio))) + 
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = " ", color = "P recycling rate", title = "Nutrient Flux") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  # coord_cartesian(ylim=c(-1,1)) +
  theme_pubr() + theme(legend.position = "right")

# trophic compartment production graph
AlongEFlrrProd <- AlongEFlrr_long %>% 
  dplyr::filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "P" = "PROD_P1rr", "P" = "PROD_P2rr", "P" = "PROD_Prr", "C" = "PROD_C1rr", "C" = "PROD_C2rr", "C" = "PROD_Crr")) %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>% 
  ggplot(., aes(x = Compartment, y = log10(Ratio))) + 
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", color = "P recycling rate", title = "Trophic Compartment Productivity") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  # coord_cartesian(ylim=c(-1,1)) +
  theme_pubr() + theme(legend.position = "right")

AlongEFlrr_AllFunct <- AlongEFlrrStock + AlongEFlrrFlux + AlongEFlrrProd + plot_layout(ncol = 1, nrow = 3, guides = "collect") + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")", title = "Consumer move along-gradient from high to low environmental fertility")

# ggsave(AlongEFlrr_AllFunct, filename = "../Results/FunctSumm_AlongEFlrr.png", dpi = 300, device = "png", width = 12, height = 8)
```

#### Against gradient movement

Following the same workflow, we now produce raw data and log response ratio 
graphs for the case of against-gradient movement. We begin by combining the
relevant dataframes into a single object, `AgainstEF`.

```{r againstEF-df-combine,echo=TRUE,tidy=TRUE}
# Combine the dataframes for the case of h1 > h2, irrespective of ∆I, then 
# retain only certain columns, then create a new column for the fertility condition
AgainstEF <- bind_rows("Equal h" = PREDeqrecrates, "High h1" = PREDhigh_I2h1, "High h2" = PREDhigh_I2h2, .id = "PPRec") %>% dplyr::mutate(., PPRec = factor(PPRec)) %>% group_by(., PPRec, hDIFF) %>% select(., PPRec:I2, N1:C2, Ntot:Ctot, FLUX_P1:FLUX_C2, FLUX_Ptot:FLUX_Ctot, PROD_P1:PROD_C2, PROD_Ptot:PROD_Ctot)
```

The code chunk below lengthens `AgainstEF` into `AgainstEF_long` and then uses
this new dataframe to produce the graphs. For each ecosystem function of 
interest, we subset `AgainstEF_long` and build the graph from the resulting 
selection of values.

```{r againstEF-raw-plot-gen, echo=TRUE,tidy=TRUE}
AgainstEF_long <- dplyr::filter(AgainstEF, N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0) %>% 
  pivot_longer(., names_to = "Compartment", values_to = "Value", cols = N1:PROD_Ctot) %>% 
  # create Scale column, capturing local vs regional (=meta-eco) spatial extent
  dplyr::mutate(., Scale = if_else(Compartment == "N1" | Compartment == "P1" | Compartment == "C1" | Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "PROD_P1" | Compartment == "PROD_C1", "Ecosystem 1", if_else(Compartment == "N2" | Compartment == "P2" | Compartment == "C2" | Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "PROD_P2" | Compartment == "PROD_C2", "Ecosystem 2", "Meta-ecosystem"))) %>%
  # create Function column, capturing different ecosystem functions measured
  # i.e., trophic compartment Stock, Nutrient Flux, Production
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_P2" | Compartment == "FLUX_C1" | Compartment == "FLUX_C2" | Compartment == "FLUX_Ptot" | Compartment == "FLUX_Ctot", "Nutrient Flux", if_else(Compartment == "PROD_P1" | Compartment == "PROD_C1" | Compartment == "PROD_P2" | Compartment == "PROD_C2" | Compartment == "PROD_Ptot" | Compartment == "PROD_Ctot", "Trophic Productivity", "Stock"))) %>% 
  # transform columns of interest to factors 
  dplyr::mutate(., PPRec = factor(PPRec), hDIFF = factor(hDIFF), Scale = factor(Scale), Compartment = factor(Compartment)) %>% 
  # subset dataframe to include only no diff, 10% diff, and 90% diff in primary
  # producers recycling rates (h_i) between local ecosystems
  dplyr::filter(., hDIFF == "0" | hDIFF == "0.9") %>%
  # remove unused levels from hDIFF column
  dplyr::mutate(., hDIFF = fct_drop(hDIFF))

AgainstEFStock <- AgainstEF_long %>% 
  dplyr::filter(., Function == "Stock") %>%
  dplyr::mutate(., Compartment = fct_recode(Compartment, "N" = "N1", "N"= "N2", "N" = "Ntot", "P" = "P1", "P" = "P2", "P" = "Ptot", "C" = "C1", "C" = "C2", "C" = "Ctot")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "N", "P", "C")) %>%
  ggplot(., aes(x = Compartment, y = Value)) + 
  geom_hline(yintercept = 10, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = " ", color = "P recycling rate", 
       title = "Nutrient Stock and Biomass") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  coord_cartesian(ylim=c(0,100)) +
  theme_pubr() + theme(legend.position = "right")

AgainstEFFlux <- AgainstEF_long %>% 
  dplyr::filter(., Function == "Nutrient Flux") %>%
  dplyr::mutate(., Compartment = fct_recode(Compartment, "P" = "FLUX_P1", "P" = "FLUX_P2", "P" = "FLUX_Ptot", "C" = "FLUX_C1", "C" = "FLUX_C2", "C" = "FLUX_Ctot")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>%
  ggplot(., aes(x = Compartment, y = Value)) + 
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = " ", color = "P recycling rate", 
       title = "Nutrient Flux") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  coord_cartesian(ylim=c(0,500)) +
  theme_pubr() + theme(legend.position = "right")

AgainstEFProd <- AgainstEF_long %>% 
  dplyr::filter(., Function == "Trophic Productivity") %>%
  dplyr::mutate(., Compartment = fct_recode(Compartment, "P" = "PROD_P1", "P" = "PROD_P2", "P" = "PROD_Ptot", "C" = "PROD_C1", "C" = "PROD_C2", "C" = "PROD_Ctot")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>%
  ggplot(., aes(x = Compartment, y = Value)) + 
  geom_hline(yintercept = 100, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = "Compartment", color = "P recycling rate", 
       title = "Trophic Compartment Productivity") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  coord_cartesian(ylim=c(0,700)) +
  theme_pubr() + theme(legend.position = "right")

AgainstEFall <- AgainstEFStock + AgainstEFFlux + AgainstEFProd + plot_layout(ncol = 1, nrow = 3, guides = "collect") + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")", title = "Consumer move against-gradient from low to high environmental fertility")

# ggsave(AgainstEFall, filename = "../Results/FunctSumm_AgainstEFraw.png", device = "png", dpi = 300, width = 12, height = 8)
```

Now, we move on to producing the log response ratio version of the graphs we
just produced above. We first calculate the log response ratio for each
ecosystem function by dividing the relevant data columns in `AgainstEFlrr` by the 
corresponding ones in the _baseline_ condition dataframe, i.e., `PRED`. 

```{r againstEF-LRR-calc,echo=TRUE,tidy=TRUE}
# now, group the resulting dataframe, then calculate the experiment:control ratio for each trophic compartment
AgainstEFlrr <- AgainstEF %>% 
  # we are going to batch-create new response ratio versions of each variable
  # we start with the "stock" group of variables
  dplyr::mutate(., N1rr = N1/PRED$N1, P1rr = P1/PRED$P1, C1rr = C1/PRED$C1, N2rr = N2/PRED$N2, P2rr = P2/PRED$P2, C2rr = C2/PRED$C2, Nrr = Ntot/PRED$Ntot, Prr = Ptot/PRED$Ptot, Crr = Ctot/PRED$Ctot) %>%
  # next, we work on the "flux" group of variables
  dplyr::mutate(., FLUX_P1rr = FLUX_P1/PRED$FLUX_P1, FLUX_C1rr = FLUX_C1/PRED$FLUX_C1, FLUX_P2rr = FLUX_P2/PRED$FLUX_P2, FLUX_C2rr = FLUX_C2/PRED$FLUX_C2, FLUX_Prr = FLUX_Ptot/PRED$FLUX_Ptot, FLUX_Crr = FLUX_Ctot/PRED$FLUX_Ctot) %>%
  # finally, we work on the "productivity" group of variables
  dplyr::mutate(., PROD_P1rr = PROD_P1/PRED$PROD_P1, PROD_C1rr = PROD_C1/PRED$PROD_C1, PROD_P2rr = PROD_P2/PRED$PROD_P2, PROD_C2rr = PROD_C2/PRED$PROD_C2, PROD_Prr = PROD_Ptot/PRED$PROD_Ptot, PROD_Crr = PROD_Ctot/PRED$PROD_Ctot) %>% filter(., N1>0 & P1>0 & C1>0 & N2>0 & P2>0 & C2>0)
```

With the log response ratio values in the dataframe, we now proceed to separate
them from the raw data into a new dataframe, `AgainstEFlrr_long`, and pivoting it 
to long format. We then use this new object to produce the graphs.

```{r againstEF-LRRplot-gen,echo=TRUE,tidy=TRUE,fig.cap="."}
# now select only the metadata and ratios columns and pivot to a long dataframe,
# then create a Scale column
AgainstEFlrr_long <- select(AgainstEFlrr, PPRec:I2, N1rr:PROD_Crr) %>% 
  # pivot to longer format after selecting only columns of interest
  pivot_longer(., names_to = "Compartment", values_to = "Ratio", cols = N1rr:PROD_Crr) %>% 
  # create Scale column, capturing local vs regional (=meta-eco) spatial extent
  dplyr::mutate(., Scale = if_else(Compartment == "N1rr" | Compartment == "P1rr" | Compartment == "C1rr" | Compartment == "FLUX_P1rr" | Compartment == "FLUX_C1rr" | Compartment == "PROD_P1rr" | Compartment == "PROD_C1rr", "Ecosystem 1", if_else(Compartment == "N2rr" | Compartment == "P2rr" | Compartment == "C2rr" | Compartment == "FLUX_P2rr" | Compartment == "FLUX_C2rr" | Compartment == "PROD_P2rr" | Compartment == "PROD_C2rr", "Ecosystem 2", "Meta-ecosystem"))) %>%
  # create Function column, capturing different ecosystem functions measured
  # i.e., trophic compartment Stock, Nutrient Flux, Production
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1rr" | Compartment == "FLUX_P2rr" | Compartment == "FLUX_C1rr" | Compartment == "FLUX_C2rr" | Compartment == "FLUX_Prr" | Compartment == "FLUX_Crr", "Nutrient Flux", if_else(Compartment == "PROD_P1rr" | Compartment == "PROD_C1rr" | Compartment == "PROD_P2rr" | Compartment == "PROD_C2rr" | Compartment == "PROD_Prr" | Compartment == "PROD_Crr", "Trophic Productivity", "Stock"))) %>% 
  # transform columns of interest to factors 
  dplyr::mutate(., PPRec = factor(PPRec), hDIFF = factor(hDIFF), Scale = factor(Scale), Compartment = factor(Compartment)) %>% 
  # subset dataframe to include only no diff, 10% diff, and 90% diff in primary
  # producers recycling rates (h_i) between local ecosystems
  dplyr::filter(., hDIFF == "0" | hDIFF == "0.9") %>%
  # remove unused levels from hDIFF column
  dplyr::mutate(., hDIFF = fct_drop(hDIFF))

# trophic compartment stock graph
AgainstEFlrrStock <- AgainstEFlrr_long %>% 
  dplyr::filter(., Function == "Stock") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "N" = "N1rr", "N" = "N2rr", "N" = "Nrr", "P" = "P1rr", "P" = "P2rr", "P" = "Prr", "C" = "C1rr", "C" = "C2rr", "C" = "Crr")) %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "N", "P", "C")) %>% 
  ggplot(., aes(x = Compartment, y = log10(Ratio))) + 
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = " ", color = "P recycling rate", 
       title = "Nutrient Stock and Biomass") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  # coord_cartesian(ylim=c(-1,1)) +
  theme_pubr() + theme(legend.position = "right")

# trophic compartment nutrient flux graph
AgainstEFlrrFlux <- AgainstEFlrr_long %>% 
  dplyr::filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "P" = "FLUX_P1rr", "P" = "FLUX_P2rr", "P" = "FLUX_Prr", "C" = "FLUX_C1rr", "C" = "FLUX_C2rr", "C" = "FLUX_Crr")) %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>% 
  ggplot(., aes(x = Compartment, y = log10(Ratio))) + 
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", x = " ", color = "P recycling rate", 
       title = "Nutrient Flux") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  # coord_cartesian(ylim=c(-1,1)) +
  theme_pubr() + theme(legend.position = "right")

# trophic compartment production graph
AgainstEFlrrProd <- AgainstEFlrr_long %>% 
  dplyr::filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "P" = "PROD_P1rr", "P" = "PROD_P2rr", "P" = "PROD_Prr", "C" = "PROD_C1rr", "C" = "PROD_C2rr", "C" = "PROD_Crr")) %>% 
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "P", "C")) %>% 
  ggplot(., aes(x = Compartment, y = log10(Ratio))) + 
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(col = PPRec)) + 
  facet_grid(.~Scale, scales = "free") + 
  labs(y = " ", color = "P recycling rate", 
       title = "Trophic Compartment Productivity") + 
  scale_color_hue(direction = -1, h.start = 90, labels = c("Equal", "90% higher in Donor", "90% higher in Recipient")) +
  # coord_cartesian(ylim=c(-1,1)) +
  theme_pubr() + theme(legend.position = "right")

AgainstEFlrr_AllFunct <- AgainstEFlrrStock + AgainstEFlrrFlux + AgainstEFlrrProd + plot_layout(ncol = 1, nrow = 3, guides = "collect") + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")", title = "Consumer move against-gradient from low to high environmental fertility")

# ggsave(AgainstEFlrr_AllFunct, filename = "../Results/FunctSumm_AgainstEFlrr.png", dpi = 300, device = "png", width = 12, height = 8)
```

## Summary tables

Here, we produce summary tables for the simulations above using the $LRR$ values 
we calculated to produce the summary plots above. In these tables, we report 
median $LRR$ values for each ecosystem function of interest in both local 
ecosystems and in the meta-ecosystem. These tables further summarize information
presented in the graphs above, by reducing the whole variation to a single 
value. As above, we focus only on the case of $\Delta h = 0.9$. 

For ease of interpretation, median LRR values $< 0$ will be shown in shades of 
red based on how close they are to $-1$ and median LRR $> 0$ will be shown in 
shades of green based on their closeness to $1$.

First, we produce dataframes to contain the median values, one for each of 
stock, nutrient flux, and primary and secondary productivity.

```{r summ-tables-df-gen, echo=TRUE,tidy=TRUE}
# first, compute median of log10 ratio values

AlongEFlrr_tables <- dplyr::filter(AlongEFlrr_long, Ratio>=0) %>% dplyr::group_by(., PPRec, Function, Scale, Compartment) %>% dplyr::mutate(., LRR = log10(Ratio)) %>% dplyr::summarise(., median = median(LRR), .groups = "keep")

AgainstEFlrr_tables <- dplyr::filter(AgainstEFlrr_long, Ratio>=0) %>% dplyr::group_by(., PPRec, Function, Scale, Compartment) %>% dplyr::mutate(., LRR = log10(Ratio)) %>% dplyr::summarise(., median = median(LRR), .groups = "keep")
```

Now, we produce the tables, separating between along and against-gradient 
movement, as above.

#### Along-gradient movement tables

```{r alongEF-tables-gen, echo=TRUE, tidy=TRUE}
AlongEFStockTab <- AlongEFlrr_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Stock") %>% 
  pivot_wider(., names_from = PPRec, values_from = median) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "C1rr", "Consumers" = "C2rr", "Consumers" = "Crr", "Producers" = "P1rr", "Producers" = "P2rr", "Producers" = "Prr", "Nutrients" = "N1rr", "Nutrients" = "N2rr", "Nutrients" = "Nrr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Nutrients", "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  fmt_number(., columns = c(4:6), decimals = 3) %>% 
  data_color(., columns = 4:6, colors = col_numeric(palette = "PiYG", domain = c(-1,1)))

AlongEFStockTab

AlongEFFluxTab <- AlongEFlrr_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Nutrient Flux") %>% 
  pivot_wider(., names_from = PPRec, values_from = median) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "FLUX_C1rr", "Consumers" = "FLUX_C2rr", "Consumers" = "FLUX_Crr", "Producers" = "FLUX_P1rr", "Producers" = "FLUX_P2rr", "Producers" = "FLUX_Prr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  fmt_number(., columns = c(4:6), decimals = 3) %>% 
  data_color(., columns = 4:6, colors = col_numeric(palette = "PiYG", domain = c(-1,1)))

AlongEFFluxTab

AlongEFProdTab <- AlongEFlrr_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Trophic Productivity") %>% 
  pivot_wider(., names_from = PPRec, values_from = median) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "PROD_C1rr", "Consumers" = "PROD_C2rr", "Consumers" = "PROD_Crr", "Producers" = "PROD_P1rr", "Producers" = "PROD_P2rr", "Producers" = "PROD_Prr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  fmt_number(., columns = c(4:6), decimals = 3) %>% 
  data_color(., columns = 4:6, colors = col_numeric(palette = "PiYG", domain = c(-1,1)))

AlongEFProdTab
```

#### Against-gradient movement tables

```{r againstEF-tables-gen, echo=TRUE, tidy=TRUE}
AgainstEFStockTab <- AgainstEFlrr_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Stock") %>% 
  pivot_wider(., names_from = PPRec, values_from = median) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "C1rr", "Consumers" = "C2rr", "Consumers" = "Crr", "Producers" = "P1rr", "Producers" = "P2rr", "Producers" = "Prr", "Nutrients" = "N1rr", "Nutrients" = "N2rr", "Nutrients" = "Nrr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Nutrients", "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  fmt_number(., columns = c(4:6), decimals = 3) %>% 
  data_color(., columns = 4:6, colors = col_numeric(palette = "PiYG", domain = c(-1,1)))

AgainstEFStockTab

AgainstEFFluxTab <- AgainstEFlrr_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Nutrient Flux") %>% 
  pivot_wider(., names_from = PPRec, values_from = median) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "FLUX_C1rr", "Consumers" = "FLUX_C2rr", "Consumers" = "FLUX_Crr", "Producers" = "FLUX_P1rr", "Producers" = "FLUX_P2rr", "Producers" = "FLUX_Prr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  fmt_number(., columns = c(4:6), decimals = 3) %>% 
  data_color(., columns = 4:6, colors = col_numeric(palette = "PiYG", domain = c(-1,1)))

AgainstEFFluxTab

AgainstEFProdTab <- AgainstEFlrr_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Trophic Productivity") %>% 
  pivot_wider(., names_from = PPRec, values_from = median) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "PROD_C1rr", "Consumers" = "PROD_C2rr", "Consumers" = "PROD_Crr", "Producers" = "PROD_P1rr", "Producers" = "PROD_P2rr", "Producers" = "PROD_Prr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  fmt_number(., columns = c(4:6), decimals = 3) %>% 
  data_color(., columns = 4:6, colors = col_numeric(palette = "PiYG", domain = c(-1,1)))

AgainstEFProdTab
```