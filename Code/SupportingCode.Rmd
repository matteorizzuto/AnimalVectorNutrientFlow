---
title: "Supporting Code"
description: |
  for "Animal-vectored nutrient flows over resource gradients influence the nature of local and meta-ecosystem functioning"
author:
  - name: Matteo Rizzuto
    url: https://matteorizzuto.github.io
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/
    orcid_id: 0000-0003-3065-9140
  - name: Shawn J. Leroux
    url: https://shawnleroux.wixsite.com/lerouxlab
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/
    orcid_id: 0000-0001-9580-0294
  - name: Oswald J. Schmitz
    url: http://schmitz.environment.yale.edu
    affiliation: School of the Environment, Yale University
    affiliation_url: https://environment.yale.edu
    orcid_id: 0000-0003-1515-2667
  - name: Eric Vander Wal
    url: http://weel.gitlab.io
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/
    orcid_id: 0000-0002-8534-4317
  - name: Yolanda F. Wiersma
    url: https://nllandscapeecology.com
    affiliation: Department of Biology, Memorial University of Newfoundland
    affiliation_url: https://mun.ca/biology/
    orcid_id: 0000-0003-4604-9240
  - name: Travis R. Heckford
    url: https://www.researchgate.net/profile/Travis-Heckford
    affiliation: Cariboo Natural Resource Region, British Columbia Ministry of Forests
    affiliation_url: https://www.gov.bc.ca/gov/content/home
    orcid_id: 0000-0002-3993-6450
date: "`r Sys.Date()`"
bibliography: SupportingCode.bib
creative_commons: CC BY-SA
repository_url: https://github.com/matteorizzuto/AnimalVectorNutrientFlow
output:
  distill::distill_article:
    toc: TRUE
    toc_depth: 2
    toc_float: TRUE
    code_folding: TRUE
    smart: TRUE
    fig_caption: TRUE
    highlight_downlit: TRUE
    self_contained: TRUE
---

```{r start-timer, include=FALSE}
tictoc::tic()
```

# Introduction

This notebook contains the code used to run numerical analyses of a 
meta-ecosystem model in which consumers move across ecosystem borders in 
different ways with respect to resource gradients. 

In section [Model Numerical Analyses], we perform numerical analyses of our 
model of consumer movement in a two-patch meta-ecosystem, using the set of 
equilibrium equations derived in Mathematica (see Mathematica notebook in this 
same repository; @Mathematica). In section [Changes to biomass distribution in 
local and meta-ecosystem], we investigate how biomass distribution changes 
following different types of consumer movement and how this may affect top-down 
influences of consumer movement on local and meta-ecosystem functions. Finally, 
in section [Sensitivity Analyses], we perform a suite of sensitivity analyses on 
our results. 

In this introduction, we briefly define the contrasting consumer movement 
types we investigate with this model ([Defining movement types]), discuss 
separation of scales in time and space ([Separation of spatial scales]), 
describe the state variables and parameters in the model 
([State variables and parameters of the model]), and describe the analyses 
setup ([Analyses setup]).

#### Defining movement types

Here, we focus on consumers moving over gradients of inorganic nutrients 
availability between two local ecosystems. Consumer movement---either _gradient 
neutral_, _along_-, or _against-gradient_---connects these two local ecosystems 
in a meta-ecosystem [@Loreau2003]. We define consumer movement as _gradient 
neutral_ when it happens among ecosystems that have equal nutrient availability. 
_Along-gradient_ movement takes place when consumers move following the gradient 
direction, from high to low nutrient availability. Conversely, 
_against-gradient_ consumer movement runs counter to the 
direction of the gradient, from low to high nutrient availability. In our model, 
we create resource gradients by varying the relative values of the inorganic 
nutrient input rates in the two ecosystems comprising our meta-ecosystem 
(parameter _I~i~_; see ***Manuscript** for details and the table below for a 
list of model parameters and state variables).

#### Separation of spatial and temporal scales

While organisms can at times cross into an ecosystem that is 
equally suitable for them immediately after leaving their original one, this is 
not often the case. Rather, organisms spend significant amounts of time searching
for a new suitable ecosystem, traversing the so-called "unsuitable" matrix 
[@Weisser1996]. Models of organismal movement in meta-ecosystems should account 
for this time spent outside ecosystem borders, as it may lead to loss of biomass
and nutrients from the system [@Gounand2018]. 

We model consumer movement in our meta-ecosystem model using a dispersers' 
pool [@Weisser1996]. Briefly, adding a dispersers' pool to a classic 
meta-ecosystem model means that consumer do not instantly travel from donor to 
recipient ecosystem. Instead, they move from the donor to the dispersers' pool 
and then from there to the recipient (see **Figure 1c** in the main text for a 
visual representation). This allows us to separate ecosystem processes that 
happen locally from those that happen regionally. See section **Model 
Derivation** in the main text for further details on our novel approach to 
model consumer movement in meta-ecosystems.

#### State variables and parameters of the model

The table below lists the model's state variables and parameters, and is analogous 
to **Table 1** in the main text. For a visual representation of the model, 
please see **Figure 1c** in the main text.

Variable       Description                                   Units     Range
-------------  --------------------------------------------- --------- -----
N~i~           Nutrients stocks in patch _i_                 g         >0
P~i~           Producers stocks in patch _i_                 g         >0
C~i~           Consumers stocks in patch _i_                 g         >0
Q              Dispersers' Pool                              g         >0  
-------------  --------------------------------------------- --------- -----
Parameter      Description                                   Units     Range
-------------  --------------------------------------------- --------- -----
I~i~           Inorganic nutrient input rate into patch _i_  g*t^-1^   [0,20]
$\ell$         Inorganic nutrient output rate                t^-1^	   constant
u~i~           Producer uptake rate in patch _i_             (g*t)^-1^ [0,10]  
a~i~           Consumer attack rate in patch _i_             (g*t)^-1^ [0,10]
$\varepsilon$~i~  Consumer assimilation efficiency in patch _i_ unitless  [0,1]
h~i~           Biomass loss rate from P~i~                   t^-1^     [0,10]
d~i~           Biomass loss rate from C~i~                   t^-1^     [0,10]
g              Movement rate from C~1~ to Q                  t^-1^     [0,10]
m              Movement rate from Q to C~2~                  t^-1^     [0,10]
c              Biomass loss rate from Q                      t^-1^     [0,10]
-------------  --------------------------------------------- --------- -----

We derived the model's single feasible equilibrium in 
Mathematica (@Mathematica; see **Model Derivation** in the main text for further 
details). 

#### Analyses setup

This notebook uses the following packages:

```{r setup, echo=TRUE, tidy=TRUE}
# The following packages are used throughout this document.
# Before loading each packages, we provide aa brief description of what it is 
# used for 

# project dependency (packages, mostly) management
library(renv) 
# data wrangling, manipulation, plotting
library(tidyverse) 
# additional plotting functions
library(plotrix) 
# use latin hypercube to create toy datasets
library(lhs) 
# building tables in a tidyverse framework
library(gt) 
# scaling functions for ggplot2
library(scales) 
# color-blind palettes for ggplot2
library(khroma) 
# extra tabbing functionality for rmarkdown documents
library(xaringanExtra) 
# functions to time compilation of this document
library(tictoc) 
# color palettes manipulation
library(RColorBrewer) 
# additional color palettes inspired by MET artworks
library(MetBrewer) 
# additional data wrangling
library(broom) 
# print local directory structure
library(fs)
# additional ggplot2 themes
library(cowplot)
# use randomForest algorithms to perform sensitivity analyses on results
library(randomForest)
# extra themes for ggplot2
library(ggpubr) 
# extra geoms for ggplot2
library(ggpol) 
# easily create and layout multi-panel plots
library(patchwork)
# additional ggplot2 functionality
library(ggh4x)
# extra themes for ggplot2
library(ggpubr) 
# extra geoms for ggplot2
library(ggpol) 
# easily create and layout multi-panel plots
library(patchwork)
# save ggplot2 objects as svg
library(svglite)

# Packages that need to be installed but do not require loading

# library(distill) # notebook templates
# library(rmarkdown) # build interactive documents in R 

# set the theme for all ggplot2 objects
theme_set(theme_classic())
```

In the interest of reproducibility, we use package `renv` to keep track of this 
notebook's packages.

```{r renv-set-up, echo=TRUE, message=FALSE, tidy=TRUE}
renv::snapshot()
```

We compiled this notebook on a machine using the following version of 
R, operative system, and necessary packages:

```{r session-information, echo=FALSE}
# this needs three colons to work between package name and function call
utils:::print.sessionInfo(sessionInfo()[-8])
```

Finally, this notebook assumes the following folder structure:

```{r dir-tree, echo=TRUE, tidy=TRUE}
dir_tree(path = "../", recurse = 0 , all = FALSE, type = "directory")
```

This structure allows us to take advantage of relative paths when loading data 
or saving figures. Note that `../` stands for the root folder. If you wish to 
recompile this notebook, please organize your folder structure 
accordingly.

# Model numerical analyses

Here, we perform the analyses of the meta-ecosystem model described in section 
**Numerical Analyses** of the main text. If you are interested in the code used 
to produce the main text's figures and tables, this can be found in 
sections [Visual Deliverables---Ecosystem functions] and 
[Summary Tables---Ecosystem functions] below. 

We conduct three rounds of analyses, one each for the three types of consumer 
movement we are interested in: _gradient-neutral_, _along-_, and _against-gradient_. 
Each round of analysis comprises iterating the model over n = 10 000 parameter 
sets, running stability analyses, and graphing the results. The
analyses will follow these steps:

1. Fit randomly-drawn parameter sets to the model's equilibrium and solve for state variable values
2. Calculate meta-ecosystem function values
3. Flag parameter sets that produce equilibria < 0, hence without biological meaning
4. Run stability analyses on each parameter set to identify those producing unstable results
5. Exclude parameter sets that are unstable and/or have no biological meaning from further analyses
6. Explore results graphically

## Generating parameter sets

This notebooks defaults to loading the two pre-generated datasets provided 
alongside it, in folder `../Data`. `DATA1` includes parameters scaled [0--10], 
whereas `DATA2` includes parameters scaled [0--1]. These were generated with a 
Latin hypercube sampling design, using function `lhs()`, and then used to 
produce the results and figures presented in the paper [@lhs]. To generate new randomly
drawn parameter values, set `eval=FALSE` in the `data-load` code chunk below 
and `eval=TRUE` in the following one, labelled `disp-poolsetParams`.

```{r data-load, echo=TRUE, tidy=TRUE}
DATA1 <- read.csv(file = "../Data/DATA1.csv", header = TRUE)

DATA2 <- read.csv(file = "../Data/DATA2.csv", header = TRUE)
```

In the code chunk below, we show how to generate two sets of randomly-drawn 
parameter values to use in all scenarios. We use function `lhs()` to do so. One 
set includes parameters values scaled 0--10 (`DATA1`), while the other one 
includes parameter values scaled 0--1 (`DATA2`).

```{r disp-pool-setParams, eval=FALSE, echo=TRUE, tidy=TRUE}
# Below we generate random values for those parameters that will vary
# during the simulations: attack rates, efficiency, death rates, and movement 
# rates

DATA1 <- NULL
# Run 2000 iterations of 100 numbers (in 100 bins between 0 to 1)
for(i in seq(1,100,1)){
  
  # Use lhs function in R. 100 bins, 11 iterations - one for each parameter that
  # is scaled between 0 and 10.
  loop_1 <- randomLHS(100, 11)
  
  # Use rbind to stack each iteration on top of the other to create a one column
  # list of 10000 samples with equal distribution in 100 bins.
  # Multiplied by 10 to get range of data from 0 to 10
  DATA1 <- rbind(DATA1, data.frame(i=i, Result=loop_1*10))
  
  # print the i value so you can track progress
  # print(i)
  # Close the loop
}

# This is for 2 parameters that is scaled 0 to 1.
DATA2 <- NULL
# Run 2000 iterations of 100 numbers (in 100 bins between 0 to 1)
for(i in seq(1,100,1)){

  # Use lhs function in R. 100 bins, 2 iterations.
  loop_2 <- randomLHS(100, 2)
  
  # Use rbind to stack each iteration on top of the other to create a one column 
  # list of 200000 samples with equal distribution in 100 bins.
  # Multiplied by 10 to get range of data from 0 to 10
  DATA2 <- rbind(DATA2, data.frame(i=i, Result=loop_2))
  
  # print the i value so you can track progress
  # print(i)
  # Close the loop
}

# Save these two datasets for later re-use
# write.csv(DATA1, file = "../Data/DATA1.csv", row.names = FALSE)
# write.csv(DATA2, file = "../Data/DATA2.csv", row.names = FALSE)
```

## Control scenario: gradient-neutral consumer movement

We begin our numerical analyses of our model with the control scenario, in 
which consumers move between two ecosystems that have equal environmental 
fertility. Consumer movement in this scenario is _gradient-neutral_, as the 
environment is homogeneous in terms of resource availability. The results of 
this first set of model iterations produce the values used at the denominator of
the response ratio (_LRR_) used to capture changes in local and meta-ecosystem 
function values (see section [Visual Deliverables] below). Below, we describe 
each step of the analyses in detail: later analyses will not describe these steps
again. 

### Step 1: plug the parameter sets into the model

First, we allocate an empty dataframe `PRED` to contain the results of each 
iteration of the model. This dataframe will contain the parameter values and the 
resulting local and meta-ecosystem function values.

```{r empty-df-allocation,echo=TRUE,tidy=TRUE}
# Allocate an empty data frame to save the data in, then allocate some rows and 
# columns. We will replace the current numbers with results below 
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers 
# (P1, P2), consumers (C1, C2), disperses (Q)

PRED <- NULL

PRED <-rbind(PRED, data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))
```

Now we run the model. We first set the values for both nutrient input rates in
ecosystem 1 (`I1` in the code chunks) and ecosystem 2 (`I2`) at 10. Recall that 
this is the control scenario with equal environmental fertility. We also set the
value of the inorganic nutrient leaching rate ($\ell$) at 0.1.

<aside>
Note that we refer to `I1` and `I2` as either the 
**nutrient input rates** or the **environmental fertility** of the two ecosystems 
</aside>

The code chunk below runs the model using a `for` loop that, over 10 000 time 
steps, iterates the model's single feasible equilibrium to calculate:
  
* stocks of Nutrients (`N1`, `N2`), Producers (`P1`, `P2`), and Consumers (`C1`, 
`C2`)
* the Dispersers' Pool (`Q`) stock
* the recycling flux for each biotic compartment
(`FLUX_X`, where `X` is the compartment) 
* the productivity for each biotic compartment (`PROD_X`, where `X` is the 
trophic compartment)

in both local ecosystems. At each time step, we draw a random value for each
parameter from either the `DATA1` or `DATA2` dataset---depending on whether the 
parameter is scaled 0--10 or 0--1, respectively. Then, we plug these values into 
the model's equilibria and ecosystem function formulas derived in Mathematica 
[@Mathematica], and finally store both the randomly drawn parameter values and 
ecosystem function values in `PRED`.

Note that feasibility conditions for this model cannot be resolved analytically. 
Hence, we do not check that our random parameters values satisfy them. Rather, 
we run stability analyses of each parameter set below.

```{r dispPool-simuls, echo=TRUE}
# Here we set values for parameters that we will not vary during the simulations
# Nutrients input rate in each patch
I1 = 10
I2 = 10
# Patch leaching rate/soil loss rate
l = 0.1

# We want to start simulations at 0
i1 = 0

for (i in seq(0,9999,1)){
	# go to the next row
	i1 = i1 + 1

# Let's sample the parameter values from DATA. We will sample these i times as 
# defined by the for loop above

  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4] # in ecosystem 1
  a2 = DATA1[i1,5] # in ecosystem 2
  # death rates (= recycling rate)
  h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
  h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystems 2
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Dispersers' pool Q
  g = DATA1[i1,11]
  # movement rate from the Dispersers' pool Q
  m = DATA1[i1,12]
  # assimilation efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PRED[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                 # Nutrient stock in ecosystem 1
                 ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 # Primary Producers biomass in ecosystem 1
                 (d1 + g)/(a1*e1),
                 # Consumers biomass in ecosystem 1
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 # Nutrient stock in ecosystem 2
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 # Primary Producers biomass in ecosystem 2
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 # Consumer biomass in ecosystem 2
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 # Consumer biomass in the Dispersers' Pool (Q)
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 # Nutrient Flux for Primary Producers in Ecosystem 1
                 ((d1 + g)*h1)/(a1*e1),
                 # Nutrient Flux for Consumers in Ecosystem 1
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 # Nutrient Flux for Primary Producers in Ecosystem 2
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 # Nutrient Flux for Consumers in Ecosystem 2
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 # Nutrient Flux for Ecosystem 1
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 # Nutrient Flux for Ecosystem 2
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 # Nutrient Flux in the Dispersers' Pool (Q)
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 # Primary Productivity in Ecosystem 1
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 # Consumer (=Secondary) Productivity in Ecosystem 1
                 (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 # Primary Productivity in Ecosystem 2
                 ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)),
                 # Consumer (=Secondary) Productivity in Ecosystem 2
                 (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
}
```

### Step 2: calculate meta-ecosystem functions values

To investigate any influence of consumer movement on nutrient cycling 
at regional spatial scales, we calculate local and meta-ecosystem total biomass 
(`Ntot`,`Ptot`, `Ctot`), meta-ecosystem nutrient flux (`MetaEcoFlux`) and 
trophic compartment nutrient flux (`FLUX_Ptot`, `FLUX_Ctot`) and productivity 
(`PROD_Ptot`, `PROD_Ctot`). Furthermore, we manually calculate each ecosystem's 
own total recycling flux as the sum of the flux of its 2 biotic compartments, as
a check on the Mathematica-derived formulas used above. 

```{r meta-eco-function-calc, echo=TRUE,tidy=TRUE}
# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem biomass
PRED$Ntot <- PRED$N1+PRED$N2
PRED$Ptot <- PRED$P1+PRED$P2
PRED$Ctot <- PRED$C1+PRED$C2

# now calculate recycling flux for the local ecosystem manually to double check 
# the formulae used above are correct 
PRED$FLUX_Eco1_check <- PRED$FLUX_P1 + PRED$FLUX_C1
PRED$FLUX_Eco2_check <- PRED$FLUX_P2 + PRED$FLUX_C2

# and the meta-ecosystem recycling flux
PRED$FLUX_Ptot <- PRED$FLUX_P1 + PRED$FLUX_P2
PRED$FLUX_Ctot <- PRED$FLUX_C1 + PRED$FLUX_C2
PRED$MetaEcoFlux <- PRED$FLUX_Eco_1 + PRED$FLUX_Eco_2 - PRED$FLUX_Q

# finally, calculate the production for each compartment at meta-ecosystem level
PRED <- dplyr::mutate(PRED, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PRED <- dplyr::mutate(PRED, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")
```

### Step 3: flag parameter sets with no biological meaning

Parameter sets that produce values of the model's state variable that are 
$\leq 0$ lack biological meaning. Accordingly, in the code chunk below,
we flag these parameter sets for later exclusion from the analysis. 

```{r bio-nonsense-flad, echo=TRUE, tidy=TRUE}
# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will flag them in the PRED dataset.
PRED <- PRED %>% dplyr::mutate(., biosense = ifelse(N1 > 0 & 
                                                    P1 > 0 & 
                                                    C1 > 0 & 
                                                    N2 > 0 & 
                                                    P2 > 0 & 
                                                    C2 > 0 & 
                                                    Q > 0, 
                                                    "yes", 
                                                    "no"), 
                               .after = MetaEcoFlux) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

### Step 4: stability analyses

We perform the stability analyses on the model by fitting the same sets of 
parameter values and equilibrium state variable values used above to the partial 
derivatives extracted from the model's Jacobian matrix evaluated in Mathematica 
[@Mathematica]. We evaluate stability of each parameter set by checking 
whether the real part of the leading eigenvalue of the Jacobian is positive or 
negative [@OttoDay2011]. If the real part of the Jacobian's leading eigenvalue 
is negative, the equilibrium is stable [@OttoDay2011].

```{r pred-jacobian-solve, echo=TRUE, tidy=TRUE}
# create an empty dataframe
MathStab <- NULL

for (i in 1:nrow(PRED)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = PRED$I1[i]
  I2 = PRED$I2[i]
  l = PRED$l[i]
  u1 = PRED$u1[i]
  u2 = PRED$u2[i]
  a1 = PRED$a1[i]
  a2 = PRED$a2[i]
  h1 = PRED$h1[i]
  h2 = PRED$h2[i]
  d1 = PRED$d1[i]
  d2 = PRED$d2[i]
  g = PRED$g[i]
  m = PRED$m[i]
  c = PRED$c[i]
  e1 = PRED$e1[i]
  e2 = PRED$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = PRED$Q[i]
  dN1 = PRED$N1[i]
  dP1 = PRED$P1[i]
  dC1 = PRED$C1[i]
  dN2 = PRED$N2[i]
  dP2 = PRED$P2[i]
  dC2 = PRED$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  MathStab <- rbind(MathStab, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                         h2, d1, d2, g, m, c, e1, e2, d1, dN1, dP1,
                                         dC1, dN2, dP2, dC2,
                                         EiV1 = Re(eigen(Jacob)$values[1]),
                                         EiV2 = Re(eigen(Jacob)$values[2]),
                                         EiV3 = Re(eigen(Jacob)$values[3]),
                                         EiV4 = Re(eigen(Jacob)$values[4]),
                                         EiV5 = Re(eigen(Jacob)$values[5]),
                                         EiV6 = Re(eigen(Jacob)$values[6]), 
                                         EiV7 = Re(eigen(Jacob)$values[7]),
                                         maxEv = max(Re(base::eigen(Jacob)$values)),
                                         stable = stable,
                                         biosense = PRED$biosense[i]))
}

MathStab$stable <- as.factor(MathStab$stable)

# separate unstable equilibria to work with later
MathStabUS <- subset(MathStab, MathStab$stable == "unstable")
```

According to the stability analyses run above, about **`r prettyNum((nrow(MathStabUS)/nrow(MathStab))*100, digits = 3)`%** of the 
parameter sets produced unstable results (i.e., 
`r prettyNum(nrow(MathStabUS))` out of `r prettyNum(nrow(MathStab))` 
iterations). 

### Step 5: exclude unstable parameter sets from further analyses

Now, let's check if the parameter sets that produce unstable equilibria are also
those that produce equilibria lacking biological meaning---i.e., those where 
state variables values at equilibrium are $\leq 0$.

```{r unstable-biononsense-check, echo=TRUE, tidy=TRUE}
biononsense <- subset(PRED, PRED$biosense == "no")

identical(as.numeric(MathStabUS[ , "TIME"]), biononsense[ , "TIME"])
```

It appears that they are. Hence, let's add the stable/unstable information to 
`PRED`.

```{r pred-edit, echo=TRUE,tidy=TRUE}
PRED <- left_join(PRED, select(MathStab, !c(I1:maxEv)), by = c("TIME", "biosense"))
```

Now, let's exclude these unstable parameter sets from the 
analyses below and from our results. 

We are also going to sample the dataset
`PRED`, that contains the results of our model's iterations, for 1000 random
iterations results. We will store these in `PRED_1k` and use them in Figures 
\@ref(fig:simulbplot), \@ref(fig:g-change), \@ref(fig:m-change), 
\@ref(fig:c-change), \@ref(fig:nut-flux-equal-I) below
to produce some preliminary graphs of our results.

```{r unstable-nonsense-excl, echo=TRUE, tidy=TRUE}
PREDpos <- filter(PRED, PRED$biosense == "yes" & PRED$stable == "stable")

# sample PREDpos to only use 1000 random simulation results
PRED_sample1000 <- PREDpos[sample(nrow(PREDpos), size = 1000), ]

PRED_1k <- droplevels(PRED_sample1000)
```

Before proceeding further, let's save the `PRED` object to disk, for ease of
use in the future.

```{r pred-save, echo=TRUE,tidy=TRUE}
write.csv(PRED, file = "../Results/PRED.csv", row.names = FALSE)
```

### Step 6: explore results graphically

We now investigate how the presence of unidirectional, gradient-neutral consumer 
movement influences the meta-ecosystem's behavior using box-plots produced using 
`PRED_1k`. Note that in the figures below, "Donor" always indicates ecosystem 1 
and "Recipient" always indicates ecosystem 2.

#### Biomass and nutrient stock accumulation

```{r simulbplot, echo=TRUE, tidy=TRUE, fig.cap="Biomass stock values at equilibrium for local and meta-ecosystem scale, drawn using 1k randomly-drawn data points from the model simulations. Consumer movement from ecosystem 1 to ecosystem 2 via the dispersers' pool results in foraging pressure of consumers being transferred from producers in ecosystem 1 to those in ecosystem 2. Primary producers in ecosystem 1 are thus released from foraging pressure while those in ecosystem 2 are depressed. In turn, this leads to differences in nutrient stocks between the two ecosystems at both the local and meta-ecosystem extents. Point-down triangles identify outliers; labels on top of the compartments' boxplots report median values for the full set of simulations (i.e., 10k iterations). Values on the y-axis are limited between [0, 100] to zoom in on the variation in the results."}
# pivot the dataset to longer format for boxplot plotting
PRED_biomass_long <- select(PRED_1k, N1:Q, Ntot:Ctot) %>%
  pivot_longer(.,
               names_to = "Compartment",
               values_to = "Stock",
               cols = c(N1, P1, C1, N2, P2, C2, Q,
                        Ntot, Ptot, Ctot)) %>%
  dplyr::mutate(.,
                Ecosystem = if_else(Compartment == "N1" |
                                      Compartment == "C1" |
                                      Compartment == "P1",
                                    "Donor",
                                    if_else(Compartment == "N2" |
                                              Compartment == "P2" |
                                              Compartment=="C2",
                                            "Recipient",
                                            if_else(Compartment == "Q",
                                                    "Dispersers Pool",
                                                    "Meta-ecosystem"))))

PRED_biomass_long$Compartment <- as_factor(PRED_biomass_long$Compartment)
PRED_biomass_long$Ecosystem <- as_factor(PRED_biomass_long$Ecosystem)

comparts_medians <- PRED_biomass_long %>%
  dplyr::group_by(Compartment, Ecosystem) %>%
  dplyr::summarise(., median = median(Stock),
                   .groups = "keep")

ggplot(data = PRED_biomass_long,
       aes(x = Compartment, y = Stock, col = Ecosystem)) +
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE,
                 outlier.shape = 25, jitter.shape = 21,
                 outlier.stroke = 1, jitter.stroke = 1) +
  stat_summary(geom = "label", fun = quantile,
                 fun.args = list(probs = 0.5),
                 aes(label = round(after_stat(y), 2)),
                 position = position_dodge(width = 0.2),
                 show.legend = F, size = 3,
                 label.padding = unit(0.15, "lines"),
                 label.size = 0.15,
                 fontface = "bold",
                 color = "black") +
  facet_grid(.~Ecosystem, scales = "free") +
  scale_color_manual(values = met.brewer("Egypt", 4)) +
  theme_pubr() +
  coord_cartesian(y = c(0, 100)) +
  theme(legend.position = "none")

#ggsave(filename = "../Results/ModelEq_base.pdf", device = "pdf", dpi = 300, height = 5)
```

The graph above shows a spatial trophic cascade [@Knight2005;@Monk2022]. In ecosystem 2,
the influx of consumers from ecosystem 1 increases the consumer biomass, in turn
depressing the producers' abundance and releasing the nutrient stock from the
producers' trophic pressure. Conversely, in ecosystem 1, consumers' numbers fall
steadily---due to the combined action of mortality and emigration towards
ecosystem 2---thus releasing the producers from the trophic pressure exerted by
consumers. In turn, this lets producers grow unchecked, depressing the nutrient
stocks in ecosystem 1. We can see this as well by looking at the change of log~10~
biomass values for each trophic compartment with respect to the two movement
parameters: `g`, the rate of consumer movement from ecosystem 1 to the
dispersers' pool `Q` (Figure \@ref(fig:g-change)), and `m`, the rate of consumer
movement from the dispersers' pool `Q` to ecosystem 2 (Figure \@ref(fig:m-change)).

```{r g-change, echo=TRUE, tidy=TRUE, fig.cap="Change in biomass in the meta-ecosystems' trophic compartments with change in the movement rate from the donor ecosystem 1 to the dispersers' pool (g). Each facet presents results for a trophic compartment, with color identifying local and meta-ecosystem. White lines are regression lines with 95% CI (grey shaded areas). Note the log~10~ scale on the y-axis. Graph produced using 1000 randomly-drawn data points from the model's analyses."}

eco_levels <- c("N1" = "Nutrient", "P1" = "Producers", "C1" = "Consumers",
                "N2" = "Nutrient", "P2" = "Producers", "C2" = "Consumers",
                "Q" = "Dispersers", "Ntot" = "Nutrient",
                "Ptot" = "Producers", "Ctot" = "Consumers")

# pivot the dataset to longer format for boxplot plotting
PRED_long <- pivot_longer(PRED_1k,
                          names_to = "Compartment",
                          values_to = "Stock",
                          cols = c(N1, P1, C1, N2, P2, C2, Q,
                                   Ntot, Ptot, Ctot)) %>%
  dplyr::mutate(., Ecosystem = if_else(Compartment == "N1" |
                                         Compartment == "C1" |
                                         Compartment == "P1",
                                       "Donor",
                                       if_else(Compartment == "N2" |
                                                 Compartment == "P2" |
                                                 Compartment=="C2", "Recipient",
                                               if_else(Compartment == "Q",
                                                       "Dispersers",
                                                       "Meta-ecosystem"))))

PRED_long$Compartment <- as_factor(PRED_long$Compartment)
PRED_long$Ecosystem <- as_factor(PRED_long$Ecosystem)

ggplot(PRED_long, aes(g, log10(Stock), col = Ecosystem)) +
  geom_point(alpha = 0.15, shape = 21, size = 2, stroke = 1) +
  geom_smooth(method = "lm", col = "white", se = T, lwd = .4) +
  facet_grid(.~Compartment) +
  scale_color_manual(values = met.brewer("Egypt", 4)) +
  theme_pubr() +
  guides(colour = guide_legend(override.aes = list(alpha = 1))) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8),
        text = element_text(size = 11))
```

```{r m-change, echo=TRUE, tidy=TRUE, fig.cap="Change in biomass in the meta-ecostystem's trophic compartments with change in movement rate from the disperser pool to the recipient ecosystem 2 (m). Graph produced using 1000 randomly-drawn data points from the model's analyses. Note the log~10~ scale on the y-axis. All other specifications as in Figure 2. "}

ggplot(PRED_long, aes(m, log10(Stock), col = Ecosystem)) +
  geom_point(alpha = 0.15, shape = 21, size = 2, stroke = 1) +
  geom_smooth(method = "lm", col = "white", se = T, lwd = .4) +
  facet_grid(.~Compartment) +
  scale_color_manual(values = met.brewer("Egypt", 4)) +
  theme_pubr() +
  guides(colour = guide_legend(override.aes = list(alpha = 1))) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8),
        text = element_text(size = 11))
```

We can see a similar effect when looking at the change in biomass in
the two local ecosystems with change in the mortality rate of consumers while in
the dispersers' pool (parameter `c` in the model; Figure \@ref(fig:c-change)).

```{r c-change, echo=TRUE, tidy=TRUE, fig.cap="Change in biomass in the meta-ecostystem's trophic compartments with change in the consumer death rate while in the dispersers' pool (c). This could represent predation risk, but also environmental hazards and stochastic events such as crossing a dangerous linear feature of the landscape---e.g., a busy highway. Graph produced using 1000 randomly-drawn data points from the model's analyses. Note the log~10~ scale on the y-axis. All other specifications as in Figure 2."}

ggplot(PRED_long, aes(c, log10(Stock), col = Ecosystem)) +
  geom_point(alpha = 0.15, shape = 21, size = 2, stroke = 1) +
  geom_smooth(method = "lm", col = "white", se = T, lwd = .4) +
  facet_grid(.~Compartment) +
  scale_color_manual(values = met.brewer("Egypt", 4)) +
  theme_pubr() +
  guides(colour = guide_legend(override.aes = list(alpha = 1))) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, size = 8),
        text = element_text(size = 11))
```

#### Nutrient flux

In the graphs below (Figure \@ref(fig:nut-flux-equal-I)), we look at nutrient
flux values in each ecosystem and in the meta-ecosystem for each iteration of
the model.

First, we will extract the flux columns (see above) from the `PRED_1k` dataframe
into a new one which we will call `FluxPRED`. We will then pivot this dataframe
from wide to long format, using function `pivot_longer` from package `tidyr`.

```{r flux-graphs-prep, echo=TRUE, tidy=TRUE}
FluxPRED <- PRED_1k %>%
  dplyr::select(TIME:c,FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>%
  tidyr::pivot_longer(., names_to = "Compartment",
                      values_to = "Flux",
                      cols = c(FLUX_P1:MetaEcoFlux)) %>%
  dplyr::mutate(., Scale = if_else(Compartment == "FLUX_P1" |
                                     Compartment == "FLUX_C1" |
                                     Compartment == "FLUX_Eco_1",
                                   "Donor",
                                   if_else(Compartment == "FLUX_P2" |
                                             Compartment == "FLUX_C2" |
                                             Compartment == "FLUX_Eco_2",
                                           "Recipient",
                                           "Meta-ecosystem"))) %>%
  dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))
```

Now, we produce the box-and-whiskers plot of recycling flux in local and
meta-ecosystem.

```{r nut-flux-equal-I, echo=TRUE, tidy=TRUE, fig.cap="Nutrient flux at local and meta-ecosystem scales when consumers move from ecosystem 1 to 2. The two ecosystems have the same fertility---i.e., basal inorganic input values are the same. Point-down triangles identify outliers; labels on top of the compartments’ boxplots report median values for the full set of simulations. The y-axis is constrained between [0, 500] to show the variation in the results. Graph produced using 1000 randomly-drawn data points from the model's analyses."}
FluxPRED$Scale <- as.factor(FluxPRED$Scale)
FluxPRED$Compartment <- as.factor(FluxPRED$Compartment)

comparts_medians <- FluxPRED %>%
  dplyr::group_by(Compartment, Scale) %>%
  dplyr::summarise(., median = median(Flux), .groups = "keep")

FluxPRED %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment,
                                             c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1",
                                               "FLUX_P2", "FLUX_C2", "FLUX_Eco_2",
                                               "MetaEcoFlux"))) %>%
  dplyr::mutate(., Scale = fct_relevel(Scale,
                                       c("Donor",
                                         "Recipient",
                                         "Meta-ecosystem"))) %>%
  ggplot(., aes(x = Compartment, y = Flux)) +
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.25, outlier.shape = 25, jitter.shape = 21) +
  stat_summary(geom = "label", fun = quantile,
                 fun.args = list(probs = 0.5),
                 aes(label = round(after_stat(y), 2)),
                 position = position_dodge(width = 0.2),
                 show.legend = F, size = 3,
                 label.padding = unit(0.15, "lines"),
                 label.size = 0.15,
                 fontface = "bold",
                 color = "black") +
  facet_grid(.~Scale, scales = "free") +
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1",
                              "FLUX_Ptot" = "Producers", "FLUX_C2" = "C2",
                              "FLUX_P2" = "P2", "FLUX_Ctot" = "Consumers",
                              "FLUX_Eco_1" = "Donor", "FLUX_Eco_2" = "Recipient",
                              "MetaEcoFlux" = "Meta-ecosystem")) +
  theme_pubr() +
  coord_cartesian(y = c(0, 500)) +
  theme(legend.position = "none", axis.title.x = element_blank())
```

## Experimental scenarios: along- and against-gradient consumer movement

Here, we investigate the influence of consumers moving from ecosystem 1 to 
ecosystem 2 when there is a gradient of nutrient availability between the two 
ecosystems. We will investigate two scenarios: higher environmental fertility in 
the donor ecosystem 1 (i.e., `I1` >> `I2`) and higher environmental fertility in 
the recipient ecosystem 2 (i.e., `I1` << `I2`). Note that the environmental 
leaching rate of  each ecosystem---i.e., the rate at which nutrients 
leave local ecosystems independently of trophic processes---is invariant and equal 
between the two ecosystems  ($\ell = 0.1$).

The analysis will follow the same steps as before: draw parameter values 
from our `DATA1` and `DATA2` data objects, simulate model 
behavior, run stability analyses, remove equilibria that are unstable and/or 
lack biological sense, and graphically inspect and interpret the results.

### Along-gradient consumer movement

We begin by simulating a meta-ecosystem where the donor ecosystem 1 has higher 
environmental fertility than the recipient ecosystem 2. Consumers move 
_along-gradient_, in a _diffusive_ way that resembles how organismal movement 
has been represented in previous studies [e.g., @Gravel2010a].

```{r simuls-I2small, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 > I2
I1=18
I2=2

# Leaching does not change as is still equal across ecosystems
l = 0.1

# Allocate an empty data frame to save the data in
PREDI2 <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDI2 <-rbind(PREDI2, data.frame(TIME=seq(0,100,1), 
                                  I1 = I1,  I2 = I2, l = l, 
                                  u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                  a1 = seq(0,100,1), a2 = seq(0,100,1), 
                                  h1 = seq(0,100,1), h2 = seq(0,100,1), 
                                  d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                  g = seq(0,100,1), m = seq(0,100,1), 
                                  c = seq(0,100,1), 
                                  e1 = seq(0,100,1), e2 = seq(0,100,1), 
                                  N1=seq(0,100,1), P1=seq(0,100,1), 
                                  C1=seq(0,100,1), N2=seq(0,100,1), 
                                  P2=seq(0,100,1), C2=seq(0,100,1), 
                                  Q = seq(0,100,1), 
                                  FLUX_P1 = seq(0,100,1), 
                                  FLUX_C1 = seq(0,100,1), 
                                  FLUX_P2 = seq(0,100,1), 
                                  FLUX_C2 = seq(0,100,1), 
                                  FLUX_Eco_1 = seq(0,100,1), 
                                  FLUX_Eco_2 = seq(0,100,1), 
                                  FLUX_Q = seq(0,100,1), 
                                  PROD_P1 = seq(0,100,1), 
                                  PROD_C1 = seq(0,100,1), 
                                  PROD_P2 = seq(0,100,1), 
                                  PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,9999,1)){
	# go to the next row
	i1 = i1 + 1

  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate)
  h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
  h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Disperser's pool Q
  g = DATA1[i1,11]
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,12]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDI2[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                 ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*h1)/(a1*e1),
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
                 (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
  }

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDI2$Ntot <- PREDI2$N1 + PREDI2$N2
PREDI2$Ptot <- PREDI2$P1 + PREDI2$P2
PREDI2$Ctot <- PREDI2$C1 + PREDI2$C2

# now calculate recycling flux for the local ecosystem
PREDI2$FLUX_Eco1_check <- PREDI2$FLUX_P1 + PREDI2$FLUX_C1
PREDI2$FLUX_Eco2_check <- PREDI2$FLUX_P2 + PREDI2$FLUX_C2

# and the meta-ecosystem recycling flux
PREDI2$FLUX_Ptot <- PREDI2$FLUX_P1 + PREDI2$FLUX_P2
PREDI2$FLUX_Ctot <- PREDI2$FLUX_C1 + PREDI2$FLUX_C2
PREDI2$MetaEcoFlux <- PREDI2$FLUX_Eco_1 + PREDI2$FLUX_Eco_2 - PREDI2$FLUX_Q

# Finally, calculate the production for each compartment at the meta-ecosystem scale
PREDI2 <- dplyr::mutate(PREDI2, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDI2 <- dplyr::mutate(PREDI2, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will flag them in the PREDI2 dataset.
PREDI2 <- PREDI2 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & 
                                     P1 > 0 & 
                                     C1 > 0 & 
                                     N2 > 0 & 
                                     P2 > 0 & 
                                     C2 > 0 & 
                                     Q > 0, 
                                     "yes", 
                                     "no"), 
                .after = MetaEcoFlux) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

#### Stability Analyses

Here we perform stability analyses for the model in this scenario where 
`I1` >> `I2`. The rationale and code are the same as above.

```{r predI2-jacobian-solve, echo=TRUE, tidy=TRUE}
# create an empty dataframe
MathStabI2 <- NULL

for (i in 1:nrow(PREDI2)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = PREDI2$I1[i]
  I2 = PREDI2$I2[i]
  l = PREDI2$l[i]
  u1 = PREDI2$u1[i]
  u2 = PREDI2$u2[i]
  a1 = PREDI2$a1[i]
  a2 = PREDI2$a2[i]
  h1 = PREDI2$h1[i]
  h2 = PREDI2$h2[i]
  d1 = PREDI2$d1[i]
  d2 = PREDI2$d2[i]
  g = PREDI2$g[i]
  m = PREDI2$m[i]
  c = PREDI2$c[i]
  e1 = PREDI2$e1[i]
  e2 = PREDI2$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = PREDI2$Q[i]
  dN1 = PREDI2$N1[i]
  dP1 = PREDI2$P1[i]
  dC1 = PREDI2$C1[i]
  dN2 = PREDI2$N2[i]
  dP2 = PREDI2$P2[i]
  dC2 = PREDI2$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  MathStabI2 <- rbind(MathStabI2, 
                      data.frame(TIME=i, I1 , I2, l, u1, u2, a1, a2, h1, h2, 
                                 d1, d2, g, m, c, e1, e2, dQ, dN1, dP1, dC1, dN2,
                                 dP2, dC2, EiV1=Re(eigen(Jacob)$values[1]),
                                 EiV2=Re(eigen(Jacob)$values[2]),
                                 EiV3=Re(eigen(Jacob)$values[3]),
                                 EiV4=Re(eigen(Jacob)$values[4]),
                                 EiV5=Re(eigen(Jacob)$values[5]),
                                 EiV6=Re(eigen(Jacob)$values[6]),
                                 EiV7 = Re(eigen(Jacob)$values[7]), 
                                 maxEv=max(Re(base::eigen(Jacob)$values)),
                                 stable=stable, biosense=PREDI2$biosense[i]))
}

MathStabI2$stable <- as.factor(MathStabI2$stable)

# separate unstable equilibria to work with later
MathStabI2US <- subset(MathStabI2, MathStabI2$stable == "unstable")
```

**`r prettyNum((nrow(MathStabI2US)/nrow(MathStabI2))*100, digits = 3)`%** of the
stability analyses runs produced unstable results (i.e., 
`r prettyNum(nrow(MathStabI2US))` out of `r prettyNum(nrow(MathStabI2))` 
iterations). Now we check if these are the same ones that produce equilibria 
where state variables are < 0 at equilibrium (i.e., not biologicaly 
plausible).

```{r unstable-biononsense-check-I2, echo=TRUE, tidy=TRUE}
I2biononsense <- subset(PREDI2, PREDI2$biosense == "no")

identical(as.numeric(MathStabI2US[ , "TIME"]), I2biononsense[ , "TIME"])
```

Since it appears that they are, let's add the stable/unstable information to 
`PREDI2`.

```{r predI2-edit, echo=TRUE,tidy=TRUE}
PREDI2 <- left_join(PREDI2, select(MathStabI2, !c(dN1:maxEv)), 
                    by = c("TIME", "I1", "I2", "l", "u1", "u2", "a1", "a2", "h1", 
                           "h2", "d1", "d2", "g", "m", "c", "e1", "e2", "biosense"))
```

Now, let's exclude the unstable parameter sets from the analyses below and from 
our results. Then, we will sample 1000 iterations out of `PREDI2` to use in
later figures.

```{r unstable-nonsense-excl-I2, echo=TRUE, tidy=TRUE}
PREDI2pos <- filter(PREDI2, PREDI2$biosense == "yes" & PREDI2$stable == "stable")

# sample PREDpos to only use 1000 random simulation results
PREDI2_sample1000 <- PREDI2pos[sample(nrow(PREDI2pos), size = 1000), ]

PREDI2_1k <- droplevels(PREDI2_sample1000)
```

#### Graphs

```{r simulbplot-I2, echo=TRUE, tidy=TRUE,fig.cap="Effects of along-gradient, diffusive consumers movement in a meta-ecosystem. Compared to the control scenario, the release of primary producers in ecosystem 1 is larger following movement of consumers out of this ecosystem (confront this figure with Figure 1). Environmental fertility values: I~1~ = 18, I~2~ = 2. All other specifications as in Figure 1."}
# pivot the dataframe
PREDI2_biomass_long <- pivot_longer(PREDI2_1k,
                                    names_to = "Compartment",
                                    values_to = "Stock",
                                    cols = c(N1, P1, C1, N2, P2, C2, Q,
                                             Ntot, Ptot, Ctot)) %>%
  dplyr::mutate(.,
                Ecosystem = if_else(Compartment == "N1" |
                                      Compartment == "P1" |
                                      Compartment == "C1", "Donor",
                                    if_else(Compartment == "N2" |
                                              Compartment == "P2" |
                                              Compartment=="C2",
                                            "Recipient",
                                            if_else(Compartment =="Q",
                                                    "Dispersers' Pool",
                                                    "Meta-ecosystem")))) %>%
  dplyr::mutate(.,
                Ecosystem = fct_relevel(Ecosystem,
                                        "Donor",
                                        "Recipient",
                                        "Meta-ecosystem")) %>%
  dplyr::filter(.,
                Ecosystem != "Dispersers' Pool")

PREDI2_biomass_long$Compartment <- as_factor(PREDI2_biomass_long$Compartment)
PREDI2_biomass_long$Ecosystem <- as_factor(PREDI2_biomass_long$Ecosystem)

comparts_medians <- PREDI2_biomass_long %>%
  dplyr::group_by(Compartment, Ecosystem) %>%
  dplyr::summarise(., median = median(Stock), .groups = "keep")

I2bm <- ggplot(data=PREDI2_biomass_long,
               aes(x = Compartment, y = Stock, col = Ecosystem)) +
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) +
  stat_summary(geom = "label", fun = quantile,
                 fun.args = list(probs = 0.5),
                 aes(label = round(after_stat(y), 2)),
                 position = position_dodge(width = 0.2),
                 show.legend = F, size = 3,
                 label.padding = unit(0.15, "lines"),
                 label.size = 0.15,
                 fontface = "bold",
                 color = "black") +
  facet_grid(.~Ecosystem, scales = "free") +
  scale_color_manual(values = met.brewer("Egypt", 4)) +
  ggtitle("Organic Biomass and Nutrients Stock") +
  theme_pubr() +
  coord_cartesian(y = c(0, 100)) +
  theme(legend.position = "none")

I2bm
```

```{r I2small-flux, echo=TRUE, tidy=TRUE,fig.cap="With a higher fertility in the ecosystem 1 (i.e., I~1~ >> I~2~) nutrient flux in this ecosystem increases, most likely as a consequence of the release primary producers. Conversely, ecosystem 2 shows lower and less variable levels of nutrient flux. At the meta-ecosystem scale, nutrient flux is higher than in either local ecosystems but lower than in the case of equal environmental fertility across ecosystems (Figure 7). Environmental fertility values: I~1~ = 18, I~2~ = 2. All other specifications as in Figure 7."}

FluxPREDI2 <- PREDI2_1k %>%
  dplyr::select(.,
                TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>%
  tidyr::pivot_longer(.,
                      names_to = "Compartment",
                      values_to = "Flux",
                      cols = c(FLUX_P1:MetaEcoFlux)) %>%
  dplyr::mutate(.,
                Scale = if_else(Compartment == "FLUX_P1"
                                | Compartment == "FLUX_C1"
                                | Compartment == "FLUX_Eco_1",
                                "Donor", if_else(Compartment == "FLUX_P2" |
                                                   Compartment == "FLUX_C2" |
                                                   Compartment == "FLUX_Eco_2",
                                                 "Recipient",
                                                 "Meta-ecosystem"))) %>%
  dplyr::mutate(.,
                Scale = fct_relevel(Scale,
                                       "Donor",
                                       "Recipient",
                                       "Meta-ecosystem"))

FluxPREDI2$Scale <- as.factor(FluxPREDI2$Scale)
FluxPREDI2$Compartment <- as.factor(FluxPREDI2$Compartment)

comparts_medians <- FluxPREDI2 %>%
  dplyr::group_by(Compartment, Scale) %>%
  dplyr::summarise(., median = median(Flux), .groups = "keep")

I2nf <- FluxPREDI2 %>%
  dplyr::mutate(.,
                Compartment = fct_relevel(Compartment,
                                          c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1",
                                            "FLUX_P2", "FLUX_C2", "FLUX_Eco_2",
                                            "MetaEcoFlux"))) %>%
  ggplot(aes(x = Compartment, y = Flux)) +
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) +
  stat_summary(geom = "label", fun = quantile,
                 fun.args = list(probs = 0.5),
                 aes(label = round(after_stat(y), 2)),
                 position = position_dodge(width = 0.2),
                 show.legend = F, size = 3,
                 label.padding = unit(0.15, "lines"),
                 label.size = 0.15,
                 fontface = "bold",
                 color = "black") +
  facet_grid(.~Scale, scales = "free") +
  coord_cartesian(y = c(0, 300)) +
  scale_x_discrete(labels = c("FLUX_C1" = "C1",
                              "FLUX_P1" = "P1",
                              "FLUX_Eco_1" = "Donor",
                              "FLUX_C2" = "C2",
                              "FLUX_P2" = "P2",
                              "FLUX_Eco_2" = "Recipient",
                              "MetaEcoFlux" = "Meta-ecosystem")) +
  ggtitle("Nutrient Flux") +
  theme_pubr() +
  theme(legend.position = "none", axis.title.x = element_blank())

I2nf

# I2all <- I2bm + I2nf + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") + plot_layout(ncol = 1, nrow = 2)

#ggsave(I2all, filename = "../Results/LowI2BmNf.pdf", device = "pdf", dpi = 300, width = 8, height = 6)
```

### Against-gradient consumer movement

The code chunk below analyses the experimental scenario of higher environmental 
fertility in ecosystem 2. In this case, consumer movement happens counter to the
resource availability gradient  (i.e., _non-diffusive_ movement; @Gounand2018). 

```{r simuls-I1small, echo=TRUE, tidy=TRUE}
# Here we set values for inorganic Nutrients input rate in each patch
# In this case, I1 < I2
I1=2
I2=18

# leaching rate
l = 0.1

# Allocate an empty data frame to save the data in
PREDI1 <- NULL
# Allocate some rows and columns. We will replace the current numbers with results below
# Data we are calculating are (bio)mass for soil nutrients (N1, N2), producers (P1, P2), consumers (C1,C2), disperses (Q)

PREDI1 <-rbind(PREDI1, 
               data.frame(TIME=seq(0,100,1), I1 = I1,  I2 = I2, l = l, 
                          u1 = seq(0,100,1), u2 = seq(0,100,1), a1 = seq(0,100,1), 
                          a2 = seq(0,100,1), h1 = seq(0,100,1), h2 = seq(0,100,1), 
                          d1 = seq(0,100,1), d2 = seq(0,100,1), g = seq(0,100,1), 
                          m = seq(0,100,1), c = seq(0,100,1), e1 = seq(0,100,1), 
                          e2 = seq(0,100,1), N1=seq(0,100,1), P1=seq(0,100,1), 
                          C1=seq(0,100,1), N2=seq(0,100,1), P2=seq(0,100,1), 
                          C2=seq(0,100,1), Q = seq(0,100,1), FLUX_P1 = seq(0,100,1), 
                          FLUX_C1 = seq(0,100,1), FLUX_P2 = seq(0,100,1), 
                          FLUX_C2 = seq(0,100,1), FLUX_Eco_1 = seq(0,100,1), 
                          FLUX_Eco_2 = seq(0,100,1), FLUX_Q = seq(0,100,1), 
                          PROD_P1 = seq(0,100,1), PROD_C1 = seq(0,100,1), 
                          PROD_P2 = seq(0,100,1), PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in seq(0,9999,1)){
	# go to the next row
	i1 = i1 + 1

  # Let's sample the parameter values from DATA. We will sample these x times as defined by the i for loop above
  # producers uptake rates
  u1 = DATA1[i1,2] # in ecosystem 1
  u2 = DATA1[i1,3] # in ecosystem 2
  # consumers attack rates
  a1 = DATA1[i1,4]
  a2 = DATA1[i1,5]
  # death rates (= recycling rate)
  h1 = DATA1[i1,6] # death (=recycling) rate for producers in ecosystems 1
  h2 = DATA1[i1,7] # death (=recycling) rate for producers in ecosystem 2
  d1 = DATA1[i1,8] # death (=recycling) rate for consumers in ecosystem 1
  d2 = DATA1[i1,9] # death (=recycling) rate for consumers in ecosystem 2
  c = DATA1[i1,10] # death rate in the disperser's pool Q
  # movement rate to the Disperser's pool Q
  g = DATA1[i1,11]
  # movement rate from the Disperser's pool Q
  m = DATA1[i1,12]
  # efficiency of consumers 
  e1 = DATA2[i1,2] # in ecosystem 1
  e2 = DATA2[i1,3] # in ecosystem 2
  
  PREDI1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                 ((d1 - d1*e1 + g)*h1 + a1*e1*I1)/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (d1 + g)/(a1*e1),
                 (e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)),
                 (l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 ((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*h1)/(a1*e1),
                 (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2),
                 (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 ((d1 + g)*h1)/(a1*e1) + (d1*e1*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 (h2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2) + (d2*((e1*g*m*(-h1*l + I1*u1)*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)) + e2*(-h2*l + I2*u2)))/(a2*e2*l - d2*(-1 + e2)*u2),
                 (c*e1*g*(-h1*l + I1*u1))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 ((d1 + g)*((d1 - d1*e1 + g)*h1 + a1*e1*I1)*u1)/(a1*e1*(a1*e1*l + (d1 - d1*e1 + g)*u1)),
                 (e1*(d1 + g)*(-h1*l + I1*u1))/(a1*e1*l + (d1 - d1*e1 + g)*u1),
                 ((-a1*e1*(d2*(-1 + e2)*h2 - a2*e2*I2)*l*(c + m) + d2*(-1 + e2)*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*(e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l - I1*u1))))*u2*(l*(-d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(-h1*l + I1*u1)) + d2*(d1*e1*I2*(c + m)*u1 - (d1 + g)*I2*(c + m)*u1 + e1*g*m*(h1*l - I1*u1))*u2 + a1*d2*e1*l*(c + m)*(h2*l - I2*u2)))/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2)*(a2*e2*h2*l*(c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1) - a2*(a1*e1*e2*I2*l*(c + m) + e2*(d1 + g)*I2*(c + m)*u1 - e1*(d1*e2*I2*(c + m)*u1 + g*m*(h1*l -I1*u1)))*u2)),
                 (e2*l*(-a1*d2*e1*h2*l*(c + m) + d2*(d1*(-1 + e1) - g)*h2*(c + m)*u1 + a2*e1*g*m*(h1*l - I1*u1)) + d2*e2*(a1*e1*I2*l*(c + m) + (d1 + g)*I2*(c + m)*u1 - e1*(d1*I2*(c + m)*u1 + g*m*(h1*l - I1*u1)))*u2)/((c + m)*(a1*e1*l + (d1 - d1*e1 + g)*u1)*(a2*e2*l - d2*(-1 + e2)*u2))
                 )
}

# calculate meta-ecosystem biomass stocks for each trophic compartment,
# a.k.a., meta-ecosystem productivity
PREDI1$Ntot <- PREDI1$N1 + PREDI1$N2
PREDI1$Ptot <- PREDI1$P1 + PREDI1$P2
PREDI1$Ctot <- PREDI1$C1 + PREDI1$C2

# now calculate recycling flux for the local ecosystem
PREDI1$FLUX_Eco1_check <- PREDI1$FLUX_P1 + PREDI1$FLUX_C1
PREDI1$FLUX_Eco2_check <- PREDI1$FLUX_P2 + PREDI1$FLUX_C2
# and the meta-ecosystem recycling flux
PREDI1$FLUX_Ptot <- PREDI1$FLUX_P1 + PREDI1$FLUX_P2
PREDI1$FLUX_Ctot <- PREDI1$FLUX_C1 + PREDI1$FLUX_C2
PREDI1$MetaEcoFlux <- PREDI1$FLUX_Eco_1 + PREDI1$FLUX_Eco_2 - PREDI1$FLUX_Q

# Finally, calculate the compartment production at meta-ecosystem scale
PREDI1 <- dplyr::mutate(PREDI1, PROD_Ptot = PROD_P1 + PROD_P2, .after = "PROD_C2")
PREDI1 <- dplyr::mutate(PREDI1, PROD_Ctot = PROD_C1 + PROD_C2, .after = "PROD_Ptot")

# Equilibrium stocks less than or equal to 0 make no biological sense, so we 
# will remove them from the PRED dataset.

PREDI1 <- PREDI1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & 
                                     P1 > 0 & 
                                     C1 > 0 & 
                                     N2 > 0 & 
                                     P2 > 0 & 
                                     C2 > 0 & 
                                     Q > 0, 
                                    "yes", 
                                    "no"), 
                .after = MetaEcoFlux) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

#### Stability Analyses

Here we perform stability analyses for the scenario of higher environmental 
fertility in ecosystem 2, the recipient (i.e., `I1` << `I2`). The analyses 
follow the established workflow (see above).

```{r predI1-jacobian-solve, echo=TRUE, tidy=TRUE}
# create an empty dataframe
MathStabI1 <- NULL

for (i in 1:nrow(PREDI1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = PREDI1$I1[i]
  I2 = PREDI1$I2[i]
  l = PREDI1$l[i]
  u1 = PREDI1$u1[i]
  u2 = PREDI1$u2[i]
  a1 = PREDI1$a1[i]
  a2 = PREDI1$a2[i]
  h1 = PREDI1$h1[i]
  h2 = PREDI1$h2[i]
  d1 = PREDI1$d1[i]
  d2 = PREDI1$d2[i]
  g = PREDI1$g[i]
  m = PREDI1$m[i]
  c = PREDI1$c[i]
  e1 = PREDI1$e1[i]
  e2 = PREDI1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = PREDI1$Q[i]
  dN1 = PREDI1$N1[i]
  dP1 = PREDI1$P1[i]
  dC1 = PREDI1$C1[i]
  dN2 = PREDI1$N2[i]
  dP2 = PREDI1$P2[i]
  dC2 = PREDI1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  MathStabI1 <- rbind(MathStabI1, 
                      data.frame(TIME=i, I1 , I2, l, u1, u2, a1, a2, h1, h2, 
                                 d1, d2, g, m, c, e1, e2, dQ, dN1, dP1, dC1, dN2,
                                 dP2, dC2, EiV1=Re(eigen(Jacob)$values[1]),
                                 EiV2=Re(eigen(Jacob)$values[2]),
                                 EiV3=Re(eigen(Jacob)$values[3]),
                                 EiV4=Re(eigen(Jacob)$values[4]),
                                 EiV5=Re(eigen(Jacob)$values[5]),
                                 EiV6=Re(eigen(Jacob)$values[6]),
                                 EiV7 = Re(eigen(Jacob)$values[7]), 
                                 maxEv=max(Re(base::eigen(Jacob)$values)),
                                 stable=stable, biosense=PREDI1$biosense[i]))
}

MathStabI1$stable <- as.factor(MathStabI1$stable)

# separate unstable equilibria to work with later
MathStabI1US <- subset(MathStabI1, MathStabI1$stable == "unstable")
```

**`r prettyNum((nrow(MathStabI1US)/nrow(MathStabI1))*100, digits = 3)`%** of the
stability analyses runs produced unstable results (i.e., 
`r prettyNum(nrow(MathStabI1US))` out of `r prettyNum(nrow(MathStabI1))` 
iterations). As always, let's check whether these are also the parameter sets 
that produce state variable values at equilibrium that do not have biological 
meaning (i.e., <0).

```{r unstable-biononsense-check-I1, echo=TRUE, tidy=TRUE}
I1biononsense <- subset(PREDI1, PREDI1$biosense == "no")

identical(as.numeric(MathStabI1US[ , "TIME"]), I1biononsense[ , "TIME"])
```

Now, since that proved to be the case, let's add the stable/unstable information to 
`PREDI1`.

```{r predI1-edit, echo=TRUE,tidy=TRUE}
PREDI1 <- left_join(PREDI1, select(MathStabI1, !c(dN1:maxEv)), 
                    by = c("TIME", "I1", "I2", "l", "u1", "u2", "a1", "a2", "h1", 
                           "h2", "d1", "d2", "g", "m", "c", "e1", "e2", "biosense"))
```

Now, let's exclude the unstable, biological nonsense parameter sets from the 
analyses below and from our results. Then, we sample 1000 random iterations
from `PREDI1` and store them for later use in figures and comparisons.

```{r unstable-nonsense-excl-I1, echo=TRUE, tidy=TRUE}
PREDI1pos <- filter(PREDI1, PREDI1$biosense == "yes" & PREDI1$stable == "stable")

# sample PREDpos to only use 1000 random simulation results
PREDI1_sample1000 <- PREDI1pos[sample(nrow(PREDI1pos), size = 1000), ]

PREDI1_1k <- droplevels(PREDI1_sample1000)
```

#### Graphs

```{r simulbplot-I1, echo=TRUE, tidy=TRUE, fig.cap="Movement of consumer against the environmental fertility gradient leads to a strong reduction of the nutrients stock in the donor ecosystem 1, stemming from the release of local primary producers from consumer control. In the recipient ecosystem 2, the nutrients stock increases beyond the level of enrichment seen in Figure 1, as local and immigrant consumer strongly suppress the local primary producers. All other specifications as in Figure 1. Environmental fertility values: I~1~ = 2, I~2~ = 18."}
# pivot the
PREDI1_biomass_long <- pivot_longer(PREDI1_1k, names_to = "Compartment", values_to = "Stock", cols = c(N1, P1, C1, N2, P2, C2, Q, Ntot, Ptot, Ctot)) %>% dplyr::mutate(., Ecosystem = if_else(Compartment == "N1"|Compartment == "C1"|Compartment == "P1", "Donor", if_else(Compartment == "N2"|Compartment == "P2"|Compartment=="C2", "Recipient", if_else(Compartment == "Q", "Dispersers' Pool", "Meta-ecosystem")))) %>% dplyr::mutate(., Ecosystem = fct_relevel(Ecosystem, "Donor", "Recipient", "Meta-ecosystem")) %>% dplyr::filter(., Ecosystem != "Dispersers' Pool")

PREDI1_biomass_long$Compartment <- as_factor(PREDI1_biomass_long$Compartment)
PREDI1_biomass_long$Ecosystem <- as_factor(PREDI1_biomass_long$Ecosystem)

comparts_medians <- PREDI1_biomass_long %>% dplyr::group_by(Compartment, Ecosystem) %>% dplyr::summarise(., median = median(Stock), .groups = "keep")

I1bm <- ggplot(data=PREDI1_biomass_long, aes(x = Compartment, y = Stock, col = Ecosystem)) +
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 25, jitter.shape = 21) +
  stat_summary(geom = "label", fun = quantile,
                 fun.args = list(probs = 0.5),
                 aes(label = round(after_stat(y), 2)),
                 position = position_dodge(width = 0.2),
                 show.legend = F, size = 3,
                 label.padding = unit(0.15, "lines"),
                 label.size = 0.15,
                 fontface = "bold",
                 color = "black") +
  facet_grid(.~Ecosystem, scales = "free") +
  scale_color_manual(values = met.brewer("Egypt", 4)) +
  ggtitle("Organic Biomass and Nutrient Stock") +
  theme_pubr() +
  coord_cartesian(y = c(0, 100)) +
  theme(legend.position = "none")

I1bm
```

Following from the stronger trophic cascades, nutrient flux is also affected at
both local and meta-ecosystem scales when consumer movement happens against the
fertility gradient. Here, median nutrient flux in the recipient, and more
fertile, ecosystem 2 is more than double the median flux in the case of
diffusive consumer movement (Figure \@ref(fig:I2small-flux)). Furthermore, it is
also higher than in the case of equal local environmental fertility---i.e., lack
of a fertility gradient (Figure \@ref(fig:nut-flux-equal-I)). Likewise, median
nutrient flux at the meta-ecosystem scale is higher than in either the
along-gradient (Figure \@ref(fig:I2small-flux)) and no-gradient
(Figure \@ref(fig:nut-flux-equal-I)) cases.

```{r I1small-flux, echo=TRUE, tidy=TRUE, fig.cap="Nutrient flux more than doubles in ecosystem 2, when this is the more fertile of the two ecosystem and is also the recipient of consumer movement. In turn, this leads to an overall increase in the nutrient flux at the meta-ecosystem scale, compared to scenarios where environmental fertility is equal among local ecosystem (Figure 7) or is higher in the donor ecosystem (Figure 21). Environmental fertility values: I~1~ = 2, I~2~ = 18."}
FluxPREDI1 <- PREDI1_1k %>% dplyr::select(TIME:c, FLUX_P1:FLUX_Eco_2, MetaEcoFlux) %>% tidyr::pivot_longer(names_to = "Compartment", values_to = "Flux", cols = c(FLUX_P1:MetaEcoFlux)) %>% dplyr::mutate(Scale = if_else(Compartment == "FLUX_P1" | Compartment == "FLUX_C1" | Compartment == "FLUX_Eco_1", "Donor", if_else(Compartment == "FLUX_P2" | Compartment == "FLUX_C2" | Compartment == "FLUX_Eco_2", "Recipient", "Meta-ecosystem"))) %>% dplyr::mutate(., Scale = fct_relevel(Scale, "Donor", "Recipient", "Meta-ecosystem"))

FluxPREDI1$Scale <- as.factor(FluxPREDI1$Scale)
FluxPREDI1$Compartment <- as.factor(FluxPREDI1$Compartment)

comparts_medians <- FluxPREDI1 %>% dplyr::group_by(Compartment, Scale) %>% dplyr::summarise(., median = median(Flux), .groups = "keep")

I1nf <- FluxPREDI1 %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, c("FLUX_P1", "FLUX_C1", "FLUX_Eco_1", "FLUX_P2", "FLUX_C2", "FLUX_Eco_2", "MetaEcoFlux"))) %>%
  ggplot(., aes(x = Compartment, y = Flux)) +
  geom_boxjitter(outlier.intersect = TRUE, alpha = 0.1, outlier.shape = 25, jitter.shape = 21) +
  stat_summary(geom = "label", fun = quantile,
                 fun.args = list(probs = 0.5),
                 aes(label = round(after_stat(y), 2)),
                 position = position_dodge(width = 0.2),
                 show.legend = F, size = 3,
                 label.padding = unit(0.15, "lines"),
                 label.size = 0.15,
                 fontface = "bold",
                 color = "black") +
  facet_grid(.~Scale, scales = "free") +
  theme_pubr() +
  coord_cartesian(y = c(0, 400)) +
  scale_x_discrete(labels = c("FLUX_C1" = "C1", "FLUX_P1" = "P1", "FLUX_Eco_1" = "Donor", "FLUX_C2" = "C2", "FLUX_P2" = "P2", "FLUX_Eco_2" = "Recipient", "MetaEcoFlux" = "Meta-ecosystem")) +
  ggtitle("Nutrient Flux") +
  theme_pubr() +
  theme(legend.position = "none", axis.title.x = element_blank())

I1nf

# I1all <- I1bm + I1nf + plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") + plot_layout(ncol = 1, nrow = 2)

#ggsave(I1all, filename = "../Results/LowI1BmNf.pdf", device = "pdf", dpi = 300, width = 8, height = 6)
```

## Summary of Stability Analyses

Here, we summarize the results of the model's stability analyses, and 
collect this information to produce **Table S1** shown in the **Supplementary 
Materials**. As the table shows, in all three scenario tested, only a 
small portion of the parameter sets used to simulate the model's behavior at 
equilibrium produces unstable results. As detailed above, we exclude these 
unstable parameter sets from further investigations.

The table is saved in folder `../Results/` as a `.tex` file. 

```{r stability-summary, echo=TRUE, tidy=TRUE}
# summarise the number of stable and unstable parameter sets for each
# stability analysis run with the numerical approximation method and
# calculate the percentage of unstable parameter sets over the total
# iterations of the simulations
MStabSum <- MathStab %>%
  dplyr::group_by(., stable) %>% 
  dplyr::summarise(., n = n(), .groups = "keep") %>% 
  add_column(., Fertility = "Control") %>% 
  pivot_wider(id_cols = Fertility, 
              names_from = stable, 
              values_from = n) %>% 
  dplyr::mutate(., Percent = ((unstable/nrow(MathStab))*100)) 

I2MStabSum <- MathStabI2 %>% 
  dplyr::group_by(., stable) %>% 
  dplyr::summarise(., n = n(), .groups = "keep") %>% 
  add_column(., Fertility = "Along-gradient consumer movement") %>% 
  pivot_wider(id_cols = Fertility, 
              names_from = stable, 
              values_from = n) %>% 
  dplyr::mutate(., Percent = ((unstable/nrow(MathStabI2))*100)) 

I1MStabSum <- MathStabI1 %>% 
  dplyr::group_by(., stable) %>% 
  dplyr::summarise(., n = n(), .groups = "keep") %>% 
  add_column(., Fertility = "Against-gradient consumer movement") %>% 
  pivot_wider(id_cols = Fertility, 
              names_from = stable, 
              values_from = n) %>% 
  dplyr::mutate(., Percent = ((unstable/nrow(MathStabI1))*100)) 

# Bind the objects generated above into a single dataframe and then produce a 
# table that shows the number of stable and unstable parameter sets for each 
# stability analysis method 

SAsummary <- bind_rows(MStabSum, I2MStabSum, I1MStabSum) %>% 
  ungroup() %>%
  gt() %>% 
  fmt_number(columns = 4, decimals = 2) %>% 
  cols_label(., Fertility = "Fertility", 
             stable = md("Stable"), 
             unstable = md("Unstable"), 
             Percent = md("\\%")) %>% 
  tab_header(title = md("**Summary of stability analyses**, showing the number of 
             Stable and Unstable equilibria, and the percentage of Unstable 
             equilibria over the total number of iterations (n = 10000). 
             Rows are grouped by consumer movement scenario.")) %>%
  tab_style(style = list(cell_text(weight = "bold")), 
            locations = cells_column_labels()) %>% 
  tab_style(style = cell_text(align = "left", size = 18), 
            locations = cells_title())

# save it
# gtsave(SAsummary, filename = "../Results/StabilityAnalyses_SummaryTable.tex")

# view it
SAsummary
```

## Visual Deliverables---Ecosystem functions

Here we summarize the above results and produce **Figures 2, 3, and 4** shown in
the main text and **Figures D.2 to D.8** in the Supplementary Materials. We refer 
the reader to those documents to see the actual figures; here we only present 
the code used to generate them.

Note that **Figures 2, 3, and 4** in the main text use a log~10~-transformed 
response ratio ($LRR_X$, where $X \in [N, P, C]$) to assess change in nutrient 
stock and biomass accumulation, nutrient flux, and trophic compartment productivity in 
different consumer movement scenarios. Our reference for calculating the 
$LRR_X$ are the results for the control scenario 
([Control scenario: gradient-neutral consumer movement]), 
where environmental fertility is homogeneous between local ecosystems 
(i.e., _I~1~_ = _I~2~_ = 10). 

Mathematically, the ratio's formula is:

$\displaystyle LRR_X = log_{10} \biggl(\frac{X_{i, I_1 \gtrless I_2}}{X_{i, I_1 = I_2}}\biggr)$

where $X \in [N, P, C]$ is the trophic compartment of interest, $i$ 
is either the local or meta-ecosystem, and $I_1 \gtrless I_2$ at the numerator 
represents the direction of fertility gradient in the **experimental** scenario of 
interest. At the denominator, $I_1 = I_2$ represents the equal fertility 
conditions of the **control** scenario. Please, see the **Numerical Analyses**
section of the manuscript as well as **Appendix Figure D.1** for a primer
on how to interpret the _LRR_ graphs.

### All stable parameter sets

```{r set-ggplot-theme-default, echo=TRUE, tidy=TRUE}
# Here we create a custom ggplot2 theme to use in the graphs below
consmov_theme <- theme_pubr() + theme(legend.position = "bottom", 
                                      legend.text = element_text(size = 16), 
                                      legend.title = element_text(size = 17), 
                                      plot.title = element_text(size = 17),
                                      axis.title.x = element_text(size = 17, 
                                                                  face = "bold"),
                                      axis.text.x = element_text(size = 15),
                                      axis.text.y = element_text(size = 15),
                                      axis.title.y = element_text(size = 17, 
                                                                  face = "bold"),
                                      strip.text = element_text(size = 16))
# custom theme for ppt
ppt_theme <- theme_bw() + theme(
  aspect.ratio = 1,
  legend.position = "bottom", 
  legend.background = element_blank(), 
  text = element_text(color = "white", size = 15), 
  axis.text = element_text(color = "white"), 
  axis.line = element_line(color = "white"), 
  axis.ticks = element_line(color = "white"), 
  strip.background = element_blank(), 
  strip.text = element_text(color = "white"), 
  panel.border = element_rect(fill = NA, color = "white"), 
  panel.background = element_blank(),
  panel.grid = element_blank(),
  plot.background = element_blank()
  )

# set width and height for 16:9 graphs
width <- 10
height <- (9/16)*width
```

We are working with the `PRED`, `PREDI2`, and `PREDI1` datasets we produced 
above (sections [Control scenario: gradient-neutral consumer movement] and 
[Experimental scenarios: along- and against-gradient consumer movement]).

First, we will check whether there is overlap among the equilibria that are 
either unstable or without biological meaning across `PRED`, `PREDI2`, and 
`PREDI1`. Then, we will join them into a new object, `EnvFert_res`. 

```{r envfert-rawdata-df, echo=TRUE,tidy=TRUE}
PREDusns <- filter(PRED, biosense == "no" | stable == "unstable")

PREDI2usns <- filter(PREDI2, biosense == "no" | stable == "unstable")

PREDI1usns <- filter(PREDI1, biosense == "no" | stable == "unstable")

summary(PREDusns[["TIME"]] %in% PREDI1usns[["TIME"]])

summary(PREDusns[["TIME"]] %in% PREDI2usns[["TIME"]])

EnvFert_res <- bind_rows("Equal" = PRED, 
                         "Along" = PREDI2, 
                         "Against" = PREDI1, 
                         .id = "Fertility") %>% 
  select(., biosense, Fertility:I2, N1:C2, Ntot:Ctot, FLUX_P1:FLUX_C2, 
         FLUX_Ptot:FLUX_Ctot, PROD_P1:PROD_Ctot, u1:e2)
```

There is no overlap among the three datasets in terms of equilibria that are 
unstable and lack biological meaning. This is something that will need 
accounting for later on when we work with the _LRR_. For now, we can remove all 
equilibria that are either unstable or do not have biological sense as we are 
going to create a figure using the raw data. 

<aside>
Note that `EnvFert_respos` has the same number of 
rows as `bmDistr` created in [Changes to biomass distribution
in local and meta-ecosystem].
</aside>

```{r envfert-biosense, echo=TRUE, tidy=TRUE}
EnvFert_respos <- filter(EnvFert_res, biosense == "yes")
```

#### Untransformed results

We now transform `EnvFert_respos` to a long-format dataframe and add two 
categorical variables: `Function` and `Scale`. `Function` tells us which 
ecosystem function is measured. `Scale` shows instead whether the function 
is being measured at the local or meta-ecosystem scale.

```{r envfert-rawdata-pivoting, echo=TRUE,tidy=TRUE}
EnvFert_long <- select(EnvFert_respos, !u1:e2) %>% 
  pivot_longer(., cols = N1:PROD_Ctot,
               names_to = "EcoFunction", 
               values_to = "Value") %>% 
  dplyr::mutate(., Function = if_else(EcoFunction == "N1" | 
                                        EcoFunction == "N2" | 
                                        EcoFunction == "P1" | 
                                        EcoFunction == "P2" | 
                                        EcoFunction == "C1" | 
                                        EcoFunction == "C2" | 
                                        EcoFunction == "Ntot" | 
                                        EcoFunction == "Ptot" | 
                                        EcoFunction == "Ctot", 
                                      "Stock", 
                                      if_else(EcoFunction == "FLUX_P1" | 
                                                EcoFunction == "FLUX_P2" | 
                                                EcoFunction == "FLUX_C1" | 
                                                EcoFunction == "FLUX_C2" | 
                                                EcoFunction == "FLUX_Ptot" | 
                                                EcoFunction == "FLUX_Ctot", 
                                              "Nutrient Flux", 
                                              "Trophic Productivity"))) %>% 
  dplyr::mutate(., Scale = if_else(EcoFunction == "N1" | 
                                     EcoFunction == "P1" | 
                                     EcoFunction == "C1" | 
                                     EcoFunction == "FLUX_P1" | 
                                     EcoFunction == "FLUX_C1" | 
                                     EcoFunction == "PROD_P1" | 
                                     EcoFunction == "PROD_C1", 
                                   "Ecosystem 1", 
                                   if_else(EcoFunction == "N2" | 
                                             EcoFunction == "P2" | 
                                             EcoFunction == "C2" | 
                                             EcoFunction == "FLUX_P2" | 
                                             EcoFunction == "FLUX_C2" | 
                                             EcoFunction == "PROD_P2" | 
                                             EcoFunction == "PROD_C2", 
                                           "Ecosystem 2", 
                                           "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), 
                Function = factor(Function), 
                Scale = factor(Scale), 
                EcoFunction = factor(EcoFunction))

head(EnvFert_long)
```

Now that we have a dataset ready for plotting, we produce the graphs. The next
code chunk produces **Figure D.2** in the Supplementary Materials. Note that we 
show the code, but not the figure itself as it is presented in the 
Supplementary Materials.

```{r envfert-rawdata-fig, echo=TRUE, tidy=TRUE, fig.show='hide'}
StockSumm <- EnvFert_long %>% 
  filter(., Function == "Stock") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            Nutrients = "N1", 
                                            Nutrients = "N2", 
                                            Nutrients = "Ntot", 
                                            "Primary\n Producers" = "P1", 
                                            "Primary\n Producers" = "P2", 
                                            "Primary\n Producers" = "Ptot", 
                                            Consumers = "C1", 
                                            Consumers = "C2", 
                                            Consumers = "Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Nutrients", 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Equal", 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 10, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) +
  scale_color_highcontrast(reverse = F, name = "Consumer movement", 
                           labels = c("Gradient-neutral", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Stock and Biomass") +
  ylab(" ") +
  xlab(" ") +
  coord_cartesian(ylim = c(0, 75)) 

FluxSumm <- EnvFert_long %>% 
  filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            "Primary\n Producers" = "FLUX_P1", 
                                            "Primary\n Producers" = "FLUX_P2", 
                                            "Primary\n Producers" = "FLUX_Ptot", 
                                            Consumers = "FLUX_C1", 
                                            Consumers = "FLUX_C2", 
                                            Consumers = "FLUX_Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility,
                                           "Equal", 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) + 
  scale_color_highcontrast(reverse = F, name = "Consumer movement", 
                           labels = c("Gradient-neutral", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Flux") +
  ylab(" ") +
  xlab(" ") +
  coord_cartesian(ylim = c(0, 350))

ProdSumm <- EnvFert_long %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            "Primary\n Producers" = "PROD_P1", 
                                            "Primary\n Producers" = "PROD_P2", 
                                            "Primary\n Producers" = "PROD_Ptot", 
                                            Consumers = "PROD_C1", 
                                            Consumers = "PROD_C2", 
                                            Consumers = "PROD_Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Primary\n Producers",
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Equal", 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) + 
  scale_color_highcontrast(reverse = F, name = "Consumer movement", 
                          labels = c("Gradient-neutral", 
                                     "Along-gradient", 
                                     "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Trophic Compartment Productivity") +
  ylab(" ") +
  xlab("Trophic compartment") +
  coord_cartesian(ylim = c(0, 500)) 

FuncAll <- StockSumm + FluxSumm + ProdSumm + 
  plot_layout(ncol = 1, nrow = 3, guides = "collect") + 
  plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") & 
  consmov_theme

FuncAll

#ggsave(FuncAll, filename = "../Results/FunctionSummary_10kN.pdf", device = "pdf", dpi = 300, width = 11, height = 10)
```

```{r median-param-values-all, eval=FALSE, include=FALSE}
EnvFert_respos %>% 
  select(., Fertility, u1:e2) %>% 
  ungroup() %>% 
  group_by(., Fertility) %>% 
  pivot_longer(., 
               cols = -Fertility, 
               names_to = "Parameter", 
               values_to = "value") %>% 
  mutate(., Parameter = as_factor(Parameter)) %>% 
  ungroup() %>% 
  group_by(., Fertility, Parameter) %>% 
  summarise(., 
            across(.cols = value, 
                   .fns = list(mean = mean, sd = sd)), 
            .groups = "keep") %>% 
  pivot_wider(., 
              names_from = "Fertility", 
              values_from = c("value_mean", "value_sd")) %>% 
  gt(rowname_col = "Parameter", 
     groupname_col = "Fertility") %>% 
  fmt_number(., columns = 2:7, decimals = 2) %>% 
  tab_spanner(label = md("Equal"), 
              columns = c("value_mean_Equal", "value_sd_Equal")) %>% 
  tab_spanner(label = md("Along"), 
              columns = c("value_mean_Along", "value_sd_Along")) %>% 
  tab_spanner(label = md("Against"), 
              columns = c("value_mean_Against", "value_sd_Against")) %>% 
  cols_label(value_mean_Against = "mean", 
             value_sd_Against = "sd", 
             value_mean_Along = "mean", 
             value_sd_Along = "sd", 
             value_mean_Equal = "mean", 
             value_sd_Equal = "sd")
```

#### Log-transformed Response Ratio

Now, we produce **Figures 2, 3, and 4** from the main text. First, we are going 
to create new dataframes (`PREDI2rr` and `PREDI1rr1`) that contain only the 
response ratio values for nutrient stock and biomass accumulation, nutrient flux, 
and trophic compartment productivity of all state variables. These dataframes 
will also contain information about the fertility conditions under which we 
measure each ecosystem function. After calculating the response ratio, we will 
remove the unstable, biologically not meaningful equilibria from 
`PREDI1` and `PREDI2` before merging them in a new object, `EnvFertRR`. 

In calculating the _LRR_, the difference in the number of equilibria that are 
either unstable or lack biological meaning among `PRED`, `PREDI1`, and `PREDI2` 
matters. To account for this, let us first create two objects, `I1NsUsrm` and 
`I2NsUsrm` that contain the unstable, nonsensical equilibria that are found in 
`PRED` but are not included in either `PREDI1` and `PREDI2`. We are going to 
remove the ones in `PREDI1` and `PREDI2` making use of the columns `biosense` 
and `stable`. Conversely, we will use `I1NsUsrm` and `I2NsUsrm` to remove 
instance of the response ratio being calculated using a denominator that is 
from an unstable, nonsensical equilibrium.

```{r ns-us-removal-tools, echo=TRUE, tidy = TRUE}
I1NsUsrm <- subset(PREDusns, !(PREDusns$TIME %in% PREDI1usns$TIME))

I2NsUsrm <- subset(PREDusns, !(PREDusns$TIME %in% PREDI2usns$TIME))
```

Then, let's create two new objects, `PREDI2rr` and `PREDI1rr`, to store the 
response ratio values calculated by dividing ecosystem function values in 
`PREDI2` and `PREDI1` by those in `PRED`, respectively. We will then merge these
two objects in a single one called `EnvFertRR`, and calculate the $C{:}R$ biomass 
ratio.

```{r envfert-lrr-df, echo=TRUE,tidy=TRUE}
# need to keep raw data in the same df as the ratio to select the >0 cases 
# for state variables

PREDI2rr <- PREDI2 %>%  
  # we are going to batch-create new response ratio versions of each variable
  # we start with the "stock" group of variables
  dplyr::mutate(., N1rr = N1/PRED$N1, P1rr = P1/PRED$P1, C1rr = C1/PRED$C1, 
                N2rr = N2/PRED$N2, P2rr = P2/PRED$P2, C2rr = C2/PRED$C2, 
                Nrr = Ntot/PRED$Ntot, Prr = Ptot/PRED$Ptot, Crr = Ctot/PRED$Ctot) %>%
  # next, we work on the "flux" group of variables
  dplyr::mutate(., FLUX_P1rr = FLUX_P1/PRED$FLUX_P1, FLUX_C1rr = FLUX_C1/PRED$FLUX_C1, 
                FLUX_P2rr = FLUX_P2/PRED$FLUX_P2, FLUX_C2rr = FLUX_C2/PRED$FLUX_C2, 
                FLUX_Prr = FLUX_Ptot/PRED$FLUX_Ptot, FLUX_Crr = FLUX_Ctot/PRED$FLUX_Ctot) %>%
  # finally, we work on the "productivity" group of variables
  dplyr::mutate(., PROD_P1rr = PROD_P1/PRED$PROD_P1, PROD_C1rr = PROD_C1/PRED$PROD_C1, 
                PROD_P2rr = PROD_P2/PRED$PROD_P2, PROD_C2rr = PROD_C2/PRED$PROD_C2, 
                PROD_Prr = PROD_Ptot/PRED$PROD_Ptot, PROD_Crr = PROD_Ctot/PRED$PROD_Ctot) %>%
  # and now let's subset the dataframe to include the resp ratio columns
  dplyr::select(., TIME:I2, N1:Ctot, N1rr:PROD_Crr, biosense, stable, u1:e2) %>%
  dplyr::filter(., biosense == "yes" | stable == "yes") %>%
  dplyr::filter(., !(TIME %in% I2NsUsrm$TIME))

# repeat, but for PREDI1

PREDI1rr <- PREDI1 %>%  
  # we are going to batch-create new response ratio versions of each variable
  # we start with the "stock" group of variables
  dplyr::mutate(., N1rr = N1/PRED$N1, P1rr = P1/PRED$P1, C1rr = C1/PRED$C1, 
                N2rr = N2/PRED$N2, P2rr = P2/PRED$P2, C2rr = C2/PRED$C2, 
                Nrr = Ntot/PRED$Ntot, Prr = Ptot/PRED$Ptot, Crr = Ctot/PRED$Ctot) %>%
  # next, we work on the "flux" group of variables
  dplyr::mutate(., FLUX_P1rr = FLUX_P1/PRED$FLUX_P1, FLUX_C1rr = FLUX_C1/PRED$FLUX_C1, 
                FLUX_P2rr = FLUX_P2/PRED$FLUX_P2, FLUX_C2rr = FLUX_C2/PRED$FLUX_C2, 
                FLUX_Prr = FLUX_Ptot/PRED$FLUX_Ptot, FLUX_Crr = FLUX_Ctot/PRED$FLUX_Ctot) %>%
  # finally, we work on the "productivity" group of variables
  dplyr::mutate(., PROD_P1rr = PROD_P1/PRED$PROD_P1, PROD_C1rr = PROD_C1/PRED$PROD_C1, 
                PROD_P2rr = PROD_P2/PRED$PROD_P2, PROD_C2rr = PROD_C2/PRED$PROD_C2, 
                PROD_Prr = PROD_Ptot/PRED$PROD_Ptot, PROD_Crr = PROD_Ctot/PRED$PROD_Ctot) %>%
  # and now let's subset the dataframe to include only the resp ratio columns
  dplyr::select(., TIME:I2, N1:Ctot, N1rr:PROD_Crr, biosense, stable, u1:e2) %>%
  dplyr::filter(., biosense == "yes" | stable == "yes") %>%
  dplyr::filter(., !(TIME %in% I1NsUsrm$TIME))

EnvFertRR <- bind_rows("Along" = PREDI2rr, 
                       "Against" = PREDI1rr, 
                       .id = "Fertility") %>% 
  dplyr::select(., Fertility, 
                biosense, 
                stable, 
                TIME:I2, 
                N1rr:PROD_Crr, 
                N1:Ctot, u1:e2) %>% 
  dplyr::mutate(., 
                CR_Eco1 = C1/P1, 
                CR_Eco2 = C2/P2, 
                CR_MetaEco = Ctot/Ptot 
                ) 
# now build the graph, first by pivoting to longer format, then graphing
```

Note that object `EnvFertRR` contains `r prettyNum(nrow(EnvFertRR), big.mark = " ")` and not 20
000 as would be expected from merging `PREDI1` and `PREDI2`, because of the two 
rounds of removal of unstable equilibria after said merge. The first round
removes those unstable, biologically not meaningful equilibria contained in 
`PREDI1` and `PREDI2`, the second uses objects `I1NsUsrm` and `I2NsUsrm` to 
remove the ones that are contained in `PRED` but do not overlap with those in 
`PREDI1` or `PREDI2`.

Now, we build the graphs. First, pivot the `EnvFertRR` dataframe from 
wide to long format.

```{r envfert-lrr-wrangling, echo=TRUE,tidy=TRUE}
EnvFertRR_long <- select(EnvFertRR, !(N1:e2)) %>% 
  pivot_longer(., 
               cols = N1rr:PROD_Crr, 
               names_to = "Compartment",
               values_to = "Ratio") %>% 
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1rr" | 
                                        Compartment == "FLUX_P2rr" | 
                                        Compartment == "FLUX_C1rr" | 
                                        Compartment == "FLUX_C2rr" | 
                                        Compartment == "FLUX_Prr" | 
                                        Compartment == "FLUX_Crr", 
                                      "Nutrient Flux", 
                                      if_else(Compartment == "PROD_P1rr" | 
                                                Compartment == "PROD_C1rr" | 
                                                Compartment == "PROD_P2rr" | 
                                                Compartment == "PROD_C2rr" | 
                                                Compartment == "PROD_Prr" | 
                                                Compartment == "PROD_Crr", 
                                              "Trophic Productivity", 
                                              "Stock"))) %>% 
  dplyr::mutate(., Scale = if_else(Compartment == "N1rr" | 
                                     Compartment == "P1rr" | 
                                     Compartment == "C1rr" | 
                                     Compartment == "FLUX_P1rr" | 
                                     Compartment == "FLUX_C1rr" | 
                                     Compartment == "PROD_P1rr" | 
                                     Compartment == "PROD_C1rr", 
                                   "Ecosystem 1", 
                                   if_else(Compartment == "N2rr" | 
                                             Compartment == "P2rr" | 
                                             Compartment == "C2rr" | 
                                             Compartment == "FLUX_P2rr" | 
                                             Compartment == "FLUX_C2rr" | 
                                             Compartment == "PROD_P2rr" | 
                                             Compartment == "PROD_C2rr", 
                                           "Ecosystem 2", 
                                           "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), 
                Function = factor(Function), 
                Scale = factor(Scale), 
                Compartment = factor(Compartment)) %>%
  dplyr::mutate(., biosense = fct_drop(biosense), 
                stable = fct_drop(stable))
```

In the following code chunks, we subset and then plot each ecosystem function 
individually against the _LRR_ to create **Figure 2, 3, and 4** in the main 
text. Note, again, that here we show only the code used to generate the figures 
but not the figures themselves as these can be found in the main text.

The following code chunk produces **Figure 2**, showing changes in nutrient 
stocks and biomass accumulation among experimental and control scenarios.

```{r envfert-lrr-stocks, echo=TRUE,tidy=TRUE, fig.show='hide'}
ptHCsubset <- c("#DDAA33", "#BB5566")
ptHCsubset_fill <- c("#f8eed6", "#f1dde0")

EFstockLRR <- EnvFertRR_long %>% 
  filter(., Function == "Stock") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, 
                                            Nutrients = "N1rr", 
                                            Nutrients = "N2rr", 
                                            Nutrients = "Nrr", 
                                            "Primary\n Producers" = "P1rr", 
                                            "Primary\n Producers" = "P2rr", 
                                            "Primary\n Producers" = "Prr", 
                                            Consumers = "C1rr", 
                                            Consumers = "C2rr", 
                                            Consumers = "Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, 
                                             "Nutrients", 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Along", "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) + 
  scale_color_manual(values = ptHCsubset, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Stock and Biomass") +
  ylab("LRR") +
  xlab("Trophic compartment") +
  consmov_theme

#ggsave(EFstockLRR, filename = "../Results/Stock_LRR_10kN.pdf", device = "pdf", dpi = 300, width = 10, height = 6)
```

The following code chunk produces **Figure 3**, which shows changes to nutrient 
flux among experimental and control scenarios.

```{r envfert-lrr-flux, echo=TRUE, tidy=TRUE, fig.show='hide'}
EFfluxLRR <- EnvFertRR_long %>% filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Primary\n Producers" = "FLUX_P1rr", "Primary\n Producers" = "FLUX_P2rr", "Primary\n Producers" = "FLUX_Prr", Consumers = "FLUX_C1rr", Consumers = "FLUX_C2rr", Consumers = "FLUX_Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Primary\n Producers", "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Along", "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) + 
  scale_color_manual(values = ptHCsubset, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Flux") +
  ylab("LRR") +
  xlab("Trophic compartment") +
  consmov_theme

#ggsave(EFfluxLRR, filename = "../Results/Flux_LRR_10kN.pdf", device = "pdf", dpi = 300, width = 10, height = 6)
```

And, finally, here we produce **Figure 4**, that shows change in the trophic
compartment productivity among experimental and control scenarios.

```{r envfert-lrr-prod, echo=TRUE,tidy=TRUE, fig.show='hide'}
EFprodLRR <- EnvFertRR_long %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Primary\n Producers" = "PROD_P1rr", "Primary\n Producers" = "PROD_P2rr", "Primary\n Producers" = "PROD_Prr", Consumers = "PROD_C1rr", Consumers = "PROD_C2rr", Consumers = "PROD_Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Primary\n Producers", "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Along", "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) + 
  scale_color_manual(values = ptHCsubset, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Trophic Compartment Productivity") +
  ylab("LRR") +
  xlab("Trophic compartment") + 
  consmov_theme

#ggsave(EFprodLRR, filename = "../Results/Production_LRR_10kN.pdf", device = "pdf", dpi = 300, width = 10, height = 6)
```

```{r envfert-lrr-patchwork, eval=FALSE, include=FALSE}
EFallLRR <- EFstockLRR + EFfluxLRR + EFprodLRR + 
  plot_layout(ncol = 1, nrow = 3, guides = "collect") + 
  plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") &
  consmov_theme

EFallLRR

#ggsave(EFallLRR, filename = "../Results/FunctionSummary_LRR_10kN.pdf", device = "pdf", dpi = 300, width = 10, height = 10)
```

In the two sections below, we investigate if our results are robust to changes 
in biomass distribution within the system caused by moving consumers and produce
**Figures D.3 to D.7** in the Supplementary Materials.

### Consumer movement in bottom-heavy systems

Here, we focus on those parameter sets that produce $C{:}R < 1$. That is, on
those parameter sets that produce classic biomass distributions [@McCauley2018].

As before, we begin with graphs for the untransformed data and then proceed to 
the _LRR_ graphs.

#### Untransformed parameter sets

First, using the object `EnvFert_CRbelow10` created above that exclude all $C{:}R$
values above 10, we further exclude all $C{:}R$ values above 1 and create a new
object, `EnvFert_CRbelow1`.

```{r filter-cr-below-1, echo=TRUE,tidy=TRUE}
EnvFert_CRbelow1 <- dplyr::mutate(EnvFert_respos,
                         CR_Eco1 = C1/P1, 
                         CR_Eco2 = C2/P2, 
                         CR_MetaEco = Ctot/Ptot
                         ) %>%
  filter(., CR_Eco1 <= 1 & CR_Eco2 <= 1 & CR_MetaEco <= 1)
```

Now, we lengthen this new dataset for plotting with `ggplot2`. 

```{r envfert-cr-below-1-pivot, echo=TRUE,tidy=TRUE}
EnvFert_CRbelow1_long <- select(EnvFert_CRbelow1, !u1:e2) %>%
  pivot_longer(., cols = N1:CR_MetaEco, 
               names_to = "EcoFunction", 
               values_to = "Value") %>% 
  dplyr::mutate(., Function = if_else(EcoFunction == "N1" | 
                                        EcoFunction == "N2" | 
                                        EcoFunction == "P1" | 
                                        EcoFunction == "P2" | 
                                        EcoFunction == "C1" | 
                                        EcoFunction == "C2" | 
                                        EcoFunction == "Ntot" | 
                                        EcoFunction == "Ptot" | 
                                        EcoFunction == "Ctot", 
                                      "Stock", 
                                      if_else(EcoFunction == "FLUX_P1" | 
                                                EcoFunction == "FLUX_P2" | 
                                                EcoFunction == "FLUX_C1" | 
                                                EcoFunction == "FLUX_C2" | 
                                                EcoFunction == "FLUX_Ptot" | 
                                                EcoFunction == "FLUX_Ctot", 
                                              "Nutrient Flux", 
                                              ifelse(EcoFunction == "CR_Eco1" | 
                                                      EcoFunction == "CR_Eco2" |
                                                      EcoFunction == "CR_MetaEco",
                                                    "C:R",
                                                    "Trophic Productivity")))) %>% 
  dplyr::mutate(., Scale = if_else(EcoFunction == "N1" | 
                                     EcoFunction == "P1" | 
                                     EcoFunction == "C1" | 
                                     EcoFunction == "FLUX_P1" | 
                                     EcoFunction == "FLUX_C1" | 
                                     EcoFunction == "PROD_P1" | 
                                     EcoFunction == "PROD_C1" |
                                     EcoFunction == "CR_Eco1", 
                                   "Ecosystem 1", 
                                   if_else(EcoFunction == "N2" | 
                                             EcoFunction == "P2" | 
                                             EcoFunction == "C2" | 
                                             EcoFunction == "FLUX_P2" | 
                                             EcoFunction == "FLUX_C2" | 
                                             EcoFunction == "PROD_P2" | 
                                             EcoFunction == "PROD_C2" |
                                             EcoFunction == "CR_Eco2", 
                                           "Ecosystem 2", 
                                           "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), 
                Function = factor(Function), 
                Scale = factor(Scale), 
                EcoFunction = factor(EcoFunction))

head(EnvFert_CRbelow1_long)
```

And now we use the newly created dataframe `EnvFert_CRbelow1_long` to produce a 
figure analogous to **Appendix Figure D.2**. Unlike previous figures, the
following one does not appear in the **Supplementary Material** and is thus shown here.

```{r envfert-cr-below-1-fig, echo=TRUE, tidy=TRUE, fig.width=10, fig.height=9, fig.cap="Change in nutrient stock and biomass (a), nutrient flux (b), and trophic compartment productivity (c) when consumers move in a heterogeneous meta-ecosystem, considering only parameters sets for which _C:R_ < 1 (unstransformed data). Notably, we observe a clear quantative difference in the nutrient stock at the meta-ecosystem scale, compared with Figure A.2. However, this does not appear to cause a qualitative change in the patterns of local and meta-ecosystem functioning observe, as noted in Figure A.3. All specifications as in Figure A.2."}
StockSummCRbelow1 <- EnvFert_CRbelow1_long %>% 
  filter(., Function == "Stock") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            Nutrients = "N1", 
                                            Nutrients = "N2", 
                                            Nutrients = "Ntot", 
                                            "Primary\n Producers" = "P1", 
                                            "Primary\n Producers" = "P2", 
                                            "Primary\n Producers" = "Ptot", 
                                            Consumers = "C1", 
                                            Consumers = "C2", 
                                            Consumers = "Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Nutrients", 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Equal", "Along", "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 10, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) +
  scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Stock and Biomass") +
  ylab(" ") +
  xlab(" ") +
  coord_cartesian(ylim = c(0, 75)) 

FluxSummCRbelow1 <- EnvFert_CRbelow1_long %>% 
  filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            "Primary\n Producers" = "FLUX_P1", 
                                            "Primary\n Producers" = "FLUX_P2", 
                                            "Primary\n Producers" = "FLUX_Ptot", 
                                            Consumers = "FLUX_C1", 
                                            Consumers = "FLUX_C2", 
                                            Consumers = "FLUX_Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Equal", 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) + 
  scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Flux") +
  ylab(" ") +
  xlab(" ") +
  coord_cartesian(ylim = c(0, 350))

ProdSummCRbelow1 <- EnvFert_CRbelow1_long %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            "Primary\n Producers" = "PROD_P1", 
                                            "Primary\n Producers" = "PROD_P2", 
                                            "Primary\n Producers" = "PROD_Ptot", 
                                            Consumers = "PROD_C1", 
                                            Consumers = "PROD_C2", 
                                            Consumers = "PROD_Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Equal", 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) + 
  scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Trophic Compartment Productivity") +
  ylab(" ") +
  xlab("Trophic Compartment") +
  coord_cartesian(ylim = c(0, 500)) 

FuncAllCRbelow1 <- StockSummCRbelow1 + FluxSummCRbelow1 + ProdSummCRbelow1 +
  plot_layout(ncol = 1, nrow = 3, guides = "collect") + 
  plot_annotation( tag_levels = "a", tag_prefix = "(", tag_suffix = ")") &
  consmov_theme

FuncAllCRbelow1
```

While the quantitative changes are more noticeable here, again in the distance 
between the upper and lower hinges of the boxes, there does not seem to be a 
marked change in the qualitative pattern observed in our results for any of the
ecosystem functions of interest. Let's proceed to work on the _LRR_ values. 

#### Log-transformed Response Ratio

As we just did for the untransformed data, let's use the previously created
object `EnvFertRR` to select the parameter sets producing $C{:}R < 1$
and store them in a new object, `EnvFertRR_CRbelow1`. 

```{r filter-lrr-cr-below-1, echo=TRUE,tidy=TRUE}
EnvFertRR_CRbelow1 <- dplyr::filter(EnvFertRR, 
                                    CR_Eco1 <= 1 & 
                                      CR_Eco2 <= 1 & 
                                      CR_MetaEco <= 1)
```

We now lengthen this newly created object.

```{r lrr-cr-below-1-pivot, echo=TRUE, tidy=TRUE}
EnvFertRR_CRbelow1_long <- select(EnvFertRR_CRbelow1, !(N1:e2)) %>% 
  pivot_longer(., 
               cols = N1rr:CR_MetaEco, 
               names_to = "Compartment",
               values_to = "Ratio") %>% 
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1rr" | 
                                        Compartment == "FLUX_P2rr" | 
                                        Compartment == "FLUX_C1rr" | 
                                        Compartment == "FLUX_C2rr" | 
                                        Compartment == "FLUX_Prr" | 
                                        Compartment == "FLUX_Crr", 
                                      "Nutrient Flux", 
                                      if_else(Compartment == "PROD_P1rr" | 
                                                Compartment == "PROD_C1rr" | 
                                                Compartment == "PROD_P2rr" | 
                                                Compartment == "PROD_C2rr" | 
                                                Compartment == "PROD_Prr" | 
                                                Compartment == "PROD_Crr", 
                                              "Trophic Productivity", 
                                              ifelse(Compartment == "CR_Eco1" | 
                                                      Compartment == "CR_Eco2" |
                                                      Compartment == "CR_MetaEco",
                                                    "C:R",
                                                    "Stock")))) %>% 
  dplyr::mutate(., Scale = if_else(Compartment == "N1rr" | 
                                     Compartment == "P1rr" | 
                                     Compartment == "C1rr" | 
                                     Compartment == "FLUX_P1rr" | 
                                     Compartment == "FLUX_C1rr" | 
                                     Compartment == "PROD_P1rr" | 
                                     Compartment == "PROD_C1rr" |
                                     Compartment == "CR_Eco1", 
                                   "Ecosystem 1", 
                                   if_else(Compartment == "N2rr" | 
                                             Compartment == "P2rr" | 
                                             Compartment == "C2rr" | 
                                             Compartment == "FLUX_P2rr" | 
                                             Compartment == "FLUX_C2rr" | 
                                             Compartment == "PROD_P2rr" | 
                                             Compartment == "PROD_C2rr" |
                                             Compartment == "CR_Eco2", 
                                           "Ecosystem 2", 
                                           "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), 
                Function = factor(Function), 
                Scale = factor(Scale), 
                Compartment = factor(Compartment)) %>%
  dplyr::mutate(., biosense = fct_drop(biosense), 
                stable = fct_drop(stable))
```

And finally we produce **Appendix Figure D.4**. Accordingly, we show the 
code here but not the figure itself.

```{r envfert-lrr-cr-below-1-fig, echo=TRUE,tidy=TRUE, fig.show='hide'}
# we make sure the y-axis of this figure has the same range of the "all data"
# graph above by extracting the limits of the y-axis from that graph and
# using them in this one
LRRstock_ymin <- layer_scales(EFstockLRR)$y$get_limits()[1]
LRRstock_ymax <- layer_scales(EFstockLRR)$y$get_limits()[2]

EFstockLRR_CRbelow1 <- EnvFertRR_CRbelow1_long %>% 
  filter(., Function == "Stock") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, 
                                            Nutrients = "N1rr", 
                                            Nutrients = "N2rr", 
                                            Nutrients = "Nrr", 
                                            "Primary\n Producers" = "P1rr", 
                                            "Primary\n Producers" = "P2rr", 
                                            "Primary\n Producers" = "Prr", 
                                            Consumers = "C1rr", 
                                            Consumers = "C2rr", 
                                            Consumers = "Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, 
                                             "Nutrients", 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), 
            fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) + 
  scale_color_manual(values = ptHCsubset, 
                     name = "Consumer movement", 
                     labels = c("Along-gradient", "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Stock and Biomass") +
  ylab("LRR") +
  xlab(" ") +
  coord_cartesian(ylim = c(LRRstock_ymin, LRRstock_ymax))

# again, we grab the y-axis limits from the relevant all-data graph
LRRflux_ymin <- layer_scales(EFfluxLRR)$y$get_limits()[1]
LRRflux_ymax <- layer_scales(EFfluxLRR)$y$get_limits()[2]

EFfluxLRR_CRbelow1 <- EnvFertRR_CRbelow1_long %>% 
  filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, 
                                            "Primary\n Producers" = "FLUX_P1rr", 
                                            "Primary\n Producers" = "FLUX_P2rr", 
                                            "Primary\n Producers" = "FLUX_Prr", 
                                            Consumers = "FLUX_C1rr", 
                                            Consumers = "FLUX_C2rr", 
                                            Consumers = "FLUX_Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), 
            fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) + 
  scale_color_manual(values = ptHCsubset, 
                     name = "Consumer movement", 
                     labels = c("Along-gradient", 
                                "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Flux") +
  ylab("LRR") +
  xlab(" ") +
  coord_cartesian(ylim = c(LRRflux_ymin, LRRflux_ymax))

# again, we grab the y-axis limits from the relevant all-data graph
LRRprod_ymin <- layer_scales(EFprodLRR)$y$get_limits()[1]
LRRprod_ymax <- layer_scales(EFprodLRR)$y$get_limits()[2]

EFprodLRR_CRbelow1 <- EnvFertRR_CRbelow1_long %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, 
                                            "Primary\n Producers" = "PROD_P1rr", 
                                            "Primary\n Producers" = "PROD_P2rr", 
                                            "Primary\n Producers" = "PROD_Prr", 
                                            Consumers = "PROD_C1rr", 
                                            Consumers = "PROD_C2rr", 
                                            Consumers = "PROD_Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), 
            fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) +
  scale_color_manual(values = ptHCsubset, 
                    name = "Consumer movement", 
                    labels = c("Along-gradient", 
                               "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Trophic Compartment Productivity") +
  ylab("LRR") +
  xlab("Trophic compartment") + 
  coord_cartesian(ylim = c(LRRprod_ymin, LRRprod_ymax))

EFallLRR_CRbelow1 <- EFstockLRR_CRbelow1 + EFfluxLRR_CRbelow1 + EFprodLRR_CRbelow1 + 
  plot_layout(ncol = 1, nrow = 3, guides = "collect") + 
  plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") &
  consmov_theme

EFallLRR_CRbelow1

#ggsave(EFallLRR_CRbelow1, filename = "../Results/FunctionSummary_LRR_CRbelow1.pdf", device = "pdf", dpi = 300, width = 10, height = 10)
```

And here, we show median parameter values for the subset of results where 
$C{:}R < 1$.

```{r median-param-values-cr-below-1-lrr, echo=TRUE, tidy=TRUE}
# table of median parameter values
# EnvFertRR_CRbelow1 %>% select(., Fertility, u1:e2) %>% ungroup() %>% group_by(., Fertility) %>% pivot_longer(., cols = -Fertility, names_to = "Parameter", values_to = "value") %>% mutate(., Parameter = as_factor(Parameter)) %>% ungroup() %>% group_by(., Fertility, Parameter) %>% summarise(., across(.cols = value, .fns = list(mean = mean, sd = sd)), .groups = "keep") %>% pivot_wider(., names_from = "Fertility", values_from = c("value_mean", "value_sd"))%>% gt(rowname_col = "Parameter", groupname_col = "Fertility") %>% fmt_number(., columns = 2:5, decimals = 2) %>% tab_spanner(label = md("Along"), columns = c("value_mean_Along", "value_sd_Along")) %>% tab_spanner(label = md("Against"), columns = c("value_mean_Against", "value_sd_Against")) %>% cols_label(value_mean_Against = "mean", value_sd_Against = "sd", value_mean_Along = "mean", value_sd_Along = "sd") 

# %>% gtsave(., filename = "../Results/MeanParam_LRR_CRbelow1.rtf")

EnvFertRR_CRbelow1 %>% 
  select(., Fertility, u1:e2) %>% 
  ungroup() %>% 
  group_by(., Fertility) %>% 
  pivot_longer(., cols = -Fertility, 
               names_to = "Parameter", 
               values_to = "value") %>% 
  mutate(., Parameter = as_factor(Parameter)) %>% 
  ggplot(., aes(x = Parameter, y = value)) +
  geom_boxjitter(aes(fill = Parameter, 
                     col = Parameter), 
                 jitter.fill = NULL, alpha = 0.1) + 
  scale_color_manual(values=met.brewer("Signac", 13)) + 
  scale_fill_manual(values=met.brewer("Signac", 13)) + 
  theme_pubr(legend = "none") + 
  ylab("Mean") + 
  facet_grid(.~Fertility, 
             labeller = as_labeller(c(`Against` = "Against-gradient Consumer movement", 
                                      `Along` = "Along-gradient Consumer movement")))  

# ggsave(filename = "../Results/MeanParam_LRR_CRbelow1.pdf", dpi = 300, device = "pdf")
```

### Consumer movement in top-heavy systems

Here we reproduce **Figures 2**, **3**, and **4** from the main text and 
**Appendix Figure D.2** using only parameter sets that produce 
$C{:}R \in (1,10)$. We exclude $C{:}R > 10$ values, as these are likely 
extremely rare in real-world ecosystems. We begin, as usual, with the 
untransformed dataframe.

#### Untransformed parameter sets

First, let's exclude from `EnvFert_respos` all the parameter sets producing
$C{:}R > 10$ and those producing $C{:}R < 1$.

```{r filter-cr-above-1, echo=TRUE,tidy=TRUE}
EnvFert_CRabove1 <- dplyr::mutate(EnvFert_respos,
                         CR_Eco1 = C1/P1,
                         CR_Eco2 = C2/P2, 
                         CR_MetaEco = Ctot/Ptot
                         ) %>%
  dplyr::filter(., CR_Eco1 <= 10 & CR_Eco2 <= 10 & CR_MetaEco <= 10) %>% 
  dplyr::filter(., CR_Eco1 > 1 & CR_Eco2 > 1 & CR_MetaEco > 1)
```

Now we lengthen the dataset `EnvFert_CRabove1` created in the code chunk above
for plotting.

```{r envfert-cr-above-1-pivot, echo=TRUE,tidy=TRUE}
EnvFert_CRabove1_long <- select(EnvFert_CRabove1, !u1:e2) %>% 
  pivot_longer(., 
               cols = N1:CR_MetaEco, 
               names_to = "EcoFunction", 
               values_to = "Value") %>% 
  dplyr::mutate(., Function = if_else(EcoFunction == "N1" | 
                                        EcoFunction == "N2" | 
                                        EcoFunction == "P1" | 
                                        EcoFunction == "P2" | 
                                        EcoFunction == "C1" | 
                                        EcoFunction == "C2" | 
                                        EcoFunction == "Ntot" | 
                                        EcoFunction == "Ptot" | 
                                        EcoFunction == "Ctot", 
                                      "Stock", 
                                      if_else(EcoFunction == "FLUX_P1" | 
                                                EcoFunction == "FLUX_P2" | 
                                                EcoFunction == "FLUX_C1" | 
                                                EcoFunction == "FLUX_C2" | 
                                                EcoFunction == "FLUX_Ptot" | 
                                                EcoFunction == "FLUX_Ctot", 
                                              "Nutrient Flux", 
                                              ifelse(EcoFunction == "CR_Eco1" | 
                                                      EcoFunction == "CR_Eco2" |
                                                      EcoFunction == "CR_MetaEco",
                                                    "C:R",
                                                    "Trophic Productivity")))) %>% 
  dplyr::mutate(., Scale = if_else(EcoFunction == "N1" | 
                                     EcoFunction == "P1" | 
                                     EcoFunction == "C1" | 
                                     EcoFunction == "FLUX_P1" | 
                                     EcoFunction == "FLUX_C1" | 
                                     EcoFunction == "PROD_P1" | 
                                     EcoFunction == "PROD_C1" |
                                     EcoFunction == "CR_Eco1", 
                                   "Ecosystem 1", 
                                   if_else(EcoFunction == "N2" | 
                                             EcoFunction == "P2" | 
                                             EcoFunction == "C2" | 
                                             EcoFunction == "FLUX_P2" | 
                                             EcoFunction == "FLUX_C2" | 
                                             EcoFunction == "PROD_P2" | 
                                             EcoFunction == "PROD_C2" |
                                             EcoFunction == "CR_Eco2", 
                                           "Ecosystem 2", 
                                           "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), 
                Function = factor(Function), 
                Scale = factor(Scale), 
                EcoFunction = factor(EcoFunction))

head(EnvFert_CRabove1_long)
```

And, finally, we reproduce **Appendix Figure D.2**. Note that, again, this
figure does not appear in the **Supplementary Materials** and is thus shown here.

```{r envfert-cr-above-1-fig, echo=TRUE, tidy=TRUE, fig.width=10, fig.height=9, fig.cap="Change in nutrient stock and biomass (a), nutrient flux (b), and trophic compartment productivity (c) when consumers move in a heterogeneous meta-ecosystem, considering only parameter sets for which _C:R_ > 1 and < 10 (unstransformed data). Here, biomass and nutrient stock results appear to more clearly point towards a trophic cascade at play at the meta-ecosystem scale, compared to Figure A.2. Patterns of nutrient flux and trophic compartment productivity appear qualitatively unchanged. All specifications as in Figure A.2."}
StockSummCRabove1 <- EnvFert_CRabove1_long %>% 
  filter(., Function == "Stock") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            Nutrients = "N1", 
                                            Nutrients = "N2", 
                                            Nutrients = "Ntot", 
                                            "Primary\n Producers" = "P1", 
                                            "Primary\n Producers" = "P2", 
                                            "Primary\n Producers" = "Ptot", 
                                            Consumers = "C1", 
                                            Consumers = "C2", 
                                            Consumers = "Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Nutrients", 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, "Equal", "Along", "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 10, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) +
  scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Stock and Biomass") +
  ylab(" ") +
  xlab(" ") +
  coord_cartesian(ylim = c(0, 75)) 

FluxSummCRabove1 <- EnvFert_CRabove1_long %>% 
  filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            "Primary\n Producers" = "FLUX_P1", 
                                            "Primary\n Producers" = "FLUX_P2", 
                                            "Primary\n Producers" = "FLUX_Ptot", 
                                            Consumers = "FLUX_C1", 
                                            Consumers = "FLUX_C2", 
                                            Consumers = "FLUX_Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Equal", 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) + 
  scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Flux") +
  ylab(" ") +
  xlab(" ") +
  coord_cartesian(ylim = c(0, 350))

ProdSummCRabove1 <- EnvFert_CRabove1_long %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., EcoFunction = fct_recode(EcoFunction, 
                                            "Primary\n Producers" = "PROD_P1", 
                                            "Primary\n Producers" = "PROD_P2", 
                                            "Primary\n Producers" = "PROD_Ptot", 
                                            Consumers = "PROD_C1", 
                                            Consumers = "PROD_C2", 
                                            Consumers = "PROD_Ctot")) %>%
  dplyr::mutate(., EcoFunction = fct_relevel(EcoFunction, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Equal", 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = EcoFunction, y = Value)) +
  geom_hline(yintercept = 50, linetype = "dashed", lwd = 0.25) + 
  geom_boxplot(aes(color = Fertility)) + 
  scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Trophic Compartment Productivity") +
  ylab(" ") +
  xlab("Trophic compartment") +
  coord_cartesian(ylim = c(0, 500)) 

FuncAllCRabove1 <- StockSummCRabove1 + FluxSummCRabove1 + ProdSummCRabove1 + 
  plot_layout(ncol = 1, nrow = 3, guides = "collect") + 
  plot_annotation( tag_levels = "a", tag_prefix = "(", tag_suffix = ")") & 
  consmov_theme

FuncAllCRabove1

#ggsave(FuncAllCRabove1, filename = "../Results/FunctionSummary_CRabove1.pdf", device = "pdf", dpi = 300, width = 10, height = 10)
```

Compared with **Appendix Figure D.2**, we see a clear change in the pattern
of biomass accumulation---consistent with the inverted, top-heavy biomass 
distribution expected when $C{:}R > 1$ [@McCauley2018].

#### Log-transformed Response Ratio

Here, we produce **Appendix Figure D.6**. We use only parameter sets that 
produce $C{:}R \in (1,10)$. First, we exclude all $C{:}R$ values below 1. 

```{r filter-lrr-cr-above-1, echo=TRUE,tidy=TRUE}
EnvFertRR_CRabove1 <- dplyr::filter(EnvFertRR, 
                                    CR_Eco1 <= 10 & 
                                      CR_Eco2 <= 10 & 
                                      CR_MetaEco <= 10) %>% 
  dplyr::filter(., CR_Eco1 > 1 & 
                  CR_Eco2 > 1 & 
                  CR_MetaEco > 1)
```

Then, we lengthen the dataset for plotting.

```{r lrr-cr-above-1-pivot, echo=TRUE, tidy=TRUE}
EnvFertRR_CRabove1_long <- select(EnvFertRR_CRabove1, !(N1:e2)) %>% 
  pivot_longer(., 
               cols = N1rr:CR_MetaEco, 
               names_to = "Compartment",
               values_to = "Ratio") %>% 
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1rr" | 
                                        Compartment == "FLUX_P2rr" | 
                                        Compartment == "FLUX_C1rr" | 
                                        Compartment == "FLUX_C2rr" | 
                                        Compartment == "FLUX_Prr" | 
                                        Compartment == "FLUX_Crr", 
                                      "Nutrient Flux", 
                                      if_else(Compartment == "PROD_P1rr" | 
                                                Compartment == "PROD_C1rr" | 
                                                Compartment == "PROD_P2rr" | 
                                                Compartment == "PROD_C2rr" | 
                                                Compartment == "PROD_Prr" | 
                                                Compartment == "PROD_Crr", 
                                              "Trophic Productivity", 
                                              ifelse(Compartment == "CR_Eco1" | 
                                                      Compartment == "CR_Eco2" |
                                                      Compartment == "CR_MetaEco",
                                                    "C:R",
                                                    "Stock")))) %>% 
  dplyr::mutate(., Scale = if_else(Compartment == "N1rr" | 
                                     Compartment == "P1rr" | 
                                     Compartment == "C1rr" | 
                                     Compartment == "FLUX_P1rr" | 
                                     Compartment == "FLUX_C1rr" | 
                                     Compartment == "PROD_P1rr" | 
                                     Compartment == "PROD_C1rr" |
                                     Compartment == "CR_Eco1", 
                                   "Ecosystem 1", 
                                   if_else(Compartment == "N2rr" | 
                                             Compartment == "P2rr" | 
                                             Compartment == "C2rr" | 
                                             Compartment == "FLUX_P2rr" | 
                                             Compartment == "FLUX_C2rr" | 
                                             Compartment == "PROD_P2rr" | 
                                             Compartment == "PROD_C2rr" |
                                             Compartment == "CR_Eco2", 
                                           "Ecosystem 2", 
                                           "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), 
                Function = factor(Function), 
                Scale = factor(Scale), 
                Compartment = factor(Compartment)) %>%
  dplyr::mutate(., biosense = fct_drop(biosense), 
                stable = fct_drop(stable))
```

And now we produce **Appendix Figure D.6**. Note that, as above, we do not 
show the figure itself here but only the code needed to produce it.

```{r envfert-lrr-cr-above-1-fig, echo=TRUE,tidy=TRUE, fig.show='hide'}
EFstockLRR_CRabove1 <- EnvFertRR_CRabove1_long %>% 
  filter(., Function == "Stock") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, 
                                            Nutrients = "N1rr", 
                                            Nutrients = "N2rr", 
                                            Nutrients = "Nrr", 
                                            "Primary\n Producers" = "P1rr", 
                                            "Primary\n Producers" = "P2rr", 
                                            "Primary\n Producers" = "Prr", 
                                            Consumers = "C1rr", 
                                            Consumers = "C2rr", 
                                            Consumers = "Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, 
                                             "Nutrients", 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), 
            fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) + 
  scale_color_manual(values = ptHCsubset, 
                     name = "Consumer movement", 
                     labels = c("Along-gradient", "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Stock and Biomass") +
  ylab("LRR") +
  xlab(" ") +
  coord_cartesian(ylim = c(LRRstock_ymin, LRRstock_ymax))

EFfluxLRR_CRabove1 <- EnvFertRR_CRabove1_long %>% 
  filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, 
                                            "Primary\n Producers" = "FLUX_P1rr", 
                                            "Primary\n Producers" = "FLUX_P2rr", 
                                            "Primary\n Producers" = "FLUX_Prr", 
                                            Consumers = "FLUX_C1rr", 
                                            Consumers = "FLUX_C2rr", 
                                            Consumers = "FLUX_Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), 
            fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) + 
  scale_color_manual(values = ptHCsubset, 
                     name = "Consumer movement", 
                     labels = c("Along-gradient", 
                                "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Nutrient Flux") +
  ylab("LRR") +
  xlab(" ") +
  coord_cartesian(ylim = c(LRRflux_ymin, LRRflux_ymax))

EFprodLRR_CRabove1 <- EnvFertRR_CRabove1_long %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, 
                                            "Primary\n Producers" = "PROD_P1rr", 
                                            "Primary\n Producers" = "PROD_P2rr", 
                                            "Primary\n Producers" = "PROD_Prr", 
                                            Consumers = "PROD_C1rr", 
                                            Consumers = "PROD_C2rr", 
                                            Consumers = "PROD_Crr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, 
                                             "Primary\n Producers", 
                                             "Consumers")) %>%
  dplyr::mutate(., Fertility = fct_relevel(Fertility, 
                                           "Along", 
                                           "Against")) %>%
  ggplot(., aes(x = Compartment, y = log10(Ratio))) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0), 
            fill = "gray95") +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "black") + 
  geom_boxplot(aes(color = Fertility, fill = Fertility)) + 
  scale_color_manual(values = ptHCsubset, 
                    name = "Consumer movement", 
                    labels = c("Along-gradient", 
                               "Against-gradient")) +
  scale_fill_manual(values = ptHCsubset_fill, name = "Consumer movement", labels = c("Along-gradient", "Against-gradient")) +
  facet_grid(.~Scale, scales = "free") +
  labs(title = "Trophic Compartment Productivity") +
  ylab("LRR") +
  xlab("Trophic compartment") + 
  coord_cartesian(ylim = c(LRRprod_ymin, LRRprod_ymax))

EFallLRR_CRabove1 <- EFstockLRR_CRabove1 + EFfluxLRR_CRabove1 + EFprodLRR_CRabove1 + 
  plot_layout(ncol = 1, nrow = 3, guides = "collect") + 
  plot_annotation(tag_levels = "a", tag_prefix = "(", tag_suffix = ")") &
  consmov_theme

#ggsave(EFallLRR_CRabove1, filename = "../Results/FunctionSummary_LRR_CRabove1.pdf", device = "pdf", dpi = 300, width = 10, height = 10)
```

As above, we now plot the median parameter values for these parameter sets.

```{r median-param-values-cr-above-1-lrr, echo=TRUE, tidy=TRUE}
# table of median parameter sets

EnvFertRR_CRabove1 %>% 
  select(., Fertility, u1:e2) %>% 
  ungroup() %>%
  group_by(., Fertility) %>% 
  pivot_longer(., cols = -Fertility, 
               names_to = "Parameter", 
               values_to = "value") %>% 
  mutate(., Parameter = as_factor(Parameter)) %>% 
  ggplot(., aes(x = Parameter, y = value)) + 
  geom_boxjitter(aes(fill = Parameter, col = Parameter), 
                 jitter.fill = NULL, alpha = 0.1) + 
  scale_color_manual(values=met.brewer("Signac", 13)) + 
  scale_fill_manual(values=met.brewer("Signac", 13)) + 
  theme_pubr(legend = "none") +
  ylab("Mean") + 
  facet_grid(.~Fertility, 
             labeller = as_labeller(c(`Against` = "Against-gradient Consumer movement", 
                                      `Along` = "Along-gradient Consumer movement")))  
 
# ggsave(filename = "../Results/MeanParam_LRR_CRabove1.pdf", dpi = 300, device = "pdf")
```

## Consumer Biomass in Dispersers' Pool

Finally, we can explore how much of the consumers' biomass remains in the 
dispersers' pool at equilibrium (Figure \@ref(fig:disp-pool-bp)) and how it 
varies over time as the simulation progress (**Appendix Figure D.8**; not 
shown here as it appears in the manuscript's appendices).

```{r disp-pool-bp, echo=TRUE, tidy=TRUE, fig.cap="Here we show in more details the accumulation of consumer biomass in the disperser's pool Q at equilibrium, in all three consumer movement scenarios. As shown above (Figures 1--4), consumer biomass in the dispersers' pool Q is negligible at equilibrium, regardless of the way consumers move in the meta-ecosystems."}
Qres <-  bind_rows("Equal" = PRED, 
                   "Along" = PREDI2, 
                   "Against" = PREDI1, 
                   .id = "Fertility") %>% 
    select(., biosense, Fertility, TIME, Q)

Qrespos <- filter(Qres, biosense == "yes")

dplyr::mutate(Qrespos, Fertility = fct_relevel(Fertility,
                                         "Equal", 
                                         "Along", 
                                         "Against")) %>% 
  ggplot(., aes(x = Fertility, y = Q, col = Fertility, group = Fertility)) + 
  geom_boxjitter(alpha = 0.25, outlier.intersect = TRUE, outlier.shape = 21, 
                 jitter.shape = 21, outlier.stroke = 2, jitter.stroke = 2) + 
  scale_color_highcontrast(reverse = F) + 
  ylab("Consumer biomass in Dispersers' Pool") + 
  xlab("Consumer movement") + 
  scale_x_discrete(labels = c("Equal" = "Gradient-neutral", 
                              "Along" = "Along-gradient", 
                              "Against" = "Against-gradient")) + 
  theme(legend.position = "none", 
        text = element_text(size = 14)) 
```

```{r disp-pool-scatterplot, echo=TRUE, tidy=TRUE, fig.show = 'hide', fig.cap="Complementing the figure above, here we show the change in consumer biomass in the dispersers' pool Q over time, for all three consumer movement scenarios. Regardless of the direction of the fertility gradient---hence, of the way consumers move in the meta-ecosystem---consumer biomass in the dispersers' pool appears negligible throughout the duration of the model simulations. In particular, the larger share of consumer biomass in the dispersers' pool appears to accumulate when consumers move along-gradient, whereas against-gradient movement leads to very little consumer biomass lingering in this pool. Note the different scales of the y-axis across the three panels."}
dplyr::mutate(Qrespos, Fertility = fct_relevel(Fertility,
                                         "Equal", 
                                         "Along", 
                                         "Against")) %>% 
  ggplot(., aes(x = TIME, y = Q, group = Fertility)) + 
  geom_point(aes(col = Fertility, alpha = Q), 
             shape = 21,show.legend = F, stroke = 2) + 
  geom_smooth(col = "white", method = "lm") + 
  scale_color_highcontrast(reverse = F) + 
  facet_wrap(.~Fertility, scales = "free", 
             labeller = as_labeller(c("Equal" = "Gradient-neutral\nConsumer movement", 
                                      "Along" = "Along-gradient\nConsumer movement", 
                                      "Against" = "Against-gradient\nConsumer movement"))) + 
  ylab("Consumer biomass in Dispersers' Pool") + 
  xlab("Time") + 
  theme(text = element_text(size = 14))

# ggsave(last_plot(), filename = "../Results/QBiomass_change.svg", device = "svg", dpi = 300, width = width, height = height)
```

## Summary tables---Ecosystem functions

Here, we produce summary tables for the results of the model's iterations, using
the _LRR_ and $C{:}R$ values we calculated to produce the summary plots above. 
For _LRR_, we report median values for each ecosystem function of interest in 
both local ecosystems and in the meta-ecosystem. 

For ease of interpretation, median $LRR < 0$ will be shown in shades 
of magenta based on how close they are to -1 and median $LRR > 0$ will be shown 
in shades of green based on their closeness to 1.

First, we produce dataframes to contain the median values, one for each of 
stock, nutrient flux, and primary and secondary productivity.

```{r summ-tables-df-gen, echo=TRUE,tidy=TRUE}
# first, compute median of log10 ratio values

EnvFertLRR_tables <- dplyr::filter(EnvFertRR_long, Ratio>=0) %>% 
  dplyr::group_by(., Fertility, Function, Scale, Compartment) %>% 
  dplyr::mutate(., LRR = log10(Ratio)) %>% 
  dplyr::summarise(., min = min(LRR), 
                   median = median(LRR), 
                   max = max(LRR), 
                   .groups = "keep")
```

Now, we produce the tables, separating between along and against-gradient 
movement, as above.

```{r xaringan-panelset, echo=TRUE, include=FALSE}
xaringanExtra::use_panelset()
```

### Consumer movement changes local and meta-ecosystem functions

::::: {.panelset}

::: {.panel}

#### Biomass and Nutrient Stock {.panel-name}
```{r EFstock-table-gen, echo=TRUE, tidy=TRUE}
EFStockTab <- EnvFertLRR_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Stock") %>% 
  pivot_wider(., names_from = Fertility, values_from = c(min, median, max)) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "C1rr", "Consumers" = "C2rr", "Consumers" = "Crr", "Producers" = "P1rr", "Producers" = "P2rr", "Producers" = "Prr", "Nutrients" = "N1rr", "Nutrients" = "N2rr", "Nutrients" = "Nrr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Nutrients", "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  tab_spanner(label = md("**Along-gradient**"), columns = c("min_Along", "median_Along", "max_Along")) %>%
  tab_spanner(label = md("**Against-gradient**"), columns = c("min_Against", "median_Against", "max_Against")) %>%
  cols_label(Compartment = md("**Compartment**"), "min_Along" = md("*Min.*"), "median_Along" = md("*Median*"), "max_Along" = md("*Max.*"), "min_Against" = md("*Min.*"), "median_Against" = md("*Median*"), "max_Against" = md("*Max.*")) %>%
  fmt_number(., columns = c(4:9), decimals = 2) %>% 
  data_color(., columns = c(6, 7), colors = col_numeric(palette = "PiYG", domain = c(-1,1))) %>% tab_header(title = md("**Change in nutrient stock and organic biomass accumulation** in the meta-ecosystem when consumers move against or along an environmental fertility gradient."), subtitle = md("Values are expressed as median _LRR_ for 10000 iterations of the model.")) %>% tab_style(style = cell_text(align = "left", size = 18), locations = cells_title())

# gtsave(EFStockTab, filename = "EFbiostock.tex", path = "../Results/")

EFStockTab
```

:::

::: {.panel}

#### Nutrient Flux {.panel-name}
```{r EFflux-table-gen, echo=TRUE, tidy=TRUE}
EFFluxTab <- EnvFertLRR_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Nutrient Flux") %>% 
  pivot_wider(., names_from = Fertility, values_from = c(min, median, max)) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "FLUX_C1rr", "Consumers" = "FLUX_C2rr", "Consumers" = "FLUX_Crr", "Producers" = "FLUX_P1rr", "Producers" = "FLUX_P2rr", "Producers" = "FLUX_Prr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  tab_spanner(label = md("**Along-gradient**"), columns = c("min_Along", "median_Along", "max_Along")) %>%
  tab_spanner(label = md("**Against-gradient**"), columns = c("min_Against", "median_Against", "max_Against")) %>%
  cols_label(Compartment = md("**Compartment**"), "min_Along" = md("*Min.*"), "median_Along" = md("*Median*"), "max_Along" = md("*Max.*"), "min_Against" = md("*Min.*"), "median_Against" = md("*Median*"), "max_Against" = md("*Max.*"))%>%
  fmt_number(., columns = c(4:9), decimals = 2) %>% 
  data_color(., columns = c(6, 7), colors = col_numeric(palette = "PiYG", domain = c(-1,1))) %>% tab_header(title = md("**Change in nutrient flux** in the meta-ecosystem when consumers move against or along an environmental fertility gradient."), subtitle = md("Values are expressed as median _LRR_ for 10000 iterations of the model.")) %>% tab_style(style = cell_text(align = "left", size = 18), locations = cells_title())

# gtsave(EFFluxTab, filename = "EFnutflux.tex", path = "../Results/")

EFFluxTab
```

:::

::: {.panel}

#### Trophic Productivity {.panel-name}
```{r EFprod-table-gen, echo=TRUE, tidy=TRUE}
EFProdTab <- EnvFertLRR_tables %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(., Function == "Trophic Productivity") %>% 
  pivot_wider(., names_from = Fertility, values_from = c(min, median, max)) %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "PROD_C1rr", "Consumers" = "PROD_C2rr", "Consumers" = "PROD_Crr", "Producers" = "PROD_P1rr", "Producers" = "PROD_P2rr", "Producers" = "PROD_Prr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Producers", "Consumers")) %>%
  gt(groupname_col = "Scale") %>% 
  cols_hide("Function") %>% 
  tab_spanner(label = md("**Along-gradient**"), columns = c("min_Along", "median_Along", "max_Along")) %>%
  tab_spanner(label = md("**Against-gradient**"), columns = c("min_Against", "median_Against", "max_Against")) %>%
  cols_label(Compartment = md("**Compartment**"), "min_Along" = md("*Min.*"), "median_Along" = md("*Median*"), "max_Along" = md("*Max.*"), "min_Against" = md("*Min.*"), "median_Against" = md("*Median*"), "max_Against" = md("*Max.*"))%>%
  fmt_number(., columns = c(4:9), decimals = 2) %>% 
  data_color(., columns = c(6, 7), colors = col_numeric(palette = "PiYG", domain = c(-1,1))) %>% tab_header(title = md("**Change in trophic compartment productivity** in the meta-ecosystem when consumers move _along-_ or _against-gradient_ of nutrient availability."), subtitle = md("Values are expressed as median _LRR_ for 10 000 iterations of the model.")) %>% tab_style(style = cell_text(align = "left", size = 18), locations = cells_title())

# gtsave(EFProdTab, filename = "EFprod.tex", path = "../Results/")

EFProdTab
```

:::

:::::

# Changes to biomass distribution in local and meta-ecosystem

Here, we investigate whether different types of consumer movement between the 
two local ecosystems lead to changes in the distribution of biomass in the 
meta-ecosystem. Biomass distribution in local and meta-ecosystems can vary from 
bottom-heavy to top-heavy [@McCauley2018]. Bottom-heavy ecosystems present the 
classic biomass distribution, with a large base of primary producers supporting an 
increasingly smaller biomass of primary and secondary consumers. 
This bottom-heavy distribution is typical of terrestrial ecosystems---albeit 
exceptions exist [@Hatton2015; @McCauley2018]. Conversely, in top-heavy 
ecosystems, a small base of primary producers supports a large biomass of 
primary and secondary consumers. This inverted biomass distribution,
long seen as an exception, is increasingly recognized as widespread in certain 
systems---e.g., marine ecosystems [@Sandin2015; @McCauley2018; @Woodson2018]. 

To investigate biomass distribution in our model, we use the Consumer 
to Resource biomass ratio, calculated as:

$\displaystyle C{:}R = \frac{{C^{\ast}_i}}{{P^{\ast}_i}}$

where the asterisk $^{\ast}$ indicates the equilibrium biomass estimates for 
Consumer and Primary Producers and $i \in [1, 2]$ indicates the ecosystem---
either donor (1) or recipient (2). Values of $C{:}R < 1$ identify ecosystems 
with a bottom-heavy biomass distribution, whereas when $C{:}R > 1$ the biomass 
distribution is inverted and top-heavy [@McCauley2018]. 

We begin by calculating the $C{:}R$ ratio for each scenario investigated above. 
First, we create a new dataframe `bmDistr`, where we will store the required 
data: fertility conditions, movement rates values, efficiency rates values, 
state variable values at equilibrium, and ecosystem function values. We will 
also filter out those parameter sets that have no biological sense and are 
unstable as per the stability analyses above.

```{r biomass-cr-ratio-df, echo=TRUE, tidy=TRUE}
bmDistr <- bind_rows("Equal" = PRED, 
                     "Along" = PREDI2, 
                     "Against" = PREDI1, 
                     .id = "Fertility") %>% 
  select(., biosense, Fertility:e2, N1:C2, Ntot:Ctot) %>% 
  filter(., biosense == "yes") %>%
  dplyr::mutate(.,
                Eco1 = C1/P1,
                Eco2 = C2/P2,
                MetaEco = Ctot/Ptot)
```

Let's look at the density distribution of these data. First, we exclude 
parameter sets that produce _extreme_ values of $C{:}R$---that is, $C{:}R > 10$.

```{r bm-cr-filter, echo=TRUE, tidy=TRUE}
ecoCR <- filter(bmDistr, Eco1 <= 10 & Eco2 <= 10 & MetaEco <= 10)

# we can save this object to speed up later work
saveRDS(ecoCR, file = "../Results/ecoCR.rds")
```

Now, we pivot the resulting dataset and plot the density distribution of $C{:}R$ 
values. 

```{r bm-cr-distrib-summary, echo=TRUE, tidy=TRUE, fig.cap="Density distribution when dataset is limited to _C:R_ < 10. Note the different scales on the y-axis."}
fert.labs <- c("Against-gradient", "Along-gradient", "Gradient-neutral")
names(fert.labs) <- c("Against", "Along", "Equal")

scale.labs <- c("Ecosystem 1", "Ecosystem 2", "Meta-ecosystem")
names(scale.labs) <- c("Ecosystem 1", "Ecosystem 2", "Meta-ecosystem")

ecoCR_long <- pivot_longer(ecoCR, cols = c(Eco1, Eco2, MetaEco), 
                           values_to = "CRratio", names_to = "Scale") %>% 
  mutate_at(., vars(Scale), factor) %>% 
  mutate(., Scale = ifelse(Scale == "Eco1", 
                           "Ecosystem 1", ifelse(Scale == "Eco2", 
                                                 "Ecosystem 2", 
                                                 "Meta-ecosystem")))

ggplot(ecoCR_long, aes(x = CRratio, fill = Fertility, col = Fertility)) + 
  geom_density(aes(y = after_stat(density)), alpha = 0.1) + 
  scale_color_highcontrast(reverse = T, name = "Consumer movement", 
                           labels = c("Against-gradient", 
                                      "Along-gradient", 
                                      "Gradient-neutral")) +
  scale_fill_highcontrast(reverse = T, name = "Consumer movement", 
                          labels = c("Against-gradient", 
                                     "Along-gradient", 
                                     "Gradient-neutral")) +
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) +
  xlab("C:R ratio") + 
  ylab("Density") +
  theme(legend.position = "top")

#ggsave(filename = "../Results/Density_CRratio_lessThan10.pdf", device = "pdf", dpi = 300, width = 10, height = 7)
```

::::: {.panelset}

::: {.panel}

## Movement from donor {.panel-name}

Here we look at how the $C{:}R$ values change with increasing movement from 
ecosystem 1, the donor, towards the dispersers' pool `Q` (i.e., parameter `g` in 
the model). The graph below uses the full dataset created above, `ecoCR_long`, 
and fits linear models to each combination of Fertility scenario 
(_gradient-neutral_, _along-_, and _against-gradient_) and Scale (ecosystem 1, 
ecosystem 2, and meta-ecosystem).

```{r cr-ratio-vs-g, echo=TRUE, tidy=TRUE, fig.cap="Distribution of _C:R_ values lower than 10 as the movement rate from ecosystem 1 to the dispersers' pool (g) increases. Darker shades of blue correspond to a higher count of _C:R_ value in a given bin. Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data. _C:R_ values appear to follow a decreasing trend as g increases in Ecosystem 1 and in the Meta-ecosystem, whereas they appear stable or slightly increasing in Ecosystem 2."}
ecoCRg_lm <- ecoCR_long %>% nest_by(Fertility, Scale) %>% 
  mutate(model = list(lm(CRratio ~ g, data = data)))  

ecoCRg_lmOutput <- ecoCRg_lm %>% summarise(glance(model))

ecoCRg_lmOutput$g_slope <- NA
ecoCRg_lmOutput$g_se <- NA

for (i in 1:length(ecoCRg_lm[["model"]])) {
  ecoCRg_lmOutput$g_slope[i] <- ecoCRg_lm$model[[i]]$coefficient[2]
  ecoCRg_lmOutput$g_se[i] <- summary(ecoCRg_lm$model[[i]])$coefficient["g", "Std. Error"]
}

ecoCRg_lmOutput %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(columns = c(r.squared:p.value,logLik:deviance, g_slope:g_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n",
             g_slope = "g Coeff.",
             g_se = "g SE") %>% 
  gtsave(., filename = "../Results/CR_g_lm_res.rtf")

ecoCR_long %>% ggplot(., aes(x = g, y = CRratio)) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) + 
  geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) + 
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) + 
  ylab("C:R ratio") + 
  xlab("Movement rate from Ecosystem 1 to Dispersers' Pool (g)")  
  # ggtitle("Binned distribution of C:R", 
  #         subtitle = "C:R values [0,10].") 

#ggsave(filename = "../Results/CRratioVg_binned.pdf", device = "pdf", dpi = 300, width = 12, height = 12)
```

Now, let's explore the relationships in a bit more detail. We do this by 
splitting the dataframe in two portions: $C{:}R > 1$ and $C{:}R < 1$. Here, we 
take a look at the relationship for $C{:}R$ values $> 1$ but $< 10$.

```{r cr-ratio-above-1-vs-g, echo=TRUE, tidy=TRUE, fig.cap="Distribution of _C:R_ values comprised between (1, 10] as the movement rate from ecosystem 1 to the dispersers' pool (g) increases. As g increases, we do not observe any trend in the values of _C:R_. Note that _C:R_ > 1 are generally indicative of top-heavy, inverted biomass distributions. Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data."}
ecoCRg_lm_above1 <- ecoCR_long %>% 
  filter(., CRratio > 1) %>% 
  nest_by(Fertility, Scale) %>% 
  mutate(model = list(lm(CRratio ~ g, data = data)))  

ecoCRg_lmOutput_above1 <- ecoCRg_lm_above1 %>% summarise(glance(model)) 

ecoCRg_lmOutput_above1$g_slope <- NA
ecoCRg_lmOutput_above1$g_se <- NA

for (i in 1:length(ecoCRg_lm_above1[["model"]])) {
  ecoCRg_lmOutput_above1$g_slope[i] <- ecoCRg_lm_above1$model[[i]]$coefficient[2]
  ecoCRg_lmOutput_above1$g_se[i] <- summary(ecoCRg_lm_above1$model[[i]])$coefficient["g", "Std. Error"]
}

ecoCRg_lmOutput_above1 %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(columns = c(r.squared:p.value, 
                         logLik:deviance, 
                         g_slope:g_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n", 
             g_slope = "g Coeff.",
             g_se = "g SE") %>% 
  tab_header(title = md("Modeling C:R ratio vs Movement rate to Dispersers' 
                        Pool (g)"), 
             subtitle = md("C:R values between (1,10].")) %>% 
  gtsave(., filename = "../Results/CR_g_lm_above1.rtf")

ecoCR_long %>% 
  filter(., CRratio > 1) %>% 
  ggplot(., aes(x = m, y = CRratio)) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) +
  geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) + 
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) + 
  ylab("C:R ratio") + 
  xlab("Movement rate from Ecosystem 1 to Dispersers' Pool (g)") 

# ggsave(filename = "../Results/CRratioVg_binned_above1.pdf", device = "pdf", 
       # dpi = 300, width = 12, height = 12)
```

And here is the relationship for $C{:}R$ values $< 1$ but $> 0$.

```{r cr-ratio-below-1-vs-g, echo=TRUE, fig.cap="Distribution of _C:R_ values [0,1] when movement rate from ecosystem 1 to the dispersers' pool (g) increases. Again, no trend is apparent save for a seeming increase in _C:R_ values in ecosystem 2 when consumers move along-gradient (central panel). Note, however, that this trend does not scale up to the meta-ecosystem. Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data."}
ecoCRg_lm_below1 <- ecoCR_long %>% 
  filter(., CRratio <= 1) %>% 
  nest_by(Fertility, Scale) %>% 
  mutate(model = list(lm(CRratio ~ g, data = data)))  

ecoCRg_lmOutput_below1 <- ecoCRg_lm_below1 %>% summarise(glance(model))

ecoCRg_lmOutput_below1$g_slope <- NA
ecoCRg_lmOutput_below1$g_se <- NA

for (i in 1:length(ecoCRg_lm_below1[["model"]])) {
  ecoCRg_lmOutput_below1$g_slope[i] <- ecoCRg_lm_below1$model[[i]]$coefficient[2]
  ecoCRg_lmOutput_below1$g_se[i] <- summary(ecoCRg_lm_above1$model[[i]])$coefficient["g", "Std. Error"]
}

ecoCRg_lmOutput_below1 %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(., columns = c(r.squared:p.value,logLik:deviance, g_slope:g_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n", 
             g_slope = "g Coeff.",
             g_se = "g SE") %>% 
  tab_header(title = md("Modeling C:R ratio vs Movement rate to Dispersers' 
                        Pool (g)"), 
             subtitle = md("C:R values between [0,1].")) %>% 
  gtsave(., filename = "../Results/CR_g_lm_below1.rtf")

ecoCR_long %>% 
  filter(., CRratio <= 1) %>% 
  ggplot(., aes(x = m, y = CRratio)) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) +
  geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) +  
 facet_grid(Fertility~Scale, scales = "free", 
            labeller = labeller(Fertility = fert.labs, 
                                Scale = scale.labs)) +  
  ylab("C:R ratio") + 
  xlab("Movement rate from Ecosystem 1 to Dispersers' Pool (g)") 

#ggsave(filename = "../Results/CRratioVg_binned_below1.pdf", device = "pdf", dpi = 300, width = 12, height = 12)
```

:::

:::{.panel}

## Movement to recipient {.panel-name}

Here, we investigate how the $C{:}R$ biomass ratio changes 
with increasing values of `m`, the movement rate of consumers leaving the
dispersers' pool `Q` to enter ecosystem 2. Here is the general relationship.

```{r cr-ratio-vs-m, echo = TRUE, tidy=TRUE, fig.cap="Density distribution of _C:R_ values [0,10] as consumer movement rate from the dispersers' pool to ecosystem 2 (m) increases. No trend is clearly visible, aside from an apparent increase in _C:R_ in ecosystem 2 when consumers move along-gradients (central panel). Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data."}
ecoCRm_lm <- ecoCR_long %>% 
  nest_by(Fertility, Scale) %>% 
  mutate(model = list(lm(CRratio ~ m, data = data)))  

ecoCRm_lmOutput <- ecoCRm_lm %>% summarise(glance(model))

ecoCRm_lmOutput$m_slope <- NA
ecoCRm_lmOutput$m_se <- NA

for (i in 1:length(ecoCRm_lm[["model"]])) {
  ecoCRm_lmOutput$m_slope[i] <- ecoCRm_lm$model[[i]]$coefficient[2]
  ecoCRm_lmOutput$m_se[i] <- summary(ecoCRm_lm$model[[i]])$coefficient["m", "Std. Error"]
}

ecoCRm_lmOutput %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(columns = c(r.squared:p.value,logLik:deviance, m_slope:m_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n",
             m_slope = "m Coeff.",
             m_se = "m SE") %>% 
  gtsave(., filename = "../Results/CR_m_lm_res.rtf")

ecoCR_long %>% 
  ggplot(., aes(x = m, y = CRratio, )) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) +
 geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) + 
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) + 
  ylab("C:R ratio") + 
  xlab("Movement rate from the Dispersers' Pool to Ecosystem 2 (m)") 

#ggsave(filename = "../Results/CRratioVm_binned.pdf", device = "pdf", dpi = 300, width = 12, height = 12)
```

Here is the relationship for $C{:}R$ values $> 1$ but $< 10$.

```{r cr-ratio-above-1-vs-m, echo=TRUE, tidy=TRUE, fig.cap="Distribution of _C:R_ (1, 10] as movement rate from the dispersers' pool to ecosystem 2 (m) increases. Focusing on only _C:R_ values indicative of inverted, top-heavy biomass distributions shows weakly increasing trends in the value of _C:R_ in ecosystem 1 when consumers move against-gradient (top-left panel), and in ecosystem 2 when consumers move along-gradient (central panel). We also note an apparent decrese in _C:R_ values in ecosystem 1 as consumers move in an homogeneous meta-ecosystem (bottom-left panel). Note, however, that none of these trends appears to influence biomass dynamics at the meta-ecosystem scale (right-most column). Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data."}
ecoCRm_lm_above1 <- ecoCR_long %>% 
  filter(., CRratio > 1) %>% 
  nest_by(Fertility, 
          Scale) %>% 
  mutate(model = list(lm(CRratio ~ m, 
                         data = data)))  

ecoCRm_lmOutput_above1 <- ecoCRm_lm_above1 %>% summarise(glance(model)) 

ecoCRm_lmOutput_above1$m_slope <- NA
ecoCRm_lmOutput_above1$m_se <- NA

for (i in 1:length(ecoCRm_lm_above1[["model"]])) {
  ecoCRm_lmOutput_above1$m_slope[i] <- ecoCRm_lm_above1$model[[i]]$coefficients[2]
  ecoCRm_lmOutput_above1$m_se[i] <- summary(ecoCRm_lm_above1$model[[i]])$coefficient["m", "Std. Error"]
}

ecoCRm_lmOutput_above1 %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(columns = c(r.squared:p.value, 
                         logLik:deviance, 
                         m_slope:m_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n", 
             m_slope = "m Coeff.",
             m_se = "m SE") %>% 
  tab_header(title = md("Modeling C:R ratio vs Movement rate from Dispersers' 
                        Pool (m)"), 
             subtitle = md("C:R values between (1,10].")) %>% 
  gtsave(., filename = "../Results/CR_m_lm_above1.rtf")

ecoCR_long %>% 
  filter(., CRratio > 1) %>% 
  ggplot(., aes(x = m, y = CRratio)) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) +
  geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) + 
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) +  
  ylab("C:R ratio") + 
  xlab("Movement rate from the Dispersers' Pool to Ecosystem 2 (m)") 

# ggsave(filename = "../Results/CRratioVm_binned_above1.pdf", device = "pdf", 
       # dpi = 300, width = 12, height = 12)
```

And here is the relationship for $C{:}R$ values $< 1$ but $> 0$.

```{r cr-ratio-below-1-vs-m, echo=TRUE, tidy=TRUE, fig.cap="Distribution of _C:R_ [0,1] as consumer movement rate from the dispersers pool to ecosystem 2 (m) increases. Here, we notice apparently increasing trends in ecosystem 2 when consumers move along-gradient (central panel) and in an homogeneous meta-ecosystem (center-bottom panel). We do not see any influence of these trends at the meta-ecosystem scale. Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data."}
ecoCRm_lm_below1 <- ecoCR_long %>% 
  filter(., CRratio <= 1) %>% 
  nest_by(Fertility, Scale) %>% 
  mutate(model = list(lm(CRratio ~ m, data = data)))  

ecoCRm_lmOutput_below1 <- ecoCRm_lm_below1 %>% summarise(glance(model))

ecoCRm_lmOutput_below1$m_slope <- NA
ecoCRm_lmOutput_below1$m_se <- NA

for (i in 1:length(ecoCRm_lm_below1[["model"]])) {
  ecoCRm_lmOutput_below1$m_slope[i] <- ecoCRm_lm_below1$model[[i]]$coefficient[2]
  ecoCRm_lmOutput_below1$m_se[i] <- summary(ecoCRm_lm_below1$model[[i]])$coefficient["m", "Std. Error"]
}

ecoCRm_lmOutput_below1 %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(columns = c(r.squared:p.value,logLik:deviance, m_slope:m_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n", 
             m_slope = "m Coeff.",
             m_se = "m SE") %>% 
  tab_header(title = md("Modeling C:R ratio vs Movement rate from Dispersers' Pool (m)"), subtitle = md("C:R values between [0,1].")) %>% 
  gtsave(., filename = "../Results/CR_m_lm_below1.rtf")

ecoCR_long %>% 
  filter(., CRratio <= 1) %>% 
  ggplot(., aes(x = m, y = CRratio)) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) +
  geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) + 
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) + 
  ylab("C:R ratio") + 
  xlab("Movement rate from the Dispersers' Pool to Ecosystem 2 (m)")

#ggsave(filename = "../Results/CRratioVm_binned_below1.pdf", device = "pdf", dpi = 300, width = 12, height = 12)
```

:::

:::{.panel}

## Death rate in Dispersers' pool {.panel-name}

Here, we investigate how the $C{:}R$ biomass ratio changes 
with increasing values of `c`, the death rate of consumers while in the 
dispersers' pool. Consumer biomass lost while transiting through `Q` is 
lost from the meta-ecosystem and does not contribute to the recycling 
pathways at either local or regional scale. Hence, it is important to 
track how biomass distribution in the system may vary with this parameter. Here 
is the general relationship.

```{r cr-ratio-vs-c, echo=TRUE, tidy=TRUE, fig.cap = "Distribution of _C:R_ values [0,10] as the consumer death rate in the dispersers' pool (c) increases. No trend is apparent, aside from a weak decrease in ecosystem 2 (central and center-bottom panels) that have no influence on meta-ecosystem biomass dynamics. Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data."}
ecoCRc_lm <- ecoCR_long %>% 
  nest_by(Fertility, Scale) %>% 
  mutate(model = list(lm(CRratio ~ c, data = data)))  

ecoCRc_lmOutput <- ecoCRc_lm %>% summarise(glance(model))

ecoCRc_lmOutput$c_slope <- NA
ecoCRc_lmOutput$c_se <- NA

for (i in 1:length(ecoCRc_lm[["model"]])) {
  ecoCRc_lmOutput$c_slope[i] <- ecoCRc_lm$model[[i]]$coefficient[2]
  ecoCRc_lmOutput$c_se[i] <- summary(ecoCRc_lm$model[[i]])$coefficient["c", "Std. Error"]
}

ecoCRc_lmOutput %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(columns = c(r.squared:p.value,logLik:deviance, c_slope:c_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n",
             c_slope = "c Coeff.",
             c_se = "c SE") %>% 
  gtsave(., filename = "../Results/CR_c_lm_res.rtf")

ecoCR_long %>% 
  ggplot(., aes(x = c, y = CRratio, )) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) +
  geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) + 
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) +  
  ylab("C:R ratio") + 
  xlab("Consumers death rate while in the Dispersers' Pool (c)") 

#ggsave(filename = "../Results/CRratioVc_binned.pdf", device = "pdf", dpi = 300, width = 12, height = 12)
```

Here is the relationship for $C{:}R$ values $> 1$ but $< 10$.

```{r cr-ratio-above-1-vs-c, echo=TRUE, tidy=TRUE, fig.cap = "Distribution of _C:R_ (1,10] as consumer death rate in the dispersers' pool (c) increases. Regardless of the type of consumer movement, we see no trend in the distribution of _C:R_ values that identify top-heavy, inverted biomass distributions. Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data."}
ecoCRc_lm_above1 <- ecoCR_long %>% 
  filter(., CRratio > 1) %>% 
  nest_by(Fertility, Scale) %>% 
  mutate(model = list(lm(CRratio ~ c, data = data)))  

ecoCRc_lmOutput_above1 <- ecoCRc_lm_above1 %>% summarise(glance(model)) 

ecoCRc_lmOutput_above1$c_slope <- NA
ecoCRc_lmOutput_above1$c_se <- NA

for (i in 1:length(ecoCRc_lm_above1[["model"]])) {
  ecoCRc_lmOutput_above1$c_slope[i] <- ecoCRc_lm_above1$model[[i]]$coefficients[2]
  ecoCRc_lmOutput_above1$c_se[i] <- summary(ecoCRc_lm_above1$model[[i]])$coefficient["c", "Std. Error"]
}

ecoCRc_lmOutput_above1 %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(columns = c(r.squared:p.value,logLik:deviance, c_slope:c_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n", 
             c_slope = "c Coeff.",
             c_se = "c SE") %>% 
  tab_header(title = md("Modeling C:R ratio vs death rate while in the
                        Dispersers' Pool (c)"), 
             subtitle = md("C:R values between (1,10].")) %>% 
  gtsave(., filename = "../Results/CR_c_lm_above1.rtf")

ecoCR_long %>% 
  filter(., CRratio > 1) %>% 
  ggplot(., aes(x = c, y = CRratio)) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) +
  geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) + 
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) + 
  ylab("C:R ratio") + 
  xlab("Consumer death rate while in the Dispersers' Pool (c)")

#ggsave(filename = "../Results/CRratioVc_binned_above1.pdf", device = "pdf", dpi = 300, width = 12, height = 12)
```

And here is the relationship for $C{:}R$ values $< 1$ but $> 0$.

```{r cr-ratio-below-1-vs-c, echo=TRUE, tidy=TRUE, fig.cap = "Distribution of _C:R_ [0,1] as consumer death rate in the dispersers' pool (c) increases. Focusing on _C:R_ < 1 brings out a weak, negative trend in ecosystem 2 when consumers move along-gradient (central panel) and in an homogeneous meta-ecosystem (center-bottom panel). Neither of these trends have any influence at the meta-ecosystem scale. Lines correspond to a linear regression (black dashed line) and to a quantile regression calculated for the median (black continuous line) fitted to the data."}
ecoCRc_lm_below1 <- ecoCR_long %>% 
  filter(., CRratio <= 1) %>% 
  nest_by(Fertility, Scale) %>% 
  mutate(model = list(lm(CRratio ~ c, data = data)))  

ecoCRc_lmOutput_below1 <- ecoCRc_lm_below1 %>% summarise(glance(model))

ecoCRc_lmOutput_below1$c_slope <- NA
ecoCRc_lmOutput_below1$c_se <- NA

for (i in 1:length(ecoCRc_lm_below1[["model"]])) {
  ecoCRc_lmOutput_below1$c_slope[i] <- ecoCRc_lm_below1$model[[i]]$coefficient[2]
  ecoCRc_lmOutput_below1$c_se[i] <- summary(ecoCRc_lm_below1$model[[i]])$coefficient["c", "Std. Error"]
}

ecoCRc_lmOutput_below1 %>% 
  gt(groupname_col = "Scale") %>% 
  fmt_number(columns = c(r.squared:p.value,logLik:deviance, c_slope:c_se), 
             decimals = 3) %>% 
  cols_label(., r.squared = "R^2", 
             adj.r.squared = "Adj. R^2", 
             sigma = "SE", 
             df.residual = "Residual df", 
             nobs = "n", 
             c_slope = "c Coeff.",
             c_se = "c SE") %>% 
  tab_header(title = md("Modeling C:R ratio vs death rate while in the 
                        Dispersers' pool (c)"), 
             subtitle = md("C:R values between [0,1].")) %>% 
  gtsave(., filename = "../Results/CR_c_lm_below1.rtf")

ecoCR_long %>% 
  filter(., CRratio <= 1) %>% 
  ggplot(., aes(x = c, y = CRratio)) + 
  geom_bin2d(bins = 70) + 
  scale_fill_met_c("Hokusai2", direction = 1) +
  geom_smooth(method = "lm", se = FALSE, col = "black",
              linetype = 2, show.legend = T, size = .5) + 
  geom_quantile(method = "rq", quantiles = .5, col = "black",
                show.legend = T) + 
  facet_grid(Fertility~Scale, scales = "free", 
             labeller = labeller(Fertility = fert.labs, 
                                 Scale = scale.labs)) +  
  ylab("C:R ratio") + 
  xlab("Consumer death rate while in the Dispersers' Pool (c)") 

#ggsave(filename = "../Results/CRratioVc_binned_below1.pdf", device = "pdf", dpi = 300, width = 12, height = 12)
```
:::

:::::

## Visual Deliverable---Biomass distributions

Here we produce graphs of the biomass distributions produced by consumer movement 
across ecosystems. These graphs allow for easy visualization of the changes in the 
distribution of biomass in either local ecosystem, or in the meta-ecosystem as a
whole, following different types of consumer movement.

We produce four graphs, one each for the following four cases:
(i) _classic_, bottom-heavy distribution in the donor ecosystem 1 (**Appendix Figure D.3**); 
(ii) _classic_, bottom-heavy distribution in the recipient ecosystem 2; 
(iii) _inverted_, top-heavy distribution in the donor ecosystem 1 (**Appendix Figure D.5**); 
(iv)  _inverted_, top-heavy distribution in the recipient ecosystem 2. We separate 
between bottom- and top-heavy distributions in either the donor or recipient 
ecosystems as these local conditions can influence the effects of consumer 
movement on biomass distribution and thus ecosystem functioning. Note that these
four biomass-informed categories will return when we perform a global 
sensitivity analyses on our results below ([Sensitivity Analyses]).

The code we use here was initially developed by 
[Dr. A. Z. Andis Arietta](https://www.azandisresearch.com).

::::: {.panelset}

::: {.panel}

#### Classic donor {.panel-name}

```{r biomass-distributions-donor-cr-below-1, echo=TRUE, tidy=TRUE, fig.cap="Biomass distributions for ecosystem 1 (donor), ecosystem 2 (recipient), and the meta-ecosystem when the Consumer:Resource ratio in ecosystem 1 is < 1. Bottom-heavy biomass distributions dominate the system in all movement scenarios. However, note how against-gradient consumer movement consistently allows for---on average---higher levels of Primary Producers biomass compared to both along-gradient and gradient-neutral consumer movement. The labels inside the bars show the average biomass for each ecosystem compartment."}
# first, produce a df that contains the values that will be printed on top of each bar in the biomass distributions
summary_df <- ecoCR %>% 
  ungroup() %>%
  select(biosense:I2, N1:Ctot, Eco1) %>%
  filter(., Eco1 < 1) %>%
  pivot_longer(cols = c(N1:Ctot),
               names_to = "Compartment",
               values_to = "Biomass") %>%
  mutate(., Ecosystem = if_else(Compartment == "N1" |
                                  Compartment == "P1" |
                                  Compartment == "C1",
                                "Ecosystem 1", 
                                ifelse(Compartment == "N2" |
                                         Compartment == "P2" |
                                         Compartment == "C2",
                                       "Ecosystem 2",
                                       "Meta-ecosystem")),
         .before = Compartment,
         Compartment = ifelse(Compartment == "N1" | 
                                Compartment == "N2" |
                                Compartment == "Ntot", 
                              "Nutrients", 
                              ifelse(Compartment == "P1" | 
                                       Compartment == "P2" |
                                       Compartment == "Ptot", 
                                     "Primary\nProducers", 
                                     "Consumers")),
         Compartment = fct_relevel(Compartment, 
                                   "Nutrients", 
                                   "Primary\nProducers", 
                                   "Consumers")) %>% 
  group_by(Fertility, Ecosystem, Compartment)

# then, produce the plot
ecoCR %>%
  ungroup() %>%
  select(biosense:I2, N1:Ctot, Eco1) %>%
  filter(Eco1 < 1) %>%
  pivot_longer(cols = c(N1:Ctot),
               names_to = "Compartment",
               values_to = "Biomass") %>%
  mutate(., Ecosystem = if_else(Compartment == "N1" |
                              Compartment == "P1" |
                              Compartment == "C1",
                            "Ecosystem 1", 
                            ifelse(Compartment == "N2" |
                                     Compartment == "P2" |
                                     Compartment == "C2",
                                   "Ecosystem 2",
                                   "Meta-ecosystem")),
         .before = Compartment,
         Compartment = ifelse(Compartment == "N1" | 
                                Compartment == "N2" |
                                Compartment == "Ntot", 
                              "Nutrients", 
                              ifelse(Compartment == "P1" | 
                                       Compartment == "P2" |
                                       Compartment == "Ptot", 
                                     "Primary\nProducers", 
                                     "Consumers")),
         Compartment = fct_relevel(Compartment, "Nutrients", "Primary\nProducers", "Consumers")) %>% 
  ggplot(aes(x = Compartment, y = Biomass)) +
  geom_bar(aes(fill = Compartment, color = Compartment),
    stat = "identity", 
    width = 0.9) +
  geom_bar(data = . %>% mutate(Biomass = -Biomass),
           aes(fill = Compartment, color = Compartment), 
           stat = "identity", 
           width = 0.9) +
  stat_summary(data = summary_df,
              geom = "label", 
              fun.args = list(mult = 1, na.rm = T), 
              aes(label = round(after_stat(y), 2)), 
              position = position_dodge(width = 1), 
              show.legend = F, size = 2,
              label.padding = unit(0.1, "lines"), 
              label.size = 0.1,
              color = "black") + 
  scale_color_met_d(name = "Isfahan2", direction = 1) +
  scale_fill_met_d(name = "Isfahan2", direction = 1) +
  facet_grid(Fertility~Ecosystem, scales = "free") +
  coord_flip() +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    legend.position = "top"
  )

# ggsave(filename = "../Results/Bpyram_CRbelow1_eco1.pdf", dpi = 300, device = "pdf")
```

:::

:::{.panel}

#### Classic recipient {.panel-name}

```{r biomass-distributions-recipient-cr-below-1, echo=TRUE, tidy=TRUE, fig.cap="Biomass distributions for ecosystem 1 (donor), ecosystem 2 (recipient), and the meta-ecosystem when the Consumer:Resource ratio in ecosystem 2 is < 1. In this case, the biomass distribution in the system is more nuanced and variable, and depends on the direction of consumer movement. Against-gradient consumer movement leads to comparable average biomass of Primary Producers in the two ecosystems. Conversely, in the along-gradient and gradient-neutral scenarios, the distribution of Primary Producers' biomass is skewed towards ecosystem 1 (the donor). Note also how the distribution of Nutrients varies among donor and recipient ecosystems across movement scenarios."}
# first, produce a df that contains the values that will be printed on top of each bar in the biomass distributions
summary_df <- ecoCR %>% 
  ungroup() %>%
  select(biosense:I2, N1:Ctot, Eco2) %>%
  filter(Eco2 < 1) %>%
  pivot_longer(cols = c(N1:Ctot),
               names_to = "Compartment",
               values_to = "Biomass") %>%
  mutate(., Ecosystem = if_else(Compartment == "N1" |
                                  Compartment == "P1" |
                                  Compartment == "C1",
                                "Ecosystem 1", 
                                ifelse(Compartment == "N2" |
                                         Compartment == "P2" |
                                         Compartment == "C2",
                                       "Ecosystem 2",
                                       "Meta-ecosystem")),
         .before = Compartment,
         Compartment = ifelse(Compartment == "N1" | 
                                Compartment == "N2" |
                                Compartment == "Ntot", 
                              "Nutrients", 
                              ifelse(Compartment == "P1" | 
                                       Compartment == "P2" |
                                       Compartment == "Ptot", 
                                     "Primary\nProducers", 
                                     "Consumers")),
         Compartment = fct_relevel(Compartment, 
                                   "Nutrients", 
                                   "Primary\nProducers", 
                                   "Consumers")) %>% 
  group_by(Fertility, Ecosystem, Compartment)

# then, produce the plot
ecoCR %>%
  ungroup() %>%
  select(biosense:I2, N1:Ctot, Eco2) %>%
  filter(Eco2 < 1) %>%
  pivot_longer(cols = c(N1:Ctot),
               names_to = "Compartment",
               values_to = "Biomass") %>%
  mutate(., Ecosystem = if_else(Compartment == "N1" |
                              Compartment == "P1" |
                              Compartment == "C1",
                            "Ecosystem 1", 
                            ifelse(Compartment == "N2" |
                                     Compartment == "P2" |
                                     Compartment == "C2",
                                   "Ecosystem 2",
                                   "Meta-ecosystem")),
         .before = Compartment,
         Compartment = ifelse(Compartment == "N1" | 
                                Compartment == "N2" |
                                Compartment == "Ntot", 
                              "Nutrients", 
                              ifelse(Compartment == "P1" | 
                                       Compartment == "P2" |
                                       Compartment == "Ptot", 
                                     "Primary\nProducers", 
                                     "Consumers")),
         Compartment = fct_relevel(Compartment, "Nutrients", "Primary\nProducers", "Consumers")) %>% 
  ggplot(aes(x = Compartment, y = Biomass)) +
  geom_bar(aes(fill = Compartment, color = Compartment),
    stat = "identity", 
    width = 0.9) +
  geom_bar(data = . %>% mutate(Biomass = -Biomass),
           aes(fill = Compartment, color = Compartment), 
           stat = "identity", 
           width = 0.9) +
  stat_summary(data = summary_df,
              geom = "label", 
              fun.args = list(mult = 1, na.rm = T), 
              aes(label = round(after_stat(y), 2)), 
              position = position_dodge(width = 1), 
              show.legend = F, size = 2,
              label.padding = unit(0.1, "lines"), 
              label.size = 0.1,
              color = "black") +
  scale_color_met_d(name = "Isfahan2", direction = 1) +
  scale_fill_met_d(name = "Isfahan2", direction = 1) +
  facet_grid(Fertility~Ecosystem, scales = "free") +
  coord_flip() +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    legend.position = "top"
  )

# ggsave(filename = "../Results/Bpyram_CRbelow1_eco2.pdf", dpi = 300, device = "pdf")
```

:::

:::{.panel}

#### Inverted donor {.panel-name}

```{r biomass-distributions-donor-cr-above-1, echo=TRUE, tidy=TRUE, fig.cap="Biomass distributions for ecosystem 1 (donor), ecosystem 2 (recipient), and the meta-ecosystem when the Consumer:Resource ratio in ecosystem 1 is > 1. In this case, while we see top-heavy, inverted biomass distributions in the donor ecosystem, bottom-heavy distributions still dominate the recipient ecosystem and ultimately the meta-ecosystem as a whole. In the against-gradient scenario, we can see an accumulation of nutrients in the recipient ecosystem (resource pooling effect), whereas the along-gradient scenario leads to a more equal distribution of nutrients in the system that resembles what we find in the gradient-neutral scenario."}
# first, produce a df that contains the values that will be printed on top of each bar in the biomass distributions
summary_df <- ecoCR %>% 
  ungroup() %>%
  select(biosense:I2, N1:Ctot, Eco1) %>%
  filter(Eco1 > 1) %>%
  pivot_longer(cols = c(N1:Ctot),
               names_to = "Compartment",
               values_to = "Biomass") %>%
  mutate(., Ecosystem = if_else(Compartment == "N1" |
                                  Compartment == "P1" |
                                  Compartment == "C1",
                                "Ecosystem 1", 
                                ifelse(Compartment == "N2" |
                                         Compartment == "P2" |
                                         Compartment == "C2",
                                       "Ecosystem 2",
                                       "Meta-ecosystem")),
         .before = Compartment,
         Compartment = ifelse(Compartment == "N1" | 
                                Compartment == "N2" |
                                Compartment == "Ntot", 
                              "Nutrients", 
                              ifelse(Compartment == "P1" | 
                                       Compartment == "P2" |
                                       Compartment == "Ptot", 
                                     "Primary\nProducers", 
                                     "Consumers")),
         Compartment = fct_relevel(Compartment, 
                                   "Nutrients", 
                                   "Primary\nProducers", 
                                   "Consumers")) %>% 
  group_by(Fertility, Ecosystem, Compartment)

# then, produce the plot
ecoCR %>%
  ungroup() %>%
  select(biosense:I2, N1:Ctot, Eco1) %>%
  filter(Eco1 > 1) %>%
  pivot_longer(cols = c(N1:Ctot),
               names_to = "Compartment",
               values_to = "Biomass") %>%
  mutate(., Ecosystem = if_else(Compartment == "N1" |
                              Compartment == "P1" |
                              Compartment == "C1",
                            "Ecosystem 1", 
                            ifelse(Compartment == "N2" |
                                     Compartment == "P2" |
                                     Compartment == "C2",
                                   "Ecosystem 2",
                                   "Meta-ecosystem")),
         .before = Compartment,
         Compartment = ifelse(Compartment == "N1" | 
                                Compartment == "N2" |
                                Compartment == "Ntot", 
                              "Nutrients", 
                              ifelse(Compartment == "P1" | 
                                       Compartment == "P2" |
                                       Compartment == "Ptot", 
                                     "Primary\nProducers", 
                                     "Consumers")),
         Compartment = fct_relevel(Compartment, "Nutrients", "Primary\nProducers", "Consumers")) %>% 
  ggplot(aes(x = Compartment, y = Biomass)) +
  geom_bar(aes(fill = Compartment, color = Compartment),
    stat = "identity", 
    width = 0.9) +
  geom_bar(data = . %>% mutate(Biomass = -Biomass),
           aes(fill = Compartment, color = Compartment), 
           stat = "identity", 
           width = 0.9) +
  stat_summary(data = summary_df,
              geom = "label", 
              fun.args = list(mult = 1, na.rm = T), 
              aes(label = round(after_stat(y), 2)), 
              position = position_dodge(width = 1), 
              show.legend = F, size = 2,
              label.padding = unit(0.1, "lines"), 
              label.size = 0.1,
              color = "black") + 
  scale_color_met_d(name = "Isfahan2", direction = 1) +
  scale_fill_met_d(name = "Isfahan2", direction = 1) +
  facet_grid(Fertility~Ecosystem, scales = "free") +
  coord_flip() +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    legend.position = "top"
  )

# ggsave(filename = "../Results/Bpyram_CRabove1_eco1.pdf", dpi = 300, device = "pdf")
```

:::

:::{.panel}

#### Inverted recipient {.panel-name}

```{r biomass-distributions-recipient-cr-above-1, echo=TRUE, tidy=TRUE, fig.cap="Biomass distributions for ecosystem 1 (donor), ecosystem 2 (recipient), and the meta-ecosystem when the Consumer:Resource ratio in ecosystem 2 is > 1. Here, we observe the spatial trophic cascade in action as a lack of top-down control on Primary Producers leads to a highly skewed accumulation of biomass for this compartment in ecosystem 1, the donor, whereas ecosystem 2 shows much reduced autothroph presence. Conversely, both Consumer biomass and Nutrient stock are higher in ecosystem 2, the recipient, in all movement scenarios. Notice how, when the recipient ecosystem shows a top-heavy biomass distribution, along-gradient consumer movement is the only scenario in which the distribution of nutrients is somewhat homogeneous across the landscape."}
# first, produce a df that contains the values that will be printed on top of each bar in the biomass distributions
summary_df <- ecoCR %>% 
  ungroup() %>%
  select(biosense:I2, N1:Ctot, Eco2) %>%
  filter(Eco2 > 1) %>%
  pivot_longer(cols = c(N1:Ctot),
               names_to = "Compartment",
               values_to = "Biomass") %>%
  mutate(., Ecosystem = if_else(Compartment == "N1" |
                                  Compartment == "P1" |
                                  Compartment == "C1",
                                "Ecosystem 1", 
                                ifelse(Compartment == "N2" |
                                         Compartment == "P2" |
                                         Compartment == "C2",
                                       "Ecosystem 2",
                                       "Meta-ecosystem")),
         .before = Compartment,
         Compartment = ifelse(Compartment == "N1" | 
                                Compartment == "N2" |
                                Compartment == "Ntot", 
                              "Nutrients", 
                              ifelse(Compartment == "P1" | 
                                       Compartment == "P2" |
                                       Compartment == "Ptot", 
                                     "Primary\nProducers", 
                                     "Consumers")),
         Compartment = fct_relevel(Compartment, 
                                   "Nutrients", 
                                   "Primary\nProducers", 
                                   "Consumers")) %>% 
  group_by(Fertility, Ecosystem, Compartment)

# then, produce the plot
ecoCR %>%
  ungroup() %>%
  select(biosense:I2, N1:Ctot, Eco2) %>%
  filter(Eco2 > 1) %>%
  pivot_longer(cols = c(N1:Ctot),
               names_to = "Compartment",
               values_to = "Biomass") %>%
  mutate(., Ecosystem = if_else(Compartment == "N1" |
                              Compartment == "P1" |
                              Compartment == "C1",
                            "Ecosystem 1", 
                            ifelse(Compartment == "N2" |
                                     Compartment == "P2" |
                                     Compartment == "C2",
                                   "Ecosystem 2",
                                   "Meta-ecosystem")),
         .before = Compartment,
         Compartment = ifelse(Compartment == "N1" | 
                                Compartment == "N2" |
                                Compartment == "Ntot", 
                              "Nutrients", 
                              ifelse(Compartment == "P1" | 
                                       Compartment == "P2" |
                                       Compartment == "Ptot", 
                                     "Primary\nProducers", 
                                     "Consumers")),
         Compartment = fct_relevel(Compartment, "Nutrients", "Primary\nProducers", "Consumers")) %>% 
  ggplot(aes(x = Compartment, y = Biomass)) +
  geom_bar(aes(fill = Compartment, color = Compartment),
    stat = "identity", 
    width = 0.9) +
  geom_bar(data = . %>% mutate(Biomass = -Biomass),
           aes(fill = Compartment, color = Compartment), 
           stat = "identity", 
           width = 0.9) +
  stat_summary(data = summary_df,
              geom = "label", 
              fun.args = list(mult = 1, na.rm = T), 
              aes(label = round(after_stat(y), 2)), 
              position = position_dodge(width = 1), 
              show.legend = F, size = 2,
              label.padding = unit(0.1, "lines"), 
              label.size = 0.1,
              color = "black") + 
  scale_color_met_d(name = "Isfahan2", direction = 1) +
  scale_fill_met_d(name = "Isfahan2", direction = 1) +
  facet_grid(Fertility~Ecosystem, scales = "free") +
  coord_flip() +
  theme_classic() +
  theme(
    text = element_text(size = 14),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    legend.position = "top"
  )

# ggsave(filename = "../Results/Bpyram_CRabove1_eco2.pdf", dpi = 300, device = "pdf")
```

:::

:::::

## Summary tables---Biomass distribution

The three tabs below contain tables showing summary statistics for the linear
models fitted to the distribution of biomass in the meta-ecosystem. The table 
shown in tab [Movement from ecosystem 1] is intended as a companion to Figures 
\@ref(fig:cr-ratio-vs-g), \@ref(fig:cr-ratio-above-1-vs-g), and 
\@ref(fig:cr-ratio-below-1-vs-g). Similarly, the table in tab 
[Movement towards ecosystem 2] is a companion to Figures \@ref(fig:cr-ratio-vs-m), 
\@ref(fig:cr-ratio-above-1-vs-m), and \@ref(fig:cr-ratio-below-1-vs-m). Finally,
the table in tab [Death rate in Dispersers' pool] provides details to accompany 
Figures \@ref(fig:cr-ratio-vs-c), \@ref(fig:cr-ratio-above-1-vs-c),
and \@ref(fig:cr-ratio-below-1-vs-c).

::::: {.panelset}

::: {.panel}

#### Movement from donor {.panel-name}
```{r cr-g-summ-table-gen, echo=TRUE,tidy=TRUE}
# first, compute median of log10 ratio values

ecoCR_g_table <- bind_rows("above 1" = ecoCRg_lmOutput_above1, 
                           "below 1" = ecoCRg_lmOutput_below1, 
                           .id = "CRslice") %>% 
  ungroup() %>% 
  select(., CRslice:adj.r.squared, g_slope:g_se) %>% 
  pivot_wider(., names_from = "CRslice", 
              values_from = c(r.squared, adj.r.squared, g_slope, g_se)) %>% 
  gt(., groupname_col = "Scale") %>% 
  tab_spanner(label = md("**C:R (1, 10]**"), 
              columns = c("r.squared_above 1", 
                          "adj.r.squared_above 1", 
                          "g_slope_above 1",
                          "g_se_above 1")) %>% 
  tab_spanner(label = md("**C:R [0, 1]**"), 
              columns = c("r.squared_below 1", 
                          "adj.r.squared_below 1", 
                          "g_slope_below 1",
                          "g_se_below 1")) %>% 
  fmt_number(., columns = 3:10, decimals = 3) %>% 
  cols_label(., "r.squared_above 1"= md("R sq."), 
             "adj.r.squared_above 1" = md("Adj. R sq."), 
             "g_slope_above 1" = md("g Coeff."), 
             "g_se_above 1" = md("g SE"),
             "r.squared_below 1"= md("R sq."), 
             "adj.r.squared_below 1" = md("Adj. R sq."), 
             "g_slope_below 1" = md("g Coeff."),
             "g_se_below 1" = md("g SE")) %>% 
  # data_color(., columns = c(3:10), 
  #            colors = col_numeric(palette = "PiYG", domain = c(-1,1))) %>% 
  tab_header(title = md("**Relationships between biomass _C:R_ and movement from ecosystem 1.**"), subtitle = md("The table shows the slope value (g Coeff.) and standard error (g SE) for linear regression models fitted to the biomass _C:R_ data. R squared and Adjusted R squared values provide a measure of fit of the model to the data. Data are split between _C:R_  values larger than 1 but below 10, and _C:R_ values below 1 but above 0.")) %>% 
  tab_style(style = cell_text(align = "left", size = 18), 
            locations = cells_title())

ecoCR_g_table
```

:::

:::{.panel}
#### Movement to recipient {.panel-name}
```{r cr-m-summ-table-gen, echo=TRUE,tidy=TRUE}
# first, compute median of log10 ratio values

ecoCR_m_table <- bind_rows("above 1" = ecoCRm_lmOutput_above1, 
                           "below 1" = ecoCRm_lmOutput_below1, 
                           .id = "CRslice") %>% 
  ungroup() %>% 
  select(., CRslice:adj.r.squared, m_slope:m_se) %>% 
  pivot_wider(., names_from = "CRslice", 
              values_from = c(r.squared, adj.r.squared, m_slope, m_se)) %>% 
  gt(., groupname_col = "Scale") %>% 
  tab_spanner(label = md("**C:R (1, 10]**"), 
              columns = c("r.squared_above 1", 
                          "adj.r.squared_above 1", 
                          "m_slope_above 1",
                          "m_se_above 1")) %>% 
  tab_spanner(label = md("**C:R [0, 1]**"), 
              columns = c("r.squared_below 1", 
                          "adj.r.squared_below 1", 
                          "m_slope_below 1",
                          "m_se_below 1")) %>% 
  fmt_number(., columns = 3:10, decimals = 3) %>% 
  cols_label(., "r.squared_above 1"= md("R sq."), 
             "adj.r.squared_above 1" = md("Adj. R sq."), 
             "m_slope_above 1" = md("m Coeff."), 
             "m_se_above 1" = md("m SE"),
             "r.squared_below 1"= md("R sq."), 
             "adj.r.squared_below 1" = md("Adj. R sq."), 
             "m_slope_below 1" = md("m Coeff."),
             "m_se_below 1" = md("m SE")) %>% 
  # data_color(., columns = c(3:10), 
  #            colors = col_numeric(palette = "PiYG", domain = c(-,))) %>% 
  tab_header(title = md("**Relationships between biomass _C:R_ and movement into ecosystem 2.**"), subtitle = md("The table shows the slope value (m Coeff.) and standard error (m SE) for linear regression models fitted to the biomass _C:R_ data. R squared and Adjusted R squared values provide a measure of fit of the model to the data. Data are split between _C:R_  values larger than 1 but below 10, and _C:R_ values below 1 but above 0.")) %>% 
  tab_style(style = cell_text(align = "left", size = 18), 
            locations = cells_title()) 

ecoCR_m_table
```
:::

:::{.panel}

#### Death rate in Dispersers' pool {.panel-name}
```{r cr-c-summ-table-gen, echo=TRUE,tidy=TRUE}
# first, compute median of log10 ratio values

ecoCR_c_table <- bind_rows("above 1" = ecoCRc_lmOutput_above1, 
                           "below 1" = ecoCRc_lmOutput_below1, 
                           .id = "CRslice") %>% 
  ungroup() %>% 
  select(., CRslice:adj.r.squared, c_slope:c_se) %>% 
  pivot_wider(., names_from = "CRslice", 
              values_from = c(r.squared, adj.r.squared, c_slope, c_se)) %>% 
  gt(., groupname_col = "Scale") %>% 
  tab_spanner(label = md("**C:R (1, 10]**"), 
              columns = c("r.squared_above 1", 
                          "adj.r.squared_above 1", 
                          "c_slope_above 1",
                          "c_se_above 1")) %>% 
  tab_spanner(label = md("**C:R [0, 1]**"), 
              columns = c("r.squared_below 1", 
                          "adj.r.squared_below 1", 
                          "c_slope_below 1",
                          "c_se_below 1")) %>% 
  fmt_number(., columns = 3:10, decimals = 3) %>% 
  cols_label(., "r.squared_above 1"= md("R sq."), 
             "adj.r.squared_above 1" = md("Adj. R sq."), 
             "c_slope_above 1" = md("c Coeff."), 
             "c_se_above 1" = md("c SE"),
             "r.squared_below 1"= md("R sq."), 
             "adj.r.squared_below 1" = md("Adj. R sq."), 
             "c_slope_below 1" = md("c Coeff."),
             "c_se_below 1" = md("c SE")) %>% 
  # data_color(., columns = c(3:10), 
  #            colors = col_numeric(palette = "PiYG", domain = c(-,))) %>% 
  tab_header(title = md("**Relationships between biomass _C:R_ and death rate in dispersers' pool.**"), subtitle = md("The table shows the slope value (c Coeff.) and standard error (c SE) for linear regression models fitted to the biomass _C:R_ data. R squared and Adjusted R squared values provide a measure of fit of the model to the data. Data are split between _C:R_  values larger than 1 but below 10, and _C:R_ values below 1 but above 0.")) %>% 
  tab_style(style = cell_text(align = "left", size = 18), 
            locations = cells_title()) 

ecoCR_c_table
```
:::

:::::

## Summary tables---Comparison across _C:R_ values

Here, we produce summary tables that show how the effects of consumer movement
on local and meta-ecosystem functions vary as the biomass distribution changes
in the system as a result of the consumer movement itself. 

We begin by collating together the required dataframes.

```{r cr-summary-tabs-setup, echo=TRUE,tidy=TRUE}
CRcomparison <- bind_rows("all" = EnvFertRR, 
                          "above_1" = EnvFertRR_CRabove1, 
                          "below_1" = EnvFertRR_CRbelow1, 
                          .id = "CR") %>% 
  select(., !(N1:Ctot)) %>% 
  filter(., biosense == "yes" | stable == "stable") %>%
  mutate(., CR = as_factor(CR)) %>%
  droplevels()
```

Then, we lengthen the dataset as this is the preferred format for producing
tables with package `gt`. 

```{r cr-summary-tab-pivot, echo=TRUE, tidy=TRUE}
# the first step in the pipe remove the by-ecosystem CR data, as these are now store in the CR column
CRcomparison_long <- select(CRcomparison, 
                            !c(biosense, 
                               stable, 
                               CR_Eco1, 
                               CR_Eco2, 
                               CR_MetaEco 
                               )) %>% 
  pivot_longer(.,  
               cols = N1rr:PROD_Crr, 
               names_to = "Compartment",
               values_to = "Ratio") %>% 
  dplyr::mutate(., Function = if_else(Compartment == "FLUX_P1rr" | 
                                        Compartment == "FLUX_P2rr" | 
                                        Compartment == "FLUX_C1rr" | 
                                        Compartment == "FLUX_C2rr" | 
                                        Compartment == "FLUX_Prr" | 
                                        Compartment == "FLUX_Crr", 
                                      "Nutrient Flux", 
                                      if_else(Compartment == "PROD_P1rr" | 
                                                Compartment == "PROD_C1rr" | 
                                                Compartment == "PROD_P2rr" | 
                                                Compartment == "PROD_C2rr" | 
                                                Compartment == "PROD_Prr" | 
                                                Compartment == "PROD_Crr", 
                                              "Trophic Productivity",
                                                    "Stock"))) %>% 
  dplyr::mutate(., Scale = if_else(Compartment == "N1rr" | 
                                     Compartment == "P1rr" | 
                                     Compartment == "C1rr" | 
                                     Compartment == "FLUX_P1rr" | 
                                     Compartment == "FLUX_C1rr" | 
                                     Compartment == "PROD_P1rr" | 
                                     Compartment == "PROD_C1rr" , 
                                   "Ecosystem 1", 
                                   if_else(Compartment == "N2rr" | 
                                             Compartment == "P2rr" | 
                                             Compartment == "C2rr" | 
                                             Compartment == "FLUX_P2rr" | 
                                             Compartment == "FLUX_C2rr" | 
                                             Compartment == "PROD_P2rr" | 
                                             Compartment == "PROD_C2rr" , 
                                           "Ecosystem 2", 
                                           "Meta-ecosystem"))) %>% 
  dplyr::mutate(., Fertility = factor(Fertility), 
                Function = factor(Function), 
                Scale = factor(Scale), 
                Compartment = factor(Compartment)) 
```

We now remove all values of the Response Ratio that are $< 0$ and 
$log_{10}$-transform them before calculating the median. 

```{r cr-summary-median-lrr-calc, echo=TRUE,tidy=TRUE}
CRcomparison_tables <- dplyr::filter(CRcomparison_long, Ratio>=0) %>%
  dplyr::group_by(., CR, Fertility, Function, Scale, Compartment) %>%
  dplyr::mutate(., LRR = log10(Ratio)) %>% 
  dplyr::summarise(.,
                   median = median(LRR), 
                   .groups = "keep")

# can add min(LRR) and max(LRR) is needed
```

Finally, we produce summary tables that show the differences in median _LRR_ 
when considering all stable parameter sets, parameter sets that produce 
$C{:}R > 1$, and parameter sets that produce $C{:}R < 1$. As before, we produce 
one table per ecosystem function.

::::: {.panelset}

::: {.panel}

#### Biomass and Nutrient Accumulation {.panel-name}

```{r stock-cr-summary-tab, echo=TRUE,tidy=TRUE}
CRsummStock <- CRcomparison_tables %>% 
  ungroup() %>% 
  filter(., Function == "Stock") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "C1rr", "Consumers" = "C2rr", "Consumers" = "Crr", "Producers" = "P1rr", "Producers" = "P2rr", "Producers" = "Prr", "Nutrients" = "N1rr", "Nutrients" = "N2rr", "Nutrients" = "Nrr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Nutrients", "Producers", "Consumers")) %>%
  pivot_wider(., names_from = c(CR, Fertility), 
              values_from = median) %>%
  gt(., groupname_col = "Scale") %>%
  fmt_number(., columns = 4:9, decimals = 2) %>%
  tab_spanner(label = md("**Along-gradient**"), 
              columns = c("all_Along", 
                          "above_1_Along",
                          "below_1_Along")) %>%
  tab_spanner(label = md("**Against-gradient**"), 
                columns = c("all_Against",
                            "above_1_Against",
                            "below_1_Against")) %>%
  cols_label(Compartment = md("**Compartment**"), 
             "all_Against" = md("*All C:R*"), 
             "above_1_Against" = md("*C:R > 1*"), 
             "below_1_Against" = md("*C:R < 1*"), 
             "all_Along" = md("*All C:R*"), 
             "above_1_Along" = md("*C:R > 1*"), 
             "below_1_Along" = md("*C:R < 1*")) %>% 
  cols_hide("Function") %>% 
  tab_footnote(
    footnote = "Includes parameter sets producing C:R > 10.",
    locations = cells_column_labels(
      columns = c("all_Against", "all_Along")
    )
  ) %>% tab_footnote(
    footnote = "Does not include parameter sets producing C:R > 10.",
    locations = cells_column_labels(
      columns = c("above_1_Against", "above_1_Along")
    )
  ) %>% 
  tab_header(title = md("**Median LRR values of biomass and nutrient stocks**"), subtitle = md("LRR values are grouped by fertility scenario and by whether they were calculated using all parameter sets, only parameter sets producing _C:R_ > 1, or only parameter sets producing _C:R_ < 1.")) %>% 
  tab_style(style = cell_text(align = "left", size = 18), 
            locations = cells_title())

CRsummStock
```
:::

::: {.panel}

#### Nutrient Flux {.panel-name}

```{r flux-cr-summary-tab, echo=TRUE, tidy=TRUE}
CRsummFlux <- CRcomparison_tables %>% 
  ungroup() %>% 
  filter(., Function == "Nutrient Flux") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "FLUX_C1rr", "Consumers" = "FLUX_C2rr", "Consumers" = "FLUX_Crr", "Producers" = "FLUX_P1rr", "Producers" = "FLUX_P2rr", "Producers" = "FLUX_Prr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Producers", "Consumers")) %>%
  pivot_wider(., names_from = c(CR, Fertility), 
              values_from = median) %>%
  gt(., groupname_col = "Scale") %>%
  fmt_number(., columns = 4:9, decimals = 2) %>%
  tab_spanner(label = md("**Along-gradient**"), 
              columns = c("all_Along", 
                          "above_1_Along",
                          "below_1_Along")) %>%
  tab_spanner(label = md("**Against-gradient**"), 
                columns = c("all_Against",
                            "above_1_Against",
                            "below_1_Against")) %>%
  cols_label(Compartment = md("**Compartment**"), 
             "all_Against" = md("*All C:R*"), 
             "above_1_Against" = md("*C:R > 1*"), 
             "below_1_Against" = md("*C:R < 1*"), 
             "all_Along" = md("*All C:R*"), 
             "above_1_Along" = md("*C:R > 1*"), 
             "below_1_Along" = md("*C:R < 1*")) %>% 
  cols_hide("Function") %>% 
  tab_footnote(
    footnote = "Includes parameter sets producing C:R > 10.",
    locations = cells_column_labels(
      columns = c("all_Against", "all_Along")
    )
  ) %>% tab_footnote(
    footnote = "Does not include parameter sets producing C:R > 10.",
    locations = cells_column_labels(
      columns = c("above_1_Against", "above_1_Along")
    )
  ) %>% 
  tab_header(title = md("**Median LRR values of nutrient flux**"), subtitle = md("LRR values are grouped by fertility scenario and by whether they were calculated using all parameter sets, only parameter sets producing _C:R_ > 1, or only parameter sets producing _C:R_ < 1.")) %>% 
  tab_style(style = cell_text(align = "left", size = 18), 
            locations = cells_title())

CRsummFlux
```
:::

::: {.panel}

#### Trophic Productivity {.panel-name}

```{r prod-cr-summary-tab, echo=TRUE,tidy=TRUE}
CRsummProd <- CRcomparison_tables %>% 
  ungroup() %>% 
  filter(., Function == "Trophic Productivity") %>% 
  dplyr::mutate(., Compartment = fct_recode(Compartment, "Consumers" = "PROD_C1rr", "Consumers" = "PROD_C2rr", "Consumers" = "PROD_Crr", "Producers" = "PROD_P1rr", "Producers" = "PROD_P2rr", "Producers" = "PROD_Prr")) %>%
  dplyr::mutate(., Compartment = fct_relevel(Compartment, "Producers", "Consumers")) %>%
  pivot_wider(., names_from = c(CR, Fertility), 
              values_from = median) %>%
  gt(., groupname_col = "Scale") %>%
  fmt_number(., columns = 4:9, decimals = 2) %>%
  tab_spanner(label = md("**Along-gradient**"), 
              columns = c("all_Along", 
                          "above_1_Along",
                          "below_1_Along")) %>%
  tab_spanner(label = md("**Against-gradient**"), 
                columns = c("all_Against",
                            "above_1_Against",
                            "below_1_Against")) %>%
  cols_label(Compartment = md("**Compartment**"), 
             "all_Against" = md("*All C:R*"), 
             "above_1_Against" = md("*C:R > 1*"), 
             "below_1_Against" = md("*C:R < 1*"), 
             "all_Along" = md("*All C:R*"), 
             "above_1_Along" = md("*C:R > 1*"), 
             "below_1_Along" = md("*C:R < 1*")) %>% 
  cols_hide("Function") %>% 
  tab_footnote(
    footnote = "Includes parameter sets producing C:R > 10.",
    locations = cells_column_labels(
      columns = c("all_Against", "all_Along")
    )
  ) %>% tab_footnote(
    footnote = "Does not include parameter sets producing C:R > 10.",
    locations = cells_column_labels(
      columns = c("above_1_Against", "above_1_Along")
    )
  ) %>% 
  tab_header(title = md("**Median LRR values of trophic compartment productivity**"), subtitle = md("LRR values are grouped by fertility scenario and by whether they were calculated using all parameter sets, only parameter sets producing _C:R_ > 1, or only parameter sets producing _C:R_ < 1.")) %>% 
  tab_style(style = cell_text(align = "left", size = 18), 
            locations = cells_title())

CRsummProd
```
:::

:::::

# Sensitivity Analyses

Here, we run a local sensitivity analysis (LSA) to investigate the influence 
of five key consumer-related parameters (_a~i~_, _d~i~_, _g_, _m_, _c_), 
henceforth **focal parameters**, on the model's equilibria and on the 
ecosystem functions of interest (see above, Manuscript).

We run one LSA for each focal parameter for each consumer movement scenario: 
_gradient-neutral_, _along-gradient_, and _against-gradient_ movement.

For each LSA run, we sample 1000 random values for the focal parameter from 
the range used for it in the [Model numerical analyses] (see Table 1 in 
Manuscript), while keeping other parameters in the LSA at their mean value 
for relevant movement scenario.

As neither the mean value of non-focal parameters nor the randomly-sampled
values of the focal parameters are necessarily comprised in the random sets 
of values used in the [Model numerical analyses], each LSA run below also 
includes a local stability analysis to check.

## Sensitivity analyses by consumer movement scenario

### Gradient-neutral scenario

First, we store the scenario's mean parameter values in named objects to use 
in local sensitivity analysis run below.

```{r grad-neutral-lsa-mean-params, echo=TRUE, tidy=TRUE}
I1_m <- PRED %>% filter(., stable == "stable") %>% pull(I1) %>% mean()
I2_m <- PRED %>% filter(., stable == "stable") %>% pull(I2) %>% mean()
l_m <- PRED %>% filter(., stable == "stable") %>% pull(l) %>% mean()
a1_m <- PRED %>% filter(., stable == "stable") %>% pull(a1) %>% mean()
a2_m <- PRED %>% filter(., stable == "stable") %>% pull(a2) %>% mean()
u1_m <- PRED %>% filter(., stable == "stable") %>% pull(u1) %>% mean()
u2_m <- PRED %>% filter(., stable == "stable") %>% pull(u2) %>% mean()
h1_m <- PRED %>% filter(., stable == "stable") %>% pull(h1) %>% mean()
h2_m <- PRED %>% filter(., stable == "stable") %>% pull(h2) %>% mean()
d1_m <- PRED %>% filter(., stable == "stable") %>% pull(d1) %>% mean()
d2_m <- PRED %>% filter(., stable == "stable") %>% pull(d2) %>% mean()
g_m <- PRED %>% filter(., stable == "stable") %>% pull(g) %>% mean()
m_m <- PRED %>% filter(., stable == "stable") %>% pull(m) %>% mean()
c_m <- PRED %>% filter(., stable == "stable") %>% pull(c) %>% mean()
e1_m <- PRED %>% filter(., stable == "stable") %>% pull(e1) %>% mean()
e2_m <- PRED %>% filter(., stable == "stable") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

#### Attack rate in Ecosystem 1

First, we generate values for the focal parameter, _a~1~_, in the [0.01, 10], 
as _a~1~_ = 0 render the _P~1~_ equilibrium equation meaningless.

```{r grad-neutral-lsa-a1-value-gen, echo=TRUE, tidy=TRUE}
DATA_neutral_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, we run the model with the _a~1~_ values we just produced and mean values for all other parameters.

```{r grad-neutral-lsa-a1}
NeutralEq_a1 <- NULL

NeutralEq_a1 <-rbind(NeutralEq_a1, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_neutral_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_neutral_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, 
# so let's flag them

NeutralEq_a1 <- NeutralEq_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                                           .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Now, for the reasons stated above, we run a local stability analysis on the 
`NeutralEq_a1` dataset.

```{r grad-neutral-lsa-a1-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Neutral_a1 <- NULL

# run the stability analysis loop
for (i in 1:nrow(NeutralEq_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_a1$I1[i]
  I2 = NeutralEq_a1$I2[i]
  l = NeutralEq_a1$l[i]
  u1 = NeutralEq_a1$u1[i]
  u2 = NeutralEq_a1$u2[i]
  a1 = NeutralEq_a1$a1[i]
  a2 = NeutralEq_a1$a2[i]
  h1 = NeutralEq_a1$h1[i]
  h2 = NeutralEq_a1$h2[i]
  d1 = NeutralEq_a1$d1[i]
  d2 = NeutralEq_a1$d2[i]
  g = NeutralEq_a1$g[i]
  m = NeutralEq_a1$m[i]
  c = NeutralEq_a1$c[i]
  e1 = NeutralEq_a1$e1[i]
  e2 = NeutralEq_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_a1$Q[i]
  dN1 = NeutralEq_a1$N1[i]
  dP1 = NeutralEq_a1$P1[i]
  dC1 = NeutralEq_a1$C1[i]
  dN2 = NeutralEq_a1$N2[i]
  dP2 = NeutralEq_a1$P2[i]
  dC2 = NeutralEq_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Neutral_a1 <- rbind(StabCheck_Neutral_a1, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                                 h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                                 dC1, dN2, dP2, dC2,
                                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                                 stable = stable,
                                                                 biosense = NeutralEq_a1$biosense[i]))
  
  # browser()
}

StabCheck_Neutral_a1$stable <- as.factor(StabCheck_Neutral_a1$stable)

# separate unstable equilibria to work with later
Neutral_a1_Unstab <- subset(StabCheck_Neutral_a1, StabCheck_Neutral_a1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_a1_Unstab)/nrow(StabCheck_Neutral_a1))*100, digits = 3)`** 
appear to produce unstable results.

:::

::: {.panel}

#### Death rate in Ecosystem 1

First, generate some values for _d~1~_, in the [0.01, 10] range. We chose `0.01`
as the left limit of our value range for the LSA to avoid issues with 
denominators being $\leq 0$.

```{r grad-neutral-lsa-d1-value-gen, echo=TRUE, tidy=TRUE}
DATA_neutral_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r grad-neutral-lsa-d1, echo=TRUE,tidy=TRUE}
NeutralEq_d1 <- NULL

NeutralEq_d1 <-rbind(NeutralEq_d1, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_neutral_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_neutral_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them 

NeutralEq_d1 <- NeutralEq_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And, finally, check for stability of the results from this new set of parameter 
values.

```{r grad-neutral-lsa-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_Neutral_d1 <- NULL

for (i in 1:nrow(NeutralEq_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_d1$I1[i]
  I2 = NeutralEq_d1$I2[i]
  l = NeutralEq_d1$l[i]
  u1 = NeutralEq_d1$u1[i]
  u2 = NeutralEq_d1$u2[i]
  a1 = NeutralEq_d1$a1[i]
  a2 = NeutralEq_d1$a2[i]
  h1 = NeutralEq_a1$h1[i]
  h2 = NeutralEq_d1$h2[i]
  d1 = NeutralEq_d1$d1[i]
  d2 = NeutralEq_d1$d2[i]
  g = NeutralEq_d1$g[i]
  m = NeutralEq_d1$m[i]
  c = NeutralEq_d1$c[i]
  e1 = NeutralEq_d1$e1[i]
  e2 = NeutralEq_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_d1$Q[i]
  dN1 = NeutralEq_d1$N1[i]
  dP1 = NeutralEq_d1$P1[i]
  dC1 = NeutralEq_d1$C1[i]
  dN2 = NeutralEq_d1$N2[i]
  dP2 = NeutralEq_d1$P2[i]
  dC2 = NeutralEq_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Neutral_d1 <- rbind(StabCheck_Neutral_d1, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                                 h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                                 dC1, dN2, dP2, dC2,
                                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                                 stable = stable,
                                                                 biosense = NeutralEq_d1$biosense[i]))
  
  # browser()
}

StabCheck_Neutral_d1$stable <- as.factor(StabCheck_Neutral_d1$stable)

# separate unstable equilibria to work with later
Neutral_d1_Unstab <- subset(StabCheck_Neutral_d1, StabCheck_Neutral_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_d1_Unstab)/nrow(StabCheck_Neutral_d1))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Movement rate into Q

Start by producing some values of _g_, excluding `0` to avoid denominators
going $\leq 0$.

```{r grad-neutral-lsa-g-values-gen, echo=TRUE,tidy=TRUE}
DATA_neutral_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r grad-neutral-lsa-g, echo=TRUE,tidy=TRUE}
NeutralEq_g <- NULL

NeutralEq_g <-rbind(NeutralEq_g, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_neutral_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_neutral_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

NeutralEq_g <- NeutralEq_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

As a final step, check for stability of this new set of parameter values.

```{r grad-neutral-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Neutral_g <- NULL

for (i in 1:nrow(NeutralEq_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_g$I1[i]
  I2 = NeutralEq_g$I2[i]
  l = NeutralEq_g$l[i]
  u1 = NeutralEq_g$u1[i]
  u2 = NeutralEq_g$u2[i]
  a1 = NeutralEq_g$a1[i]
  a2 = NeutralEq_g$a2[i]
  h1 = NeutralEq_g$h1[i]
  h2 = NeutralEq_g$h2[i]
  d1 = NeutralEq_g$d1[i]
  d2 = NeutralEq_g$d2[i]
  g = NeutralEq_g$g[i]
  m = NeutralEq_g$m[i]
  c = NeutralEq_g$c[i]
  e1 = NeutralEq_g$e1[i]
  e2 = NeutralEq_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_g$Q[i]
  dN1 = NeutralEq_g$N1[i]
  dP1 = NeutralEq_g$P1[i]
  dC1 = NeutralEq_g$C1[i]
  dN2 = NeutralEq_g$N2[i]
  dP2 = NeutralEq_g$P2[i]
  dC2 = NeutralEq_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Neutral_g <- rbind(StabCheck_Neutral_g, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                                 h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                                 dC1, dN2, dP2, dC2,
                                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                                 stable = stable,
                                                                 biosense = NeutralEq_g$biosense[i]))
  
  # browser()
}

StabCheck_Neutral_g$stable <- as.factor(StabCheck_Neutral_g$stable)

# separate unstable equilibria to work with later
Neutral_g_Unstab <- subset(StabCheck_Neutral_g, StabCheck_Neutral_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_g_Unstab)/nrow(StabCheck_Neutral_g))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Movement rate from Q

Begin by sampling values of _m_ between `[0.01, 10]`, to avoid cases of 
the denominators going $\leq 0$.

```{r grad-neutral-lsa-m-values-gen, echo=TRUE,tidy=TRUE}
DATA_neutral_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Follow up by running the LSA.

```{r grad-neutral-lsa-m, echo=TRUE,tidy=TRUE}
NeutralEq_m <- NULL

NeutralEq_m <-rbind(NeutralEq_m, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_neutral_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_neutral_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

NeutralEq_m <- NeutralEq_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

And wrap it up with a stability check on the results from this new set of 
parameter values.

```{r grad-neutral-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Neutral_m <- NULL

for (i in 1:nrow(NeutralEq_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_m$I1[i]
  I2 = NeutralEq_m$I2[i]
  l = NeutralEq_m$l[i]
  u1 = NeutralEq_m$u1[i]
  u2 = NeutralEq_m$u2[i]
  a1 = NeutralEq_m$a1[i]
  a2 = NeutralEq_m$a2[i]
  h1 = NeutralEq_m$h1[i]
  h2 = NeutralEq_m$h2[i]
  d1 = NeutralEq_m$d1[i]
  d2 = NeutralEq_m$d2[i]
  g = NeutralEq_m$g[i]
  m = NeutralEq_m$m[i]
  c = NeutralEq_m$c[i]
  e1 = NeutralEq_m$e1[i]
  e2 = NeutralEq_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_m$Q[i]
  dN1 = NeutralEq_m$N1[i]
  dP1 = NeutralEq_m$P1[i]
  dC1 = NeutralEq_m$C1[i]
  dN2 = NeutralEq_m$N2[i]
  dP2 = NeutralEq_m$P2[i]
  dC2 = NeutralEq_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Neutral_m <- rbind(StabCheck_Neutral_m, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                               h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                               dC1, dN2, dP2, dC2,
                                                               EiV1 = Re(eigen(Jacob)$values[1]),
                                                               EiV2 = Re(eigen(Jacob)$values[2]),
                                                               EiV3 = Re(eigen(Jacob)$values[3]),
                                                               EiV4 = Re(eigen(Jacob)$values[4]),
                                                               EiV5 = Re(eigen(Jacob)$values[5]),
                                                               EiV6 = Re(eigen(Jacob)$values[6]),
                                                               EiV7 = Re(eigen(Jacob)$values[7]),
                                                               maxEv = max(Re(base::eigen(Jacob)$values)),
                                                               stable = stable,
                                                               biosense = NeutralEq_m$biosense[i]))
  
  # browser()
}

StabCheck_Neutral_m$stable <- as.factor(StabCheck_Neutral_m$stable)

# separate unstable equilibria to work with later
Neutral_m_Unstab <- subset(StabCheck_Neutral_m, StabCheck_Neutral_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_m_Unstab)/nrow(StabCheck_Neutral_m))*100, digits = 3)`** parameter sets appear to be unstable.
:::

::: {.panel}

#### Death rate in Q

The first step is sampling values in the `[0.01, 10]` interval to then assign to
_c_. We chose `0.01` as left limit of the sampling interval to avoid instances of
the denominators going to $\leq 0$.

```{r grad-neutral-lsa-c-values-gen, echo=TRUE,tidy=TRUE}
DATA_neutral_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r grad-neutral-lsa-c, echo=TRUE,tidy=TRUE}
NeutralEq_c <- NULL

NeutralEq_c <-rbind(NeutralEq_c, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_neutral_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_neutral_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

NeutralEq_c <- NeutralEq_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for the results of the model stability, since we are using a
previously untested set of parameter values.

```{r grad-neutral-lsa-c-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Neutral_c <- NULL

for (i in 1:nrow(NeutralEq_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_c$I1[i]
  I2 = NeutralEq_c$I2[i]
  l = NeutralEq_c$l[i]
  u1 = NeutralEq_c$u1[i]
  u2 = NeutralEq_c$u2[i]
  a1 = NeutralEq_c$a1[i]
  a2 = NeutralEq_c$a2[i]
  h1 = NeutralEq_c$h1[i]
  h2 = NeutralEq_c$h2[i]
  d1 = NeutralEq_c$d1[i]
  d2 = NeutralEq_c$d2[i]
  g = NeutralEq_c$g[i]
  m = NeutralEq_c$m[i]
  c = NeutralEq_c$c[i]
  e1 = NeutralEq_c$e1[i]
  e2 = NeutralEq_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_c$Q[i]
  dN1 = NeutralEq_c$N1[i]
  dP1 = NeutralEq_c$P1[i]
  dC1 = NeutralEq_c$C1[i]
  dN2 = NeutralEq_c$N2[i]
  dP2 = NeutralEq_c$P2[i]
  dC2 = NeutralEq_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Neutral_c <- rbind(StabCheck_Neutral_c, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                               h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                               dC1, dN2, dP2, dC2,
                                                               EiV1 = Re(eigen(Jacob)$values[1]),
                                                               EiV2 = Re(eigen(Jacob)$values[2]),
                                                               EiV3 = Re(eigen(Jacob)$values[3]),
                                                               EiV4 = Re(eigen(Jacob)$values[4]),
                                                               EiV5 = Re(eigen(Jacob)$values[5]),
                                                               EiV6 = Re(eigen(Jacob)$values[6]),
                                                               EiV7 = Re(eigen(Jacob)$values[7]),
                                                               maxEv = max(Re(base::eigen(Jacob)$values)),
                                                               stable = stable,
                                                               biosense = NeutralEq_c$biosense[i]))
  
  # browser()
}

StabCheck_Neutral_c$stable <- as.factor(StabCheck_Neutral_c$stable)

# separate unstable equilibria to work with later
Neutral_c_Unstab <- subset(StabCheck_Neutral_c, StabCheck_Neutral_c$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_c_Unstab)/nrow(StabCheck_Neutral_c))*100, digits = 3)`** parameter sets appear to be unstable.
:::

:::::

### Along-gradient scenario

Let's remove the gradient-neutral mean parameter values objects first, then 
store this scenario's mean parameter values in named objects to use 
in local sensitivity analysis run below.

```{r along-lsa-mean-params, echo=TRUE, tidy=TRUE}
rm(list = c('I1_m', 'I2_m', 'l_m', 'a1_m', 'a2_m', 'u1_m', 'u2_m', 'h1_m', 
            'h2_m', 'd1_m', 'd2_m', 'g_m', 'c_m', 'm_m', 'e1_m', 'e2_m'))

I1_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(I1) %>% mean()
I2_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(I2) %>% mean()
l_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(l) %>% mean()
a1_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(a1) %>% mean()
a2_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(a2) %>% mean()
u1_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(u1) %>% mean()
u2_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(u2) %>% mean()
h1_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(h1) %>% mean()
h2_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(h2) %>% mean()
d1_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(d1) %>% mean()
d2_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(d2) %>% mean()
g_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(g) %>% mean()
m_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(m) %>% mean()
c_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(c) %>% mean()
e1_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(e1) %>% mean()
e2_m <- PREDI2 %>% filter(., stable == "stable") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

#### Attack rate in Ecosystem 1

First, sample parameter values for _a~1~_, leaving out values that could lead to
denominators $\leq 0$.

```{r along-lsa-a1-values-gen, echo=TRUE,tidy=TRUE}
DATA_along_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r along-lsa-a1, echo=TRUE, tidy=TRUE}
AlongEq_a1 <- NULL

AlongEq_a1 <-rbind(AlongEq_a1, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_along_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_along_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                       # Nutrient stock in ecosystem 1
                       ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary Producers biomass in ecosystem 1
                       (d1+g)/(a1*e1),
                       # Consumers biomass in ecosystem 1
                       (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Nutrient stock in ecosystem 2
                       (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                       # Primary Producers biomass in ecosystem 2
                       (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Consumer biomass in ecosystem 2
                       ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Consumer biomass in the Dispersers' Pool (Q)
                       (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Nutrient flux for primary producers in Ecosystem 1
                       ((d1+g)*h1)/(a1*e1),
                       # Nutrient flux for consumers in Ecosystem 1
                       (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                       # Nutrient flux for primary producers in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Nutrient flux for consumers in Ecosystem 2
                       (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Total flux in Ecosystem 1
                       (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Total flux in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Nutrient flux in the Dispersers' Pool
                       (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Primary productivity in Ecosystem 1
                       ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Secondary (=consumers) productivity in Ecosystem 1
                       (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary productivity in Ecosystem 2
                       ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                       # Secondary (=consumer) productivity in Ecosystem 2
                       (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_a1 <- AlongEq_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check the result for stability.

```{r along-lsa-a1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_Along_a1 <- NULL

for (i in 1:nrow(AlongEq_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_a1$I1[i]
  I2 = AlongEq_a1$I2[i]
  l = AlongEq_a1$l[i]
  u1 = AlongEq_a1$u1[i]
  u2 = AlongEq_a1$u2[i]
  a1 = AlongEq_a1$a1[i]
  a2 = AlongEq_a1$a2[i]
  h1 = AlongEq_a1$h1[i]
  h2 = AlongEq_a1$h2[i]
  d1 = AlongEq_a1$d1[i]
  d2 = AlongEq_a1$d2[i]
  g = AlongEq_a1$g[i]
  m = AlongEq_a1$m[i]
  c = AlongEq_a1$c[i]
  e1 = AlongEq_a1$e1[i]
  e2 = AlongEq_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_a1$Q[i]
  dN1 = AlongEq_a1$N1[i]
  dP1 = AlongEq_a1$P1[i]
  dC1 = AlongEq_a1$C1[i]
  dN2 = AlongEq_a1$N2[i]
  dP2 = AlongEq_a1$P2[i]
  dC2 = AlongEq_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Along_a1 <- rbind(StabCheck_Along_a1, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                               h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                               dC1, dN2, dP2, dC2,
                                                               EiV1 = Re(eigen(Jacob)$values[1]),
                                                               EiV2 = Re(eigen(Jacob)$values[2]),
                                                               EiV3 = Re(eigen(Jacob)$values[3]),
                                                               EiV4 = Re(eigen(Jacob)$values[4]),
                                                               EiV5 = Re(eigen(Jacob)$values[5]),
                                                               EiV6 = Re(eigen(Jacob)$values[6]),
                                                               EiV7 = Re(eigen(Jacob)$values[7]),
                                                               maxEv = max(Re(base::eigen(Jacob)$values)),
                                                               stable = stable,
                                                               biosense = AlongEq_a1$biosense[i]))
  
  # browser()
}

StabCheck_Along_a1$stable <- as.factor(StabCheck_Along_a1$stable)

# separate unstable equilibria to work with later
Along_a1_Unstab <- subset(StabCheck_Along_a1, StabCheck_Along_a1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_a1_Unstab)/nrow(StabCheck_Along_a1))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Death rate in Ecosystem 1

Start by generating values for _d~1~_, leaving `0` out to avoid denominators 
going to $\leq 0$.

```{r along-lsa-d1-values-gen, echo=TRUE,tidy=TRUE}
DATA_along_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r along-lsa-d1, echo=TRUE,tidy=TRUE}
AlongEq_d1 <- NULL

AlongEq_d1 <-rbind(AlongEq_d1, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_along_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_along_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                       # Nutrient stock in ecosystem 1
                       ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary Producers biomass in ecosystem 1
                       (d1+g)/(a1*e1),
                       # Consumers biomass in ecosystem 1
                       (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Nutrient stock in ecosystem 2
                       (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                       # Primary Producers biomass in ecosystem 2
                       (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Consumer biomass in ecosystem 2
                       ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Consumer biomass in the Dispersers' Pool (Q)
                       (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Nutrient flux for primary producers in Ecosystem 1
                       ((d1+g)*h1)/(a1*e1),
                       # Nutrient flux for consumers in Ecosystem 1
                       (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                       # Nutrient flux for primary producers in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Nutrient flux for consumers in Ecosystem 2
                       (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Total flux in Ecosystem 1
                       (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Total flux in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Nutrient flux in the Dispersers' Pool
                       (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Primary productivity in Ecosystem 1
                       ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Secondary (=consumers) productivity in Ecosystem 1
                       (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary productivity in Ecosystem 2
                       ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                       # Secondary (=consumer) productivity in Ecosystem 2
                       (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_d1 <- AlongEq_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check this new set of parameter values for stability, using the 
state variable values calculated above.

```{r along-lsa-d1-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Along_d1 <- NULL

for (i in 1:nrow(AlongEq_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_d1$I1[i]
  I2 = AlongEq_d1$I2[i]
  l = AlongEq_d1$l[i]
  u1 = AlongEq_d1$u1[i]
  u2 = AlongEq_d1$u2[i]
  a1 = AlongEq_d1$a1[i]
  a2 = AlongEq_d1$a2[i]
  h1 = AlongEq_d1$h1[i]
  h2 = AlongEq_d1$h2[i]
  d1 = AlongEq_d1$d1[i]
  d2 = AlongEq_d1$d2[i]
  g = AlongEq_d1$g[i]
  m = AlongEq_d1$m[i]
  c = AlongEq_d1$c[i]
  e1 = AlongEq_d1$e1[i]
  e2 = AlongEq_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_d1$Q[i]
  dN1 = AlongEq_d1$N1[i]
  dP1 = AlongEq_d1$P1[i]
  dC1 = AlongEq_d1$C1[i]
  dN2 = AlongEq_d1$N2[i]
  dP2 = AlongEq_d1$P2[i]
  dC2 = AlongEq_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Along_d1 <- rbind(StabCheck_Along_d1, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                             h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                             dC1, dN2, dP2, dC2,
                                                             EiV1 = Re(eigen(Jacob)$values[1]),
                                                             EiV2 = Re(eigen(Jacob)$values[2]),
                                                             EiV3 = Re(eigen(Jacob)$values[3]),
                                                             EiV4 = Re(eigen(Jacob)$values[4]),
                                                             EiV5 = Re(eigen(Jacob)$values[5]),
                                                             EiV6 = Re(eigen(Jacob)$values[6]),
                                                             EiV7 = Re(eigen(Jacob)$values[7]),
                                                             maxEv = max(Re(base::eigen(Jacob)$values)),
                                                             stable = stable,
                                                             biosense = AlongEq_d1$biosense[i]))
  
  # browser()
}

StabCheck_Along_d1$stable <- as.factor(StabCheck_Along_d1$stable)

# separate unstable equilibria to work with later
Along_d1_Unstab <- subset(StabCheck_Along_d1, StabCheck_Along_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_d1_Unstab)/nrow(StabCheck_Along_d1))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Movement rate into Q

Generate sample values for _g_, leaving `0` out of the sampling interval to 
avoid instances of denominators being $\leq 0$.

```{r along-lsa-g-values-gen, echo=TRUE,tidy=TRUE}
DATA_along_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r along-lsa-g, echo=TRUE, tidy=TRUE}
AlongEq_g <- NULL

AlongEq_g <-rbind(AlongEq_g, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_along_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_along_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_g <- AlongEq_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check the results for stability.

```{r along-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Along_g <- NULL

for (i in 1:nrow(AlongEq_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_g$I1[i]
  I2 = AlongEq_g$I2[i]
  l = AlongEq_g$l[i]
  u1 = AlongEq_g$u1[i]
  u2 = AlongEq_g$u2[i]
  a1 = AlongEq_g$a1[i]
  a2 = AlongEq_g$a2[i]
  h1 = AlongEq_g$h1[i]
  h2 = AlongEq_g$h2[i]
  d1 = AlongEq_g$d1[i]
  d2 = AlongEq_g$d2[i]
  g = AlongEq_g$g[i]
  m = AlongEq_g$m[i]
  c = AlongEq_g$c[i]
  e1 = AlongEq_g$e1[i]
  e2 = AlongEq_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_g$Q[i]
  dN1 = AlongEq_g$N1[i]
  dP1 = AlongEq_g$P1[i]
  dC1 = AlongEq_g$C1[i]
  dN2 = AlongEq_g$N2[i]
  dP2 = AlongEq_g$P2[i]
  dC2 = AlongEq_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Along_g<- rbind(StabCheck_Along_g, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                             h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                             dC1, dN2, dP2, dC2,
                                                             EiV1 = Re(eigen(Jacob)$values[1]),
                                                             EiV2 = Re(eigen(Jacob)$values[2]),
                                                             EiV3 = Re(eigen(Jacob)$values[3]),
                                                             EiV4 = Re(eigen(Jacob)$values[4]),
                                                             EiV5 = Re(eigen(Jacob)$values[5]),
                                                             EiV6 = Re(eigen(Jacob)$values[6]),
                                                             EiV7 = Re(eigen(Jacob)$values[7]),
                                                             maxEv = max(Re(base::eigen(Jacob)$values)),
                                                             stable = stable,
                                                             biosense = AlongEq_g$biosense[i]))
  
  # browser()
}

StabCheck_Along_g$stable <- as.factor(StabCheck_Along_g$stable)

# separate unstable equilibria to work with later
Along_g_Unstab <- subset(StabCheck_Along_g, StabCheck_Along_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_g_Unstab)/nrow(StabCheck_Along_g))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Movement rate from Q

Start by generating values for _m_, avoiding `0` as it may lead to some 
denominators being $\leq 0$.

```{r along-lsa-m-values-gen, echo=TRUE,tidy=TRUE}
DATA_along_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Run the LSA.

```{r along-lsa-m, echo=TRUE,tidy=TRUE}
AlongEq_m <- NULL

AlongEq_m <-rbind(AlongEq_m, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_along_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_along_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so
# let's flag them

AlongEq_m <- AlongEq_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then test the results for stability, since the values we used to generate 
these results may not have been included in the random samples used above for 
the model's numerical analyses.

```{r along-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Along_m <- NULL

for (i in 1:nrow(AlongEq_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_m$I1[i]
  I2 = AlongEq_m$I2[i]
  l = AlongEq_m$l[i]
  u1 = AlongEq_m$u1[i]
  u2 = AlongEq_m$u2[i]
  a1 = AlongEq_m$a1[i]
  a2 = AlongEq_m$a2[i]
  h1 = AlongEq_m$h1[i]
  h2 = AlongEq_m$h2[i]
  d1 = AlongEq_m$d1[i]
  d2 = AlongEq_m$d2[i]
  g = AlongEq_m$g[i]
  m = AlongEq_m$m[i]
  c = AlongEq_m$c[i]
  e1 = AlongEq_m$e1[i]
  e2 = AlongEq_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_m$Q[i]
  dN1 = AlongEq_m$N1[i]
  dP1 = AlongEq_m$P1[i]
  dC1 = AlongEq_m$C1[i]
  dN2 = AlongEq_m$N2[i]
  dP2 = AlongEq_m$P2[i]
  dC2 = AlongEq_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Along_m<- rbind(StabCheck_Along_m, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                          h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                          dC1, dN2, dP2, dC2,
                                                          EiV1 = Re(eigen(Jacob)$values[1]),
                                                          EiV2 = Re(eigen(Jacob)$values[2]),
                                                          EiV3 = Re(eigen(Jacob)$values[3]),
                                                          EiV4 = Re(eigen(Jacob)$values[4]),
                                                          EiV5 = Re(eigen(Jacob)$values[5]),
                                                          EiV6 = Re(eigen(Jacob)$values[6]),
                                                          EiV7 = Re(eigen(Jacob)$values[7]),
                                                          maxEv = max(Re(base::eigen(Jacob)$values)),
                                                          stable = stable,
                                                          biosense = AlongEq_m$biosense[i]))
  
  # browser()
}

StabCheck_Along_m$stable <- as.factor(StabCheck_Along_m$stable)

# separate unstable equilibria to work with later
Along_m_Unstab <- subset(StabCheck_Along_m, StabCheck_Along_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_m_Unstab)/nrow(StabCheck_Along_m))*100, digits = 3)`** parameter sets appear to be unstable.
:::

::: {.panel}

#### Death rate in Q

Begin by sampling values to assign to _c_, excluding `0` from the sampling 
interval to avoid denominators going $\leq 0$.

```{r along-lsa-c-values-gen, echo=TRUE, tidy=TRUE}
DATA_along_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r along-lsa-c, echo=TRUE, tidy=TRUE}
AlongEq_c <- NULL

AlongEq_c <-rbind(AlongEq_c, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_along_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_along_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_c <- AlongEq_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

And, finally, check for stability of the model's results just produced.

```{r along-lsa-c-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Along_c <- NULL

for (i in 1:nrow(AlongEq_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_c$I1[i]
  I2 = AlongEq_c$I2[i]
  l = AlongEq_c$l[i]
  u1 = AlongEq_c$u1[i]
  u2 = AlongEq_c$u2[i]
  a1 = AlongEq_c$a1[i]
  a2 = AlongEq_c$a2[i]
  h1 = AlongEq_c$h1[i]
  h2 = AlongEq_c$h2[i]
  d1 = AlongEq_c$d1[i]
  d2 = AlongEq_c$d2[i]
  g = AlongEq_c$g[i]
  m = AlongEq_c$m[i]
  c = AlongEq_c$c[i]
  e1 = AlongEq_c$e1[i]
  e2 = AlongEq_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_c$Q[i]
  dN1 = AlongEq_c$N1[i]
  dP1 = AlongEq_c$P1[i]
  dC1 = AlongEq_c$C1[i]
  dN2 = AlongEq_c$N2[i]
  dP2 = AlongEq_c$P2[i]
  dC2 = AlongEq_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Along_c <- rbind(StabCheck_Along_c, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                          h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                          dC1, dN2, dP2, dC2,
                                                          EiV1 = Re(eigen(Jacob)$values[1]),
                                                          EiV2 = Re(eigen(Jacob)$values[2]),
                                                          EiV3 = Re(eigen(Jacob)$values[3]),
                                                          EiV4 = Re(eigen(Jacob)$values[4]),
                                                          EiV5 = Re(eigen(Jacob)$values[5]),
                                                          EiV6 = Re(eigen(Jacob)$values[6]),
                                                          EiV7 = Re(eigen(Jacob)$values[7]),
                                                          maxEv = max(Re(base::eigen(Jacob)$values)),
                                                          stable = stable,
                                                          biosense = AlongEq_c$biosense[i]))
  
  # browser()
}

StabCheck_Along_c$stable <- as.factor(StabCheck_Along_c$stable)

# separate unstable equilibria to work with later
Along_c_Unstab <- subset(StabCheck_Along_c, StabCheck_Along_c$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_c_Unstab)/nrow(StabCheck_Along_c))*100, digits = 3)`** parameter sets appear to be unstable.
:::

:::::

### Against-gradient scenario

Begin by removing the along-gradient mean parameter values and storing this 
scenario's mean parameter values in named objects to use in local sensitivity 
analysis run below.

```{r against-lsa-mean-params, echo=TRUE, tidy=TRUE}
rm(list = c('I1_m', 'I2_m', 'l_m', 'a1_m', 'a2_m', 'u1_m', 'u2_m', 'h1_m', 
            'h2_m', 'd1_m', 'd2_m', 'g_m', 'c_m', 'm_m', 'e1_m', 'e2_m'))

I1_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(I1) %>% mean()
I2_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(I2) %>% mean()
l_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(l) %>% mean()
a1_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(a1) %>% mean()
a2_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(a2) %>% mean()
u1_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(u1) %>% mean()
u2_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(u2) %>% mean()
h1_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(h1) %>% mean()
h2_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(h2) %>% mean()
d1_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(d1) %>% mean()
d2_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(d2) %>% mean()
g_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(g) %>% mean()
m_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(m) %>% mean()
c_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(c) %>% mean()
e1_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(e1) %>% mean()
e2_m <- PREDI1 %>% filter(., stable == "stable") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

#### Attack rate in Ecosystem 1

As with all other runs, start by sampling values for _a~1~_, excluding `0` to 
avoid negative or null denominators.

```{r against-lsa-a1-values-gen, echo=TRUE,tidy=TRUE}
DATA_against_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Run the LSA.

```{r against-lsa-a1, echo=TRUE,tidy=TRUE}
AgainstEq_a1 <- NULL

AgainstEq_a1 <-rbind(AgainstEq_a1, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_against_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_against_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AgainstEq_a1 <- AgainstEq_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability of the results.

```{r against-lsa-a1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_Against_a1 <- NULL

for (i in 1:nrow(AgainstEq_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_a1$I1[i]
  I2 = AgainstEq_a1$I2[i]
  l = AgainstEq_a1$l[i]
  u1 = AgainstEq_a1$u1[i]
  u2 = AgainstEq_a1$u2[i]
  a1 = AgainstEq_a1$a1[i]
  a2 = AgainstEq_a1$a2[i]
  h1 = AgainstEq_a1$h1[i]
  h2 = AgainstEq_a1$h2[i]
  d1 = AgainstEq_a1$d1[i]
  d2 = AgainstEq_a1$d2[i]
  g = AgainstEq_a1$g[i]
  m = AgainstEq_a1$m[i]
  c = AgainstEq_a1$c[i]
  e1 = AgainstEq_a1$e1[i]
  e2 = AgainstEq_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_a1$Q[i]
  dN1 = AgainstEq_a1$N1[i]
  dP1 = AgainstEq_a1$P1[i]
  dC1 = AgainstEq_a1$C1[i]
  dN2 = AgainstEq_a1$N2[i]
  dP2 = AgainstEq_a1$P2[i]
  dC2 = AgainstEq_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Against_a1 <- rbind(StabCheck_Against_a1, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                           h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                           dC1, dN2, dP2, dC2,
                                                           EiV1 = Re(eigen(Jacob)$values[1]),
                                                           EiV2 = Re(eigen(Jacob)$values[2]),
                                                           EiV3 = Re(eigen(Jacob)$values[3]),
                                                           EiV4 = Re(eigen(Jacob)$values[4]),
                                                           EiV5 = Re(eigen(Jacob)$values[5]),
                                                           EiV6 = Re(eigen(Jacob)$values[6]),
                                                           EiV7 = Re(eigen(Jacob)$values[7]),
                                                           maxEv = max(Re(base::eigen(Jacob)$values)),
                                                           stable = stable,
                                                           biosense = AgainstEq_a1$biosense[i]))
  
  # browser()
}

StabCheck_Against_a1$stable <- as.factor(StabCheck_Against_a1$stable)

# separate unstable equilibria to work with later
Against_a1_Unstab <- subset(StabCheck_Against_a1, StabCheck_Against_a1$stable == "unstable")

rm(Jacob)

```

**`r prettyNum((nrow(Against_a1_Unstab)/nrow(StabCheck_Against_a1))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Death rate in Ecosystem 1

Start by sampling values for _d~1~_, leaving `0` to avoid negative or null
denominators. 

```{r against-lsa-d1-values-gen, echo=TRUE, tidy=TRUE}
DATA_against_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r against-lsa-d1, echo=TRUE, tidy=TRUE}
AgainstEq_d1 <- NULL

AgainstEq_d1 <-rbind(AgainstEq_d1, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_against_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_against_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AgainstEq_d1 <- AgainstEq_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check the results for stability.

```{r against-lsa-d1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_Against_d1 <- NULL

for (i in 1:nrow(AgainstEq_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_d1$I1[i]
  I2 = AgainstEq_d1$I2[i]
  l = AgainstEq_d1$l[i]
  u1 = AgainstEq_d1$u1[i]
  u2 = AgainstEq_d1$u2[i]
  a1 = AgainstEq_d1$a1[i]
  a2 = AgainstEq_d1$a2[i]
  h1 = AgainstEq_d1$h1[i]
  h2 = AgainstEq_d1$h2[i]
  d1 = AgainstEq_d1$d1[i]
  d2 = AgainstEq_d1$d2[i]
  g = AgainstEq_d1$g[i]
  m = AgainstEq_d1$m[i]
  c = AgainstEq_d1$c[i]
  e1 = AgainstEq_d1$e1[i]
  e2 = AgainstEq_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_d1$Q[i]
  dN1 = AgainstEq_d1$N1[i]
  dP1 = AgainstEq_d1$P1[i]
  dC1 = AgainstEq_d1$C1[i]
  dN2 = AgainstEq_d1$N2[i]
  dP2 = AgainstEq_d1$P2[i]
  dC2 = AgainstEq_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Against_d1 <- rbind(StabCheck_Against_d1, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                                 h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                                 dC1, dN2, dP2, dC2,
                                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                                 stable = stable,
                                                                 biosense = AgainstEq_d1$biosense[i]))
  
  # browser()
}

StabCheck_Against_d1$stable <- as.factor(StabCheck_Against_d1$stable)

# separate unstable equilibria to work with later
Against_d1_Unstab <- subset(StabCheck_Against_d1, StabCheck_Against_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_d1_Unstab)/nrow(StabCheck_Against_d1))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Movement rate into Q

Sample values of _g_ first, leaving `0` out to avoid denominators being $leq 0$.

```{r against-lsa-g-values-gen, echo=TRUE, tidy=TRUE}
DATA_against_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, use the sampled values to run the LSA on the model, using mean values for
all other parameters.

```{r against-lsa-g, echo=TRUE,tidy=TRUE}
AgainstEq_g <- NULL

AgainstEq_g <-rbind(AgainstEq_g, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_against_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_against_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_g <- AgainstEq_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability of the LSA results.

```{r against-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Against_g <- NULL

for (i in 1:nrow(AgainstEq_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_g$I1[i]
  I2 = AgainstEq_g$I2[i]
  l = AgainstEq_g$l[i]
  u1 = AgainstEq_g$u1[i]
  u2 = AgainstEq_g$u2[i]
  a1 = AgainstEq_g$a1[i]
  a2 = AgainstEq_g$a2[i]
  h1 = AgainstEq_g$h1[i]
  h2 = AgainstEq_g$h2[i]
  d1 = AgainstEq_g$d1[i]
  d2 = AgainstEq_g$d2[i]
  g = AgainstEq_g$g[i]
  m = AgainstEq_g$m[i]
  c = AgainstEq_g$c[i]
  e1 = AgainstEq_g$e1[i]
  e2 = AgainstEq_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_g$Q[i]
  dN1 = AgainstEq_g$N1[i]
  dP1 = AgainstEq_g$P1[i]
  dC1 = AgainstEq_g$C1[i]
  dN2 = AgainstEq_g$N2[i]
  dP2 = AgainstEq_g$P2[i]
  dC2 = AgainstEq_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Against_g <- rbind(StabCheck_Against_g, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                                 h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                                 dC1, dN2, dP2, dC2,
                                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                                 stable = stable,
                                                                 biosense = AgainstEq_g$biosense[i]))
  
  # browser()
}

StabCheck_Against_g$stable <- as.factor(StabCheck_Against_g$stable)

# separate unstable equilibria to work with later
Against_g_Unstab <- subset(StabCheck_Against_g, StabCheck_Against_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_g_Unstab)/nrow(StabCheck_Against_g))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Movement rate from Q

Start by sampling values for _m_ in the `[0.01, 10]` interval. We exclude `0` to
avoid denominators that are $\leq 0$.

```{r against-lsa-m-values-gen, echo=TRUE, tidy=TRUE}
DATA_against_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, use these sampled values and the mean parameter values to run the LSA.

```{r against-lsa-m, echo=TRUE,tidy=TRUE}
AgainstEq_m <- NULL

AgainstEq_m <-rbind(AgainstEq_m, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_against_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_against_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_m <- AgainstEq_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability of the LSA results.

```{r against-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Against_m <- NULL

for (i in 1:nrow(AgainstEq_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_m$I1[i]
  I2 = AgainstEq_m$I2[i]
  l = AgainstEq_m$l[i]
  u1 = AgainstEq_m$u1[i]
  u2 = AgainstEq_m$u2[i]
  a1 = AgainstEq_m$a1[i]
  a2 = AgainstEq_m$a2[i]
  h1 = AgainstEq_m$h1[i]
  h2 = AgainstEq_m$h2[i]
  d1 = AgainstEq_m$d1[i]
  d2 = AgainstEq_m$d2[i]
  g = AgainstEq_m$g[i]
  m = AgainstEq_m$m[i]
  c = AgainstEq_m$c[i]
  e1 = AgainstEq_m$e1[i]
  e2 = AgainstEq_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_m$Q[i]
  dN1 = AgainstEq_m$N1[i]
  dP1 = AgainstEq_m$P1[i]
  dC1 = AgainstEq_m$C1[i]
  dN2 = AgainstEq_m$N2[i]
  dP2 = AgainstEq_m$P2[i]
  dC2 = AgainstEq_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Against_m <- rbind(StabCheck_Against_m, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                                 h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                                 dC1, dN2, dP2, dC2,
                                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                                 stable = stable,
                                                                 biosense = AgainstEq_m$biosense[i]))
  
  # browser()
}

StabCheck_Against_m$stable <- as.factor(StabCheck_Against_m$stable)

# separate unstable equilibria to work with later
Against_m_Unstab <- subset(StabCheck_Against_m, StabCheck_Against_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_m_Unstab)/nrow(StabCheck_Against_m))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

#### Death rate in Q

Start by sampling _c_ values in the `[0.01, 10]` interval, leaving `0` out to
avoid denominators going $\leq 0$.

```{r against-lsa-c-values-gen, echo=TRUE, tidy=TRUE}
DATA_against_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r against-lsa-c, echo=TRUE, tidy=TRUE}
AgainstEq_c <- NULL

AgainstEq_c <-rbind(AgainstEq_c, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_against_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_against_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_c <- AgainstEq_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then test the LSA results for stability.

```{r against-lsa-c-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_Against_c <- NULL

for (i in 1:nrow(AgainstEq_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_c$I1[i]
  I2 = AgainstEq_c$I2[i]
  l = AgainstEq_c$l[i]
  u1 = AgainstEq_c$u1[i]
  u2 = AgainstEq_c$u2[i]
  a1 = AgainstEq_c$a1[i]
  a2 = AgainstEq_c$a2[i]
  h1 = AgainstEq_c$h1[i]
  h2 = AgainstEq_c$h2[i]
  d1 = AgainstEq_c$d1[i]
  d2 = AgainstEq_c$d2[i]
  g = AgainstEq_c$g[i]
  m = AgainstEq_c$m[i]
  c = AgainstEq_c$c[i]
  e1 = AgainstEq_c$e1[i]
  e2 = AgainstEq_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_c$Q[i]
  dN1 = AgainstEq_c$N1[i]
  dP1 = AgainstEq_c$P1[i]
  dC1 = AgainstEq_c$C1[i]
  dN2 = AgainstEq_c$N2[i]
  dP2 = AgainstEq_c$P2[i]
  dC2 = AgainstEq_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not - if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Against_c <- rbind(StabCheck_Against_c, data.frame(TIME=i, I1, I2, l, u1, u2, a1, a2, h1,
                                                               h2, d1, d2, g, m, c, e1, e2, dQ, dN1, dP1,
                                                               dC1, dN2, dP2, dC2,
                                                               EiV1 = Re(eigen(Jacob)$values[1]),
                                                               EiV2 = Re(eigen(Jacob)$values[2]),
                                                               EiV3 = Re(eigen(Jacob)$values[3]),
                                                               EiV4 = Re(eigen(Jacob)$values[4]),
                                                               EiV5 = Re(eigen(Jacob)$values[5]),
                                                               EiV6 = Re(eigen(Jacob)$values[6]),
                                                               EiV7 = Re(eigen(Jacob)$values[7]),
                                                               maxEv = max(Re(base::eigen(Jacob)$values)),
                                                               stable = stable,
                                                               biosense = AgainstEq_c$biosense[i]))
  
  # browser()
}

StabCheck_Against_c$stable <- as.factor(StabCheck_Against_c$stable)

# separate unstable equilibria to work with later
Against_c_Unstab <- subset(StabCheck_Against_c, StabCheck_Against_c$stable == "unstable")

rm(Jacob)

rm(list = c('I1_m', 'I2_m', 'l_m', 'a1_m', 'a2_m', 'u1_m', 'u2_m', 'h1_m', 
            'h2_m', 'd1_m', 'd2_m', 'g_m', 'c_m', 'm_m', 'e1_m', 'e2_m'))
```

**`r prettyNum((nrow(Against_c_Unstab)/nrow(StabCheck_Against_c))*100, digits = 3)`** parameter sets appear to be unstable.

:::

:::::

## Sensitivity analyses by biomass distribution

Here, we repeat our local sensitivity analyses but we separate between parameter
sets that produce classical, pyramidal biomass distributions and those that 
produce inverted biomass distributions in the donor ecosystem 1 (sensu @McCauley2018). 

We differentiate between these two cases by selecting different slices of our 
comprehensive dataset `ecoCR` to calculate the mean parameter 
values used for all parameters other than the five focal ones; i.e., _a~1~_, 
_d~1~_, _g_, _m_, and _c_ (see the table in [State variables and parameters of the model]
or Table 1 in the Manuscript for definitions, units, and ranges).

We focus on how the influence of biomass distributions in the donor ecosystem 1 
as consumers movement in our meta-ecosystem is unidirectional, hence changes in
how biomass is distributed in the donor ecosystem 1 will likely reflect on 
the recipient ecosystem 2 and on the meta-ecosystem.

### Setup

First, we load the `ecoCR` object, and create two additional variables: 
`E1CRabove1` and `E2CRabove1`. Both these are categorical variables, with `Yes` 
or `No` values, and capture whether the local biomass distribution in the donor 
ecosystem 1 or in the recipient ecosystem 2 conforms to a classic bottom-heavy 
distribution or to an inverted, top-heavy distribution.

```{r LSA-setup, echo=TRUE, tidy=TRUE}
# load the data, then create additional categorical variables for plotting
ecoCR <- readRDS(file = "../Results/ecoCR.rds") %>% 
  mutate(.,
         E1CRabove1 = as_factor(ifelse(Eco1 > 1, "Y", "N")),
         E2CRabove1 = as_factor(ifelse(Eco2 > 1, "Y", "N")),
         Fertility = as_factor(Fertility))
```

#### Classical biomass distribution

Here, we run a LSA using only the values from the subset of entries in `ecoCR`
where the distribution of biomass in the donor ecosystem 1 conforms to a classical,
pyramidal shape. As before, we run one LSA per focal parameter, per consumer 
movement scenario.

##### Gradient-neutral scenario

As before, we first store the scenario's mean parameter values in named objects 
to use in the LSA runs below. Note that the code here has changed to select
from `ecoCR`, and then isolate only the parameter values for this scenario, that
are stable, and produce a bottom-heavy biomass distribution.

```{r cls-bm-grad-neutral-lsa-mean-params, echo=TRUE, tidy=TRUE}
I1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(I1) %>% mean()
I2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(I2) %>% mean()
l_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(l) %>% mean()
a1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(a1) %>% mean()
a2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(a2) %>% mean()
u1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(u1) %>% mean()
u2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(u2) %>% mean()
h1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(h1) %>% mean()
h2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(h2) %>% mean()
d1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(d1) %>% mean()
d2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(d2) %>% mean()
g_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(g) %>% mean()
m_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(m) %>% mean()
c_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(c) %>% mean()
e1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(e1) %>% mean()
e2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "N") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

###### Attack rate in Ecosystem 1

First, we generate values for the focal parameter, _a~1~_, in the [0.01, 10].

```{r cls-bm-grad-neutral-lsa-a1-value-gen, echo=TRUE, tidy=TRUE}
DATA_E1pyram_neutral_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, we run the LSA.

```{r cls-bm-grad-neutral-lsa-a1}
NeutralEq_E1pyram_a1 <- NULL

NeutralEq_E1pyram_a1 <-rbind(NeutralEq_E1pyram_a1, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_neutral_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_E1pyram_neutral_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1pyram_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, 
# so let's flag them

NeutralEq_E1pyram_a1 <- NeutralEq_E1pyram_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                                           .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then the local stability analysis.

```{r cls-bm-grad-neutral-lsa-a1-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Neutral_E1pyram_a1 <- NULL

# run the stability analysis loop
for (i in 1:nrow(NeutralEq_E1pyram_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1pyram_a1$I1[i]
  I2 = NeutralEq_E1pyram_a1$I2[i]
  l = NeutralEq_E1pyram_a1$l[i]
  u1 = NeutralEq_E1pyram_a1$u1[i]
  u2 = NeutralEq_E1pyram_a1$u2[i]
  a1 = NeutralEq_E1pyram_a1$a1[i]
  a2 = NeutralEq_E1pyram_a1$a2[i]
  h1 = NeutralEq_E1pyram_a1$h1[i]
  h2 = NeutralEq_E1pyram_a1$h2[i]
  d1 = NeutralEq_E1pyram_a1$d1[i]
  d2 = NeutralEq_E1pyram_a1$d2[i]
  g = NeutralEq_E1pyram_a1$g[i]
  m = NeutralEq_E1pyram_a1$m[i]
  c = NeutralEq_E1pyram_a1$c[i]
  e1 = NeutralEq_E1pyram_a1$e1[i]
  e2 = NeutralEq_E1pyram_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1pyram_a1$Q[i]
  dN1 = NeutralEq_E1pyram_a1$N1[i]
  dP1 = NeutralEq_E1pyram_a1$P1[i]
  dC1 = NeutralEq_E1pyram_a1$C1[i]
  dN2 = NeutralEq_E1pyram_a1$N2[i]
  dP2 = NeutralEq_E1pyram_a1$P2[i]
  dC2 = NeutralEq_E1pyram_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Neutral_E1pyram_a1 <- rbind(StabCheck_Neutral_E1pyram_a1, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2,
                                                   a1, a2, h1, h2, d1, d2, g,
                                                   m, c, e1, e2, dQ, dN1, dP1,
                                                   dC1, dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = NeutralEq_E1pyram_a1$biosense[i]))
  
  # browser()
}

StabCheck_Neutral_E1pyram_a1$stable <- as.factor(StabCheck_Neutral_E1pyram_a1$stable)

# separate unstable equilibria to work with later
Neutral_E1pyram_a1_Unstab <- subset(StabCheck_Neutral_E1pyram_a1, 
                                    StabCheck_Neutral_E1pyram_a1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1pyram_a1_Unstab)/nrow(StabCheck_Neutral_E1pyram_a1))*100, digits = 3)`** 
parameter sets produced unstable solutions.
:::

::: {.panel}

###### Death rate in Ecosystem 1

Following the same template as for _a~1~_, we start by generating values of _d~1~_.

```{r cls-bm-grad-neutral-lsa-d1-value-gen, echo=TRUE, tidy=TRUE}
DATA_E1pyram_neutral_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r cls-bm-grad-neutral-lsa-d1, echo=TRUE,tidy=TRUE}
NeutralEq_E1pyram_d1 <- NULL

NeutralEq_E1pyram_d1 <-rbind(NeutralEq_E1pyram_d1, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_neutral_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_E1pyram_neutral_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1pyram_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them 

NeutralEq_E1pyram_d1 <- NeutralEq_E1pyram_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability of the results from this new set of parameter 
values.

```{r cls-bm-grad-neutral-lsa-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Neutral_d1 <- NULL

for (i in 1:nrow(NeutralEq_E1pyram_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1pyram_d1$I1[i]
  I2 = NeutralEq_E1pyram_d1$I2[i]
  l = NeutralEq_E1pyram_d1$l[i]
  u1 = NeutralEq_E1pyram_d1$u1[i]
  u2 = NeutralEq_E1pyram_d1$u2[i]
  a1 = NeutralEq_E1pyram_d1$a1[i]
  a2 = NeutralEq_E1pyram_d1$a2[i]
  h1 = NeutralEq_E1pyram_a1$h1[i]
  h2 = NeutralEq_E1pyram_d1$h2[i]
  d1 = NeutralEq_E1pyram_d1$d1[i]
  d2 = NeutralEq_E1pyram_d1$d2[i]
  g = NeutralEq_E1pyram_d1$g[i]
  m = NeutralEq_E1pyram_d1$m[i]
  c = NeutralEq_E1pyram_d1$c[i]
  e1 = NeutralEq_E1pyram_d1$e1[i]
  e2 = NeutralEq_E1pyram_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1pyram_d1$Q[i]
  dN1 = NeutralEq_E1pyram_d1$N1[i]
  dP1 = NeutralEq_E1pyram_d1$P1[i]
  dC1 = NeutralEq_E1pyram_d1$C1[i]
  dN2 = NeutralEq_E1pyram_d1$N2[i]
  dP2 = NeutralEq_E1pyram_d1$P2[i]
  dC2 = NeutralEq_E1pyram_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Neutral_d1 <- rbind(StabCheck_E1pyram_Neutral_d1, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                   a1, a2, h1, h2, d1, d2, g,
                                                   m, c, e1, e2, dQ, dN1, dP1,
                                                   dC1, dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = NeutralEq_E1pyram_d1$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Neutral_d1$stable <- as.factor(StabCheck_E1pyram_Neutral_d1$stable)

# separate unstable equilibria to work with later
Neutral_E1pyram_d1_Unstab <- subset(StabCheck_E1pyram_Neutral_d1, 
                                    StabCheck_E1pyram_Neutral_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1pyram_d1_Unstab)/nrow(StabCheck_E1pyram_Neutral_d1))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate into Q

Sample values for _g_.

```{r cls-bm-grad-neutral-lsa-g-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1pyram_neutral_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r cls-bm-grad-neutral-lsa-g, echo=TRUE,tidy=TRUE}
NeutralEq_E1pyram_g <- NULL

NeutralEq_E1pyram_g <-rbind(NeutralEq_E1pyram_g, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_neutral_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_E1pyram_neutral_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1pyram_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

NeutralEq_E1pyram_g <- NeutralEq_E1pyram_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

As a final step, check for stability of this new set of parameter values.

```{r cls-bm-grad-neutral-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Neutral_g <- NULL

for (i in 1:nrow(NeutralEq_E1pyram_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1pyram_g$I1[i]
  I2 = NeutralEq_E1pyram_g$I2[i]
  l = NeutralEq_E1pyram_g$l[i]
  u1 = NeutralEq_E1pyram_g$u1[i]
  u2 = NeutralEq_E1pyram_g$u2[i]
  a1 = NeutralEq_E1pyram_g$a1[i]
  a2 = NeutralEq_E1pyram_g$a2[i]
  h1 = NeutralEq_E1pyram_g$h1[i]
  h2 = NeutralEq_E1pyram_g$h2[i]
  d1 = NeutralEq_E1pyram_g$d1[i]
  d2 = NeutralEq_E1pyram_g$d2[i]
  g = NeutralEq_E1pyram_g$g[i]
  m = NeutralEq_E1pyram_g$m[i]
  c = NeutralEq_E1pyram_g$c[i]
  e1 = NeutralEq_E1pyram_g$e1[i]
  e2 = NeutralEq_E1pyram_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1pyram_g$Q[i]
  dN1 = NeutralEq_E1pyram_g$N1[i]
  dP1 = NeutralEq_E1pyram_g$P1[i]
  dC1 = NeutralEq_E1pyram_g$C1[i]
  dN2 = NeutralEq_E1pyram_g$N2[i]
  dP2 = NeutralEq_E1pyram_g$P2[i]
  dC2 = NeutralEq_E1pyram_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Neutral_g <- rbind(StabCheck_E1pyram_Neutral_g, 
                                       data.frame(TIME=i, I1, I2, l, u1, u2,
                                                  a1, a2, h1, h2, d1, d2, g,
                                                  m, c, e1, e2, dQ, dN1, dP1,
                                                  dC1, dN2, dP2, dC2,
                                                  EiV1 = Re(eigen(Jacob)$values[1]),
                                                  EiV2 = Re(eigen(Jacob)$values[2]),
                                                  EiV3 = Re(eigen(Jacob)$values[3]),
                                                  EiV4 = Re(eigen(Jacob)$values[4]),
                                                  EiV5 = Re(eigen(Jacob)$values[5]),
                                                  EiV6 = Re(eigen(Jacob)$values[6]),
                                                  EiV7 = Re(eigen(Jacob)$values[7]),
                                                  maxEv = max(Re(base::eigen(Jacob)$values)),
                                                  stable = stable,
                                                  biosense = NeutralEq_E1pyram_g$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Neutral_g$stable <- as.factor(StabCheck_E1pyram_Neutral_g$stable)

# separate unstable equilibria to work with later
Neutral_E1pyram_g_Unstab <- subset(StabCheck_E1pyram_Neutral_g, 
                                   StabCheck_E1pyram_Neutral_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1pyram_g_Unstab)/nrow(StabCheck_E1pyram_Neutral_g))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate from Q

The code chunk below produces values for _m_.

```{r cls-bm-grad-neutral-lsa-m-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1pyram_neutral_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

This one runs the LSA.

```{r cls-bm-grad-neutral-lsa-m, echo=TRUE,tidy=TRUE}
NeutralEq_E1pyram_m <- NULL

NeutralEq_E1pyram_m <-rbind(NeutralEq_E1pyram_m, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_neutral_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_E1pyram_neutral_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1pyram_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

NeutralEq_E1pyram_m <- NeutralEq_E1pyram_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

And the next one wraps it up with a stability check.

```{r cls-bm-grad-neutral-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Neutral_m <- NULL

for (i in 1:nrow(NeutralEq_E1pyram_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1pyram_m$I1[i]
  I2 = NeutralEq_E1pyram_m$I2[i]
  l = NeutralEq_E1pyram_m$l[i]
  u1 = NeutralEq_E1pyram_m$u1[i]
  u2 = NeutralEq_E1pyram_m$u2[i]
  a1 = NeutralEq_E1pyram_m$a1[i]
  a2 = NeutralEq_E1pyram_m$a2[i]
  h1 = NeutralEq_E1pyram_m$h1[i]
  h2 = NeutralEq_E1pyram_m$h2[i]
  d1 = NeutralEq_E1pyram_m$d1[i]
  d2 = NeutralEq_E1pyram_m$d2[i]
  g = NeutralEq_E1pyram_m$g[i]
  m = NeutralEq_E1pyram_m$m[i]
  c = NeutralEq_E1pyram_m$c[i]
  e1 = NeutralEq_E1pyram_m$e1[i]
  e2 = NeutralEq_E1pyram_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1pyram_m$Q[i]
  dN1 = NeutralEq_E1pyram_m$N1[i]
  dP1 = NeutralEq_E1pyram_m$P1[i]
  dC1 = NeutralEq_E1pyram_m$C1[i]
  dN2 = NeutralEq_E1pyram_m$N2[i]
  dP2 = NeutralEq_E1pyram_m$P2[i]
  dC2 = NeutralEq_E1pyram_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Neutral_m <- rbind(StabCheck_E1pyram_Neutral_m, 
                                       data.frame(TIME=i, I1, I2, l, u1, u2,
                                                  a1, a2, h1, h2, d1, d2, g,
                                                  m, c, e1, e2, dQ, dN1, dP1,
                                                  dC1, dN2, dP2, dC2,
                                                  EiV1 = Re(eigen(Jacob)$values[1]),
                                                  EiV2 = Re(eigen(Jacob)$values[2]),
                                                  EiV3 = Re(eigen(Jacob)$values[3]),
                                                  EiV4 = Re(eigen(Jacob)$values[4]),
                                                  EiV5 = Re(eigen(Jacob)$values[5]),
                                                  EiV6 = Re(eigen(Jacob)$values[6]),
                                                  EiV7 = Re(eigen(Jacob)$values[7]),
                                                  maxEv = max(Re(base::eigen(Jacob)$values)),
                                                  stable = stable,
                                                  biosense = NeutralEq_E1pyram_m$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Neutral_m$stable <- as.factor(StabCheck_E1pyram_Neutral_m$stable)

# separate unstable equilibria to work with later
Neutral_E1pyram_m_Unstab <- subset(StabCheck_E1pyram_Neutral_m, 
                                   StabCheck_E1pyram_Neutral_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1pyram_m_Unstab)/nrow(StabCheck_E1pyram_Neutral_m))*100, digits = 3)`** 
parameter sets appear to be unstable.
:::

::: {.panel}

###### Death rate in Q

First, sample values for _c_.

```{r cls-bm-grad-neutral-lsa-c-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1pyram_neutral_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r cls-bm-grad-neutral-lsa-c, echo=TRUE,tidy=TRUE}
NeutralEq_E1pyram_c <- NULL

NeutralEq_E1pyram_c <-rbind(NeutralEq_E1pyram_c, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_neutral_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_E1pyram_neutral_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1pyram_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

NeutralEq_E1pyram_c <- NeutralEq_E1pyram_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability.

```{r cls-bm-grad-neutral-lsa-c-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Neutral_c <- NULL

for (i in 1:nrow(NeutralEq_E1pyram_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1pyram_c$I1[i]
  I2 = NeutralEq_E1pyram_c$I2[i]
  l = NeutralEq_E1pyram_c$l[i]
  u1 = NeutralEq_E1pyram_c$u1[i]
  u2 = NeutralEq_E1pyram_c$u2[i]
  a1 = NeutralEq_E1pyram_c$a1[i]
  a2 = NeutralEq_E1pyram_c$a2[i]
  h1 = NeutralEq_E1pyram_c$h1[i]
  h2 = NeutralEq_E1pyram_c$h2[i]
  d1 = NeutralEq_E1pyram_c$d1[i]
  d2 = NeutralEq_E1pyram_c$d2[i]
  g = NeutralEq_E1pyram_c$g[i]
  m = NeutralEq_E1pyram_c$m[i]
  c = NeutralEq_E1pyram_c$c[i]
  e1 = NeutralEq_E1pyram_c$e1[i]
  e2 = NeutralEq_E1pyram_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1pyram_c$Q[i]
  dN1 = NeutralEq_E1pyram_c$N1[i]
  dP1 = NeutralEq_E1pyram_c$P1[i]
  dC1 = NeutralEq_E1pyram_c$C1[i]
  dN2 = NeutralEq_E1pyram_c$N2[i]
  dP2 = NeutralEq_E1pyram_c$P2[i]
  dC2 = NeutralEq_E1pyram_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Neutral_c <- rbind(StabCheck_E1pyram_Neutral_c, 
                                       data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                  a1, a2, h1, h2, d1, d2, g, 
                                                  m, c, e1, e2, dQ, dN1, dP1,
                                                  dC1, dN2, dP2, dC2,
                                                  EiV1 = Re(eigen(Jacob)$values[1]),
                                                  EiV2 = Re(eigen(Jacob)$values[2]),
                                                  EiV3 = Re(eigen(Jacob)$values[3]),
                                                  EiV4 = Re(eigen(Jacob)$values[4]),
                                                  EiV5 = Re(eigen(Jacob)$values[5]),
                                                  EiV6 = Re(eigen(Jacob)$values[6]),
                                                  EiV7 = Re(eigen(Jacob)$values[7]),
                                                  maxEv = max(Re(base::eigen(Jacob)$values)),
                                                  stable = stable,
                                                  biosense = NeutralEq_E1pyram_c$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Neutral_c$stable <- as.factor(StabCheck_E1pyram_Neutral_c$stable)

# separate unstable equilibria to work with later
Neutral_E1pyram_c_Unstab <- subset(StabCheck_E1pyram_Neutral_c, 
                                   StabCheck_E1pyram_Neutral_c$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1pyram_c_Unstab)/nrow(StabCheck_E1pyram_Neutral_c))*100, digits = 3)`** 
parameter sets appear to be unstable.
:::

:::::

##### Along-gradient scenario

This section and the next one follow the same template as the one immediately 
above. First, remove the objects containing the mean parameter values for the 
non-focal parameters. Then, for each focal parameter, (i) sample the `[0.01, 10]`
interval for values, (ii) run the LSA, and (iii) check for stability.

```{r cls-bm-along-lsa-mean-params, echo=TRUE, tidy=TRUE}
rm(list = c('I1_m', 'I2_m', 'l_m', 'a1_m', 'a2_m', 'u1_m', 'u2_m', 'h1_m', 
            'h2_m', 'd1_m', 'd2_m', 'g_m', 'c_m', 'm_m', 'e1_m', 'e2_m'))

I1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(I1) %>% mean()
I2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(I2) %>% mean()
l_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(l) %>% mean()
a1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(a1) %>% mean()
a2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(a2) %>% mean()
u1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(u1) %>% mean()
u2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(u2) %>% mean()
h1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(h1) %>% mean()
h2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(h2) %>% mean()
d1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(d1) %>% mean()
d2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(d2) %>% mean()
g_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(g) %>% mean()
m_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(m) %>% mean()
c_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(c) %>% mean()
e1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(e1) %>% mean()
e2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "N") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

###### Attack rate in Ecosystem 1

Sample values for _a~1~_.

```{r cls-bm-along-lsa-a1-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1pyram_along_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r cls-bm-along-lsa-a1, echo=TRUE, tidy=TRUE}
AlongEq_E1pyram_a1 <- NULL

AlongEq_E1pyram_a1 <-rbind(AlongEq_E1pyram_a1, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_along_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_E1pyram_along_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1pyram_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                       # Nutrient stock in ecosystem 1
                       ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary Producers biomass in ecosystem 1
                       (d1+g)/(a1*e1),
                       # Consumers biomass in ecosystem 1
                       (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Nutrient stock in ecosystem 2
                       (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                       # Primary Producers biomass in ecosystem 2
                       (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Consumer biomass in ecosystem 2
                       ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Consumer biomass in the Dispersers' Pool (Q)
                       (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Nutrient flux for primary producers in Ecosystem 1
                       ((d1+g)*h1)/(a1*e1),
                       # Nutrient flux for consumers in Ecosystem 1
                       (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                       # Nutrient flux for primary producers in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Nutrient flux for consumers in Ecosystem 2
                       (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Total flux in Ecosystem 1
                       (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Total flux in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Nutrient flux in the Dispersers' Pool
                       (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Primary productivity in Ecosystem 1
                       ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Secondary (=consumers) productivity in Ecosystem 1
                       (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary productivity in Ecosystem 2
                       ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                       # Secondary (=consumer) productivity in Ecosystem 2
                       (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_E1pyram_a1 <- AlongEq_E1pyram_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check the result for stability.

```{r cls-bm-along-lsa-a1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Along_a1 <- NULL

for (i in 1:nrow(AlongEq_E1pyram_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1pyram_a1$I1[i]
  I2 = AlongEq_E1pyram_a1$I2[i]
  l = AlongEq_E1pyram_a1$l[i]
  u1 = AlongEq_E1pyram_a1$u1[i]
  u2 = AlongEq_E1pyram_a1$u2[i]
  a1 = AlongEq_E1pyram_a1$a1[i]
  a2 = AlongEq_E1pyram_a1$a2[i]
  h1 = AlongEq_E1pyram_a1$h1[i]
  h2 = AlongEq_E1pyram_a1$h2[i]
  d1 = AlongEq_E1pyram_a1$d1[i]
  d2 = AlongEq_E1pyram_a1$d2[i]
  g = AlongEq_E1pyram_a1$g[i]
  m = AlongEq_E1pyram_a1$m[i]
  c = AlongEq_E1pyram_a1$c[i]
  e1 = AlongEq_E1pyram_a1$e1[i]
  e2 = AlongEq_E1pyram_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1pyram_a1$Q[i]
  dN1 = AlongEq_E1pyram_a1$N1[i]
  dP1 = AlongEq_E1pyram_a1$P1[i]
  dC1 = AlongEq_E1pyram_a1$C1[i]
  dN2 = AlongEq_E1pyram_a1$N2[i]
  dP2 = AlongEq_E1pyram_a1$P2[i]
  dC2 = AlongEq_E1pyram_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Along_a1 <- rbind(StabCheck_E1pyram_Along_a1, 
                                      data.frame(TIME=i, I1, I2, l, u1, u2,
                                                 a1, a2, h1, h2, d1, d2, g,
                                                 m, c, e1, e2, dQ, dN1, dP1,
                                                 dC1, dN2, dP2, dC2, 
                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                 stable = stable,
                                                 biosense = AlongEq_E1pyram_a1$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Along_a1$stable <- as.factor(StabCheck_E1pyram_Along_a1$stable)

# separate unstable equilibria to work with later
Along_E1pyram_a1_Unstab <- subset(StabCheck_E1pyram_Along_a1, 
                                  StabCheck_E1pyram_Along_a1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1pyram_a1_Unstab)/nrow(StabCheck_E1pyram_Along_a1))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

###### Death rate in Ecosystem 1

Start by sampling values for _d~1~_.

```{r cls-bm-along-lsa-d1-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1pyram_along_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r cls-bm-along-lsa-d1, echo=TRUE,tidy=TRUE}
AlongEq_E1pyram_d1 <- NULL

AlongEq_E1pyram_d1 <-rbind(AlongEq_E1pyram_d1, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_along_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_E1pyram_along_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1pyram_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                       # Nutrient stock in ecosystem 1
                       ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary Producers biomass in ecosystem 1
                       (d1+g)/(a1*e1),
                       # Consumers biomass in ecosystem 1
                       (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Nutrient stock in ecosystem 2
                       (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                       # Primary Producers biomass in ecosystem 2
                       (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Consumer biomass in ecosystem 2
                       ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Consumer biomass in the Dispersers' Pool (Q)
                       (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Nutrient flux for primary producers in Ecosystem 1
                       ((d1+g)*h1)/(a1*e1),
                       # Nutrient flux for consumers in Ecosystem 1
                       (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                       # Nutrient flux for primary producers in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Nutrient flux for consumers in Ecosystem 2
                       (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Total flux in Ecosystem 1
                       (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Total flux in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Nutrient flux in the Dispersers' Pool
                       (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Primary productivity in Ecosystem 1
                       ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Secondary (=consumers) productivity in Ecosystem 1
                       (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary productivity in Ecosystem 2
                       ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                       # Secondary (=consumer) productivity in Ecosystem 2
                       (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_E1pyram_d1 <- AlongEq_E1pyram_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability.

```{r cls-bm-along-lsa-d1-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Along_d1 <- NULL

for (i in 1:nrow(AlongEq_E1pyram_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1pyram_d1$I1[i]
  I2 = AlongEq_E1pyram_d1$I2[i]
  l = AlongEq_E1pyram_d1$l[i]
  u1 = AlongEq_E1pyram_d1$u1[i]
  u2 = AlongEq_E1pyram_d1$u2[i]
  a1 = AlongEq_E1pyram_d1$a1[i]
  a2 = AlongEq_E1pyram_d1$a2[i]
  h1 = AlongEq_E1pyram_d1$h1[i]
  h2 = AlongEq_E1pyram_d1$h2[i]
  d1 = AlongEq_E1pyram_d1$d1[i]
  d2 = AlongEq_E1pyram_d1$d2[i]
  g = AlongEq_E1pyram_d1$g[i]
  m = AlongEq_E1pyram_d1$m[i]
  c = AlongEq_E1pyram_d1$c[i]
  e1 = AlongEq_E1pyram_d1$e1[i]
  e2 = AlongEq_E1pyram_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1pyram_d1$Q[i]
  dN1 = AlongEq_E1pyram_d1$N1[i]
  dP1 = AlongEq_E1pyram_d1$P1[i]
  dC1 = AlongEq_E1pyram_d1$C1[i]
  dN2 = AlongEq_E1pyram_d1$N2[i]
  dP2 = AlongEq_E1pyram_d1$P2[i]
  dC2 = AlongEq_E1pyram_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Along_d1 <- rbind(StabCheck_E1pyram_Along_d1, 
                                      data.frame(TIME=i, I1, I2, l, u1, u2,
                                                 a1, a2, h1, h2, d1, d2, g,
                                                 m, c, e1, e2, dQ, dN1, dP1,
                                                 dC1, dN2, dP2, dC2,
                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                 stable = stable,
                                                 biosense = AlongEq_E1pyram_d1$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Along_d1$stable <- as.factor(StabCheck_E1pyram_Along_d1$stable)

# separate unstable equilibria to work with later
Along_E1pyram_d1_Unstab <- subset(StabCheck_E1pyram_Along_d1, 
                                  StabCheck_E1pyram_Along_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1pyram_d1_Unstab)/nrow(StabCheck_E1pyram_Along_d1))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate into Q

Generate sample values for _g_.

```{r cls-bm-along-lsa-g-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1pyram_along_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r cls-bm-along-lsa-g, echo=TRUE, tidy=TRUE}
AlongEq_E1pyram_g <- NULL

AlongEq_E1pyram_g <-rbind(AlongEq_E1pyram_g, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_along_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_E1pyram_along_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1pyram_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_E1pyram_g <- AlongEq_E1pyram_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check the results for stability.

```{r cls-bm-along-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Along_g <- NULL

for (i in 1:nrow(AlongEq_E1pyram_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1pyram_g$I1[i]
  I2 = AlongEq_E1pyram_g$I2[i]
  l = AlongEq_E1pyram_g$l[i]
  u1 = AlongEq_E1pyram_g$u1[i]
  u2 = AlongEq_E1pyram_g$u2[i]
  a1 = AlongEq_E1pyram_g$a1[i]
  a2 = AlongEq_E1pyram_g$a2[i]
  h1 = AlongEq_E1pyram_g$h1[i]
  h2 = AlongEq_E1pyram_g$h2[i]
  d1 = AlongEq_E1pyram_g$d1[i]
  d2 = AlongEq_E1pyram_g$d2[i]
  g = AlongEq_E1pyram_g$g[i]
  m = AlongEq_E1pyram_g$m[i]
  c = AlongEq_E1pyram_g$c[i]
  e1 = AlongEq_E1pyram_g$e1[i]
  e2 = AlongEq_E1pyram_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1pyram_g$Q[i]
  dN1 = AlongEq_E1pyram_g$N1[i]
  dP1 = AlongEq_E1pyram_g$P1[i]
  dC1 = AlongEq_E1pyram_g$C1[i]
  dN2 = AlongEq_E1pyram_g$N2[i]
  dP2 = AlongEq_E1pyram_g$P2[i]
  dC2 = AlongEq_E1pyram_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Along_g<- rbind(StabCheck_E1pyram_Along_g, 
                                    data.frame(TIME=i, I1, I2, l, u1, u2, 
                                               a1, a2, h1, h2, d1, d2, g, 
                                               m, c, e1, e2, dQ, dN1, dP1,
                                               dC1, dN2, dP2, dC2,
                                               EiV1 = Re(eigen(Jacob)$values[1]),
                                               EiV2 = Re(eigen(Jacob)$values[2]),
                                               EiV3 = Re(eigen(Jacob)$values[3]),
                                               EiV4 = Re(eigen(Jacob)$values[4]),
                                               EiV5 = Re(eigen(Jacob)$values[5]),
                                               EiV6 = Re(eigen(Jacob)$values[6]),
                                               EiV7 = Re(eigen(Jacob)$values[7]),
                                               maxEv = max(Re(base::eigen(Jacob)$values)),
                                               stable = stable,
                                               biosense = AlongEq_E1pyram_g$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Along_g$stable <- as.factor(StabCheck_E1pyram_Along_g$stable)

# separate unstable equilibria to work with later
Along_E1pyram_g_Unstab <- subset(StabCheck_E1pyram_Along_g, 
                                 StabCheck_E1pyram_Along_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1pyram_g_Unstab)/nrow(StabCheck_E1pyram_Along_g))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate from Q

Start by generating values for _m_.

```{r cls-bm-along-lsa-m-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1pyram_along_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Run the LSA.

```{r cls-bm-along-lsa-m, echo=TRUE,tidy=TRUE}
AlongEq_E1pyram_m <- NULL

AlongEq_E1pyram_m <-rbind(AlongEq_E1pyram_m, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_along_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_E1pyram_along_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1pyram_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so
# let's flag them

AlongEq_E1pyram_m <- AlongEq_E1pyram_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then test the results for stability.

```{r cls-bm-along-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Along_m <- NULL

for (i in 1:nrow(AlongEq_E1pyram_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1pyram_m$I1[i]
  I2 = AlongEq_E1pyram_m$I2[i]
  l = AlongEq_E1pyram_m$l[i]
  u1 = AlongEq_E1pyram_m$u1[i]
  u2 = AlongEq_E1pyram_m$u2[i]
  a1 = AlongEq_E1pyram_m$a1[i]
  a2 = AlongEq_E1pyram_m$a2[i]
  h1 = AlongEq_E1pyram_m$h1[i]
  h2 = AlongEq_E1pyram_m$h2[i]
  d1 = AlongEq_E1pyram_m$d1[i]
  d2 = AlongEq_E1pyram_m$d2[i]
  g = AlongEq_E1pyram_m$g[i]
  m = AlongEq_E1pyram_m$m[i]
  c = AlongEq_E1pyram_m$c[i]
  e1 = AlongEq_E1pyram_m$e1[i]
  e2 = AlongEq_E1pyram_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1pyram_m$Q[i]
  dN1 = AlongEq_E1pyram_m$N1[i]
  dP1 = AlongEq_E1pyram_m$P1[i]
  dC1 = AlongEq_E1pyram_m$C1[i]
  dN2 = AlongEq_E1pyram_m$N2[i]
  dP2 = AlongEq_E1pyram_m$P2[i]
  dC2 = AlongEq_E1pyram_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Along_m<- rbind(StabCheck_E1pyram_Along_m, 
                                    data.frame(TIME=i, I1, I2, l, u1, u2, 
                                               a1, a2, h1, h2, d1, d2, g,
                                               m, c, e1, e2, dQ, dN1, dP1,
                                               dC1, dN2, dP2, dC2,
                                               EiV1 = Re(eigen(Jacob)$values[1]),
                                               EiV2 = Re(eigen(Jacob)$values[2]),
                                               EiV3 = Re(eigen(Jacob)$values[3]),
                                               EiV4 = Re(eigen(Jacob)$values[4]),
                                               EiV5 = Re(eigen(Jacob)$values[5]),
                                               EiV6 = Re(eigen(Jacob)$values[6]),
                                               EiV7 = Re(eigen(Jacob)$values[7]),
                                               maxEv = max(Re(base::eigen(Jacob)$values)),
                                               stable = stable,
                                               biosense = AlongEq_E1pyram_m$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Along_m$stable <- as.factor(StabCheck_E1pyram_Along_m$stable)

# separate unstable equilibria to work with later
Along_E1pyram_m_Unstab <- subset(StabCheck_E1pyram_Along_m, 
                                 StabCheck_E1pyram_Along_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1pyram_m_Unstab)/nrow(StabCheck_E1pyram_Along_m))*100, digits = 3)`** parameter sets appear to be unstable.
:::

::: {.panel}

###### Death rate in Q

Begin by sampling values to assign to _c_.

```{r cls-bm-along-lsa-c-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1pyram_along_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r cls-bm-along-lsa-c, echo=TRUE, tidy=TRUE}
AlongEq_E1pyram_c <- NULL

AlongEq_E1pyram_c <-rbind(AlongEq_E1pyram_c, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_along_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_E1pyram_along_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1pyram_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_E1pyram_c <- AlongEq_E1pyram_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

And, finally, check for stability.

```{r cls-bm-along-lsa-c-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Along_c <- NULL

for (i in 1:nrow(AlongEq_E1pyram_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1pyram_c$I1[i]
  I2 = AlongEq_E1pyram_c$I2[i]
  l = AlongEq_E1pyram_c$l[i]
  u1 = AlongEq_E1pyram_c$u1[i]
  u2 = AlongEq_E1pyram_c$u2[i]
  a1 = AlongEq_E1pyram_c$a1[i]
  a2 = AlongEq_E1pyram_c$a2[i]
  h1 = AlongEq_E1pyram_c$h1[i]
  h2 = AlongEq_E1pyram_c$h2[i]
  d1 = AlongEq_E1pyram_c$d1[i]
  d2 = AlongEq_E1pyram_c$d2[i]
  g = AlongEq_E1pyram_c$g[i]
  m = AlongEq_E1pyram_c$m[i]
  c = AlongEq_E1pyram_c$c[i]
  e1 = AlongEq_E1pyram_c$e1[i]
  e2 = AlongEq_E1pyram_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1pyram_c$Q[i]
  dN1 = AlongEq_E1pyram_c$N1[i]
  dP1 = AlongEq_E1pyram_c$P1[i]
  dC1 = AlongEq_E1pyram_c$C1[i]
  dN2 = AlongEq_E1pyram_c$N2[i]
  dP2 = AlongEq_E1pyram_c$P2[i]
  dC2 = AlongEq_E1pyram_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Along_c <- rbind(StabCheck_E1pyram_Along_c, 
                                     data.frame(TIME=i, I1, I2, l, u1, u2,
                                                a1, a2, h1, h2, d1, d2, g, 
                                                m, c, e1, e2, dQ, dN1, dP1,
                                                dC1, dN2, dP2, dC2,
                                                EiV1 = Re(eigen(Jacob)$values[1]),
                                                EiV2 = Re(eigen(Jacob)$values[2]),
                                                EiV3 = Re(eigen(Jacob)$values[3]),
                                                EiV4 = Re(eigen(Jacob)$values[4]),
                                                EiV5 = Re(eigen(Jacob)$values[5]),
                                                EiV6 = Re(eigen(Jacob)$values[6]),
                                                EiV7 = Re(eigen(Jacob)$values[7]),
                                                maxEv = max(Re(base::eigen(Jacob)$values)),
                                                stable = stable,
                                                biosense = AlongEq_E1pyram_c$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Along_c$stable <- as.factor(StabCheck_E1pyram_Along_c$stable)

# separate unstable equilibria to work with later
Along_E1pyram_c_Unstab <- subset(StabCheck_E1pyram_Along_c, 
                                 StabCheck_E1pyram_Along_c$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1pyram_c_Unstab)/nrow(StabCheck_E1pyram_Along_c))*100, digits = 3)`** 
parameter sets appear to be unstable.
:::

:::::

##### Against-gradient scenario

Again, we follow the same template as above. Remove the previous scenario's 
non-focal parameter mean values, then store the ones for this movement scenario. 
Once that is done, for each focal parameter, (i) sample values in the 
`[0.01, 10]` interval, (ii) run the LSA, and (iii) test for stability.

```{r cls-bm-against-lsa-mean-params, echo=TRUE, tidy=TRUE}
rm(list = c('I1_m', 'I2_m', 'l_m', 'a1_m', 'a2_m', 'u1_m', 'u2_m', 'h1_m', 
            'h2_m', 'd1_m', 'd2_m', 'g_m', 'c_m', 'm_m', 'e1_m', 'e2_m'))

I1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(I1) %>% mean()
I2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(I2) %>% mean()
l_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(l) %>% mean()
a1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(a1) %>% mean()
a2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(a2) %>% mean()
u1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(u1) %>% mean()
u2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(u2) %>% mean()
h1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(h1) %>% mean()
h2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(h2) %>% mean()
d1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(d1) %>% mean()
d2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(d2) %>% mean()
g_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(g) %>% mean()
m_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(m) %>% mean()
c_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(c) %>% mean()
e1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(e1) %>% mean()
e2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "N") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

###### Attack rate in Ecosystem 1

As with all other runs, start by sampling values for _a~1~_,.

```{r cls-bm-against-lsa-a1-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1pyram_against_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Run the LSA.

```{r cls-bm-against-lsa-a1, echo=TRUE,tidy=TRUE}
AgainstEq_E1pyram_a1 <- NULL

AgainstEq_E1pyram_a1 <-rbind(AgainstEq_E1pyram_a1, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_against_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_E1pyram_against_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1pyram_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AgainstEq_E1pyram_a1 <- AgainstEq_E1pyram_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability.

```{r cls-bm-against-lsa-a1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Against_a1 <- NULL

for (i in 1:nrow(AgainstEq_E1pyram_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1pyram_a1$I1[i]
  I2 = AgainstEq_E1pyram_a1$I2[i]
  l = AgainstEq_E1pyram_a1$l[i]
  u1 = AgainstEq_E1pyram_a1$u1[i]
  u2 = AgainstEq_E1pyram_a1$u2[i]
  a1 = AgainstEq_E1pyram_a1$a1[i]
  a2 = AgainstEq_E1pyram_a1$a2[i]
  h1 = AgainstEq_E1pyram_a1$h1[i]
  h2 = AgainstEq_E1pyram_a1$h2[i]
  d1 = AgainstEq_E1pyram_a1$d1[i]
  d2 = AgainstEq_E1pyram_a1$d2[i]
  g = AgainstEq_E1pyram_a1$g[i]
  m = AgainstEq_E1pyram_a1$m[i]
  c = AgainstEq_E1pyram_a1$c[i]
  e1 = AgainstEq_E1pyram_a1$e1[i]
  e2 = AgainstEq_E1pyram_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1pyram_a1$Q[i]
  dN1 = AgainstEq_E1pyram_a1$N1[i]
  dP1 = AgainstEq_E1pyram_a1$P1[i]
  dC1 = AgainstEq_E1pyram_a1$C1[i]
  dN2 = AgainstEq_E1pyram_a1$N2[i]
  dP2 = AgainstEq_E1pyram_a1$P2[i]
  dC2 = AgainstEq_E1pyram_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Against_a1 <- rbind(StabCheck_E1pyram_Against_a1, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2,
                                                   a1, a2, h1, h2, d1, d2, g,
                                                   m, c, e1, e2, dQ, dN1, dP1, 
                                                   dC1, dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = AgainstEq_E1pyram_a1$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Against_a1$stable <- as.factor(StabCheck_E1pyram_Against_a1$stable)

# separate unstable equilibria to work with later
Against_E1pyram_a1_Unstab <- subset(StabCheck_E1pyram_Against_a1, 
                                    StabCheck_E1pyram_Against_a1$stable == "unstable")

rm(Jacob)

```

**`r prettyNum((nrow(Against_E1pyram_a1_Unstab)/nrow(StabCheck_E1pyram_Against_a1))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Death rate in Ecosystem 1

Start by sampling values for _d~1~_. 

```{r cls-bm-against-lsa-d1-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1pyram_against_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r cls-bm-against-lsa-d1, echo=TRUE, tidy=TRUE}
AgainstEq_E1pyram_d1 <- NULL

AgainstEq_E1pyram_d1 <-rbind(AgainstEq_E1pyram_d1, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_against_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_E1pyram_against_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1pyram_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AgainstEq_E1pyram_d1 <- AgainstEq_E1pyram_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability.

```{r cls-bm-against-lsa-d1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Against_d1 <- NULL

for (i in 1:nrow(AgainstEq_E1pyram_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1pyram_d1$I1[i]
  I2 = AgainstEq_E1pyram_d1$I2[i]
  l = AgainstEq_E1pyram_d1$l[i]
  u1 = AgainstEq_E1pyram_d1$u1[i]
  u2 = AgainstEq_E1pyram_d1$u2[i]
  a1 = AgainstEq_E1pyram_d1$a1[i]
  a2 = AgainstEq_E1pyram_d1$a2[i]
  h1 = AgainstEq_E1pyram_d1$h1[i]
  h2 = AgainstEq_E1pyram_d1$h2[i]
  d1 = AgainstEq_E1pyram_d1$d1[i]
  d2 = AgainstEq_E1pyram_d1$d2[i]
  g = AgainstEq_E1pyram_d1$g[i]
  m = AgainstEq_E1pyram_d1$m[i]
  c = AgainstEq_E1pyram_d1$c[i]
  e1 = AgainstEq_E1pyram_d1$e1[i]
  e2 = AgainstEq_E1pyram_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1pyram_d1$Q[i]
  dN1 = AgainstEq_E1pyram_d1$N1[i]
  dP1 = AgainstEq_E1pyram_d1$P1[i]
  dC1 = AgainstEq_E1pyram_d1$C1[i]
  dN2 = AgainstEq_E1pyram_d1$N2[i]
  dP2 = AgainstEq_E1pyram_d1$P2[i]
  dC2 = AgainstEq_E1pyram_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Against_d1 <- rbind(StabCheck_E1pyram_Against_d1, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2,
                                                   a1, a2, h1, h2, d1, d2, g,
                                                   m, c, e1, e2, dQ, dN1, dP1,
                                                   dC1, dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = AgainstEq_E1pyram_d1$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Against_d1$stable <- as.factor(StabCheck_E1pyram_Against_d1$stable)

# separate unstable equilibria to work with later
Against_E1pyram_d1_Unstab <- subset(StabCheck_E1pyram_Against_d1, 
                                    StabCheck_E1pyram_Against_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_E1pyram_d1_Unstab)/nrow(StabCheck_E1pyram_Against_d1))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate into Q

Sample values of _g_ first.

```{r cls-bm-against-lsa-g-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1pyram_against_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r cls-bm-against-lsa-g, echo=TRUE,tidy=TRUE}
AgainstEq_E1pyram_g <- NULL

AgainstEq_E1pyram_g <-rbind(AgainstEq_E1pyram_g, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_against_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_E1pyram_against_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1pyram_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_E1pyram_g <- AgainstEq_E1pyram_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability.

```{r cls-bm-against-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Against_g <- NULL

for (i in 1:nrow(AgainstEq_E1pyram_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1pyram_g$I1[i]
  I2 = AgainstEq_E1pyram_g$I2[i]
  l = AgainstEq_E1pyram_g$l[i]
  u1 = AgainstEq_E1pyram_g$u1[i]
  u2 = AgainstEq_E1pyram_g$u2[i]
  a1 = AgainstEq_E1pyram_g$a1[i]
  a2 = AgainstEq_E1pyram_g$a2[i]
  h1 = AgainstEq_E1pyram_g$h1[i]
  h2 = AgainstEq_E1pyram_g$h2[i]
  d1 = AgainstEq_E1pyram_g$d1[i]
  d2 = AgainstEq_E1pyram_g$d2[i]
  g = AgainstEq_E1pyram_g$g[i]
  m = AgainstEq_E1pyram_g$m[i]
  c = AgainstEq_E1pyram_g$c[i]
  e1 = AgainstEq_E1pyram_g$e1[i]
  e2 = AgainstEq_E1pyram_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1pyram_g$Q[i]
  dN1 = AgainstEq_E1pyram_g$N1[i]
  dP1 = AgainstEq_E1pyram_g$P1[i]
  dC1 = AgainstEq_E1pyram_g$C1[i]
  dN2 = AgainstEq_E1pyram_g$N2[i]
  dP2 = AgainstEq_E1pyram_g$P2[i]
  dC2 = AgainstEq_E1pyram_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Against_g <- rbind(StabCheck_E1pyram_Against_g, 
                                       data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                  a1, a2, h1, h2, d1, d2, g,
                                                  m, c, e1, e2, dQ, dN1, dP1,
                                                  dC1, dN2, dP2, dC2,
                                                  EiV1 = Re(eigen(Jacob)$values[1]),
                                                  EiV2 = Re(eigen(Jacob)$values[2]),
                                                  EiV3 = Re(eigen(Jacob)$values[3]),
                                                  EiV4 = Re(eigen(Jacob)$values[4]),
                                                  EiV5 = Re(eigen(Jacob)$values[5]),
                                                  EiV6 = Re(eigen(Jacob)$values[6]),
                                                  EiV7 = Re(eigen(Jacob)$values[7]),
                                                  maxEv = max(Re(base::eigen(Jacob)$values)),
                                                  stable = stable,
                                                  biosense = AgainstEq_E1pyram_g$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Against_g$stable <- as.factor(StabCheck_E1pyram_Against_g$stable)

# separate unstable equilibria to work with later
Against_E1pyram_g_Unstab <- subset(StabCheck_E1pyram_Against_g, 
                                   StabCheck_E1pyram_Against_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_E1pyram_g_Unstab)/nrow(StabCheck_E1pyram_Against_g))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate from Q

Start by sampling values for _m_.

```{r cls-bm-against-lsa-m-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1pyram_against_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r cls-bm-against-lsa-m, echo=TRUE,tidy=TRUE}
AgainstEq_E1pyram_m <- NULL

AgainstEq_E1pyram_m <-rbind(AgainstEq_E1pyram_m, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_against_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_E1pyram_against_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1pyram_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_E1pyram_m <- AgainstEq_E1pyram_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability.

```{r cls-bm-against-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Against_m <- NULL

for (i in 1:nrow(AgainstEq_E1pyram_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1pyram_m$I1[i]
  I2 = AgainstEq_E1pyram_m$I2[i]
  l = AgainstEq_E1pyram_m$l[i]
  u1 = AgainstEq_E1pyram_m$u1[i]
  u2 = AgainstEq_E1pyram_m$u2[i]
  a1 = AgainstEq_E1pyram_m$a1[i]
  a2 = AgainstEq_E1pyram_m$a2[i]
  h1 = AgainstEq_E1pyram_m$h1[i]
  h2 = AgainstEq_E1pyram_m$h2[i]
  d1 = AgainstEq_E1pyram_m$d1[i]
  d2 = AgainstEq_E1pyram_m$d2[i]
  g = AgainstEq_E1pyram_m$g[i]
  m = AgainstEq_E1pyram_m$m[i]
  c = AgainstEq_E1pyram_m$c[i]
  e1 = AgainstEq_E1pyram_m$e1[i]
  e2 = AgainstEq_E1pyram_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1pyram_m$Q[i]
  dN1 = AgainstEq_E1pyram_m$N1[i]
  dP1 = AgainstEq_E1pyram_m$P1[i]
  dC1 = AgainstEq_E1pyram_m$C1[i]
  dN2 = AgainstEq_E1pyram_m$N2[i]
  dP2 = AgainstEq_E1pyram_m$P2[i]
  dC2 = AgainstEq_E1pyram_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Against_m <- rbind(StabCheck_E1pyram_Against_m, 
                                       data.frame(TIME=i, I1, I2, l, u1, u2,
                                                  a1, a2, h1, h2, d1, d2, g,
                                                  m, c, e1, e2, dQ, dN1, dP1,
                                                  dC1, dN2, dP2, dC2,
                                                  EiV1 = Re(eigen(Jacob)$values[1]),
                                                  EiV2 = Re(eigen(Jacob)$values[2]),
                                                  EiV3 = Re(eigen(Jacob)$values[3]),
                                                  EiV4 = Re(eigen(Jacob)$values[4]),
                                                  EiV5 = Re(eigen(Jacob)$values[5]),
                                                  EiV6 = Re(eigen(Jacob)$values[6]),
                                                  EiV7 = Re(eigen(Jacob)$values[7]),
                                                  maxEv = max(Re(base::eigen(Jacob)$values)),
                                                  stable = stable,
                                                  biosense = AgainstEq_E1pyram_m$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Against_m$stable <- as.factor(StabCheck_E1pyram_Against_m$stable)

# separate unstable equilibria to work with later
Against_E1pyram_m_Unstab <- subset(StabCheck_E1pyram_Against_m, 
                                   StabCheck_E1pyram_Against_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_E1pyram_m_Unstab)/nrow(StabCheck_E1pyram_Against_m))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Death rate in Q

Start by sampling _c_ values.

```{r cls-bm-against-lsa-c-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1pyram_against_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r cls-bm-against-lsa-c, echo=TRUE, tidy=TRUE}
AgainstEq_E1pyram_c <- NULL

AgainstEq_E1pyram_c <-rbind(AgainstEq_E1pyram_c, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1pyram_against_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_E1pyram_against_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1pyram_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_E1pyram_c <- AgainstEq_E1pyram_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then test for stability.

```{r cls-bm-against-lsa-c-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1pyram_Against_c <- NULL

for (i in 1:nrow(AgainstEq_E1pyram_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1pyram_c$I1[i]
  I2 = AgainstEq_E1pyram_c$I2[i]
  l = AgainstEq_E1pyram_c$l[i]
  u1 = AgainstEq_E1pyram_c$u1[i]
  u2 = AgainstEq_E1pyram_c$u2[i]
  a1 = AgainstEq_E1pyram_c$a1[i]
  a2 = AgainstEq_E1pyram_c$a2[i]
  h1 = AgainstEq_E1pyram_c$h1[i]
  h2 = AgainstEq_E1pyram_c$h2[i]
  d1 = AgainstEq_E1pyram_c$d1[i]
  d2 = AgainstEq_E1pyram_c$d2[i]
  g = AgainstEq_E1pyram_c$g[i]
  m = AgainstEq_E1pyram_c$m[i]
  c = AgainstEq_E1pyram_c$c[i]
  e1 = AgainstEq_E1pyram_c$e1[i]
  e2 = AgainstEq_E1pyram_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1pyram_c$Q[i]
  dN1 = AgainstEq_E1pyram_c$N1[i]
  dP1 = AgainstEq_E1pyram_c$P1[i]
  dC1 = AgainstEq_E1pyram_c$C1[i]
  dN2 = AgainstEq_E1pyram_c$N2[i]
  dP2 = AgainstEq_E1pyram_c$P2[i]
  dC2 = AgainstEq_E1pyram_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1pyram_Against_c <- rbind(StabCheck_E1pyram_Against_c, 
                                       data.frame(TIME=i, I1, I2, l, u1, u2,
                                                  a1, a2, h1, h2, d1, d2, g,
                                                  m, c, e1, e2, dQ, dN1, dP1,
                                                  dC1, dN2, dP2, dC2,
                                                  EiV1 = Re(eigen(Jacob)$values[1]),
                                                  EiV2 = Re(eigen(Jacob)$values[2]),
                                                  EiV3 = Re(eigen(Jacob)$values[3]),
                                                  EiV4 = Re(eigen(Jacob)$values[4]),
                                                  EiV5 = Re(eigen(Jacob)$values[5]),
                                                  EiV6 = Re(eigen(Jacob)$values[6]),
                                                  EiV7 = Re(eigen(Jacob)$values[7]),
                                                  maxEv = max(Re(base::eigen(Jacob)$values)),
                                                  stable = stable,
                                                  biosense = AgainstEq_E1pyram_c$biosense[i]))
  
  # browser()
}

StabCheck_E1pyram_Against_c$stable <- as.factor(StabCheck_E1pyram_Against_c$stable)

# separate unstable equilibria to work with later
Against_E1pyram_c_Unstab <- subset(StabCheck_E1pyram_Against_c, 
                                   StabCheck_E1pyram_Against_c$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_E1pyram_c_Unstab)/nrow(StabCheck_E1pyram_Against_c))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

:::::

#### Inverted biomass distribution

Here, we run a LSA using only the values from the subset of entries in `ecoCR`
where the distribution of biomass in the donor ecosystem 1 is inverted, 
top-heavy. As before, we run one LSA per focal parameter, per consumer 
movement scenario.

##### Gradient-neutral scenario

The LSA blueprint is always the same. First, remove the non-focal parameter mean
values from the previous LSA run. Then, store the new mean values. Finally, for 
each focal parameter (see above for a list), (i) sample values in the 
`[0.01, 10]` interval, (ii) run the LSA, and (iii) check for stability.

```{r ivrt-bm-grad-neutral-lsa-mean-params, echo=TRUE, tidy=TRUE}
rm(list = c('I1_m', 'I2_m', 'l_m', 'a1_m', 'a2_m', 'u1_m', 'u2_m', 'h1_m', 
            'h2_m', 'd1_m', 'd2_m', 'g_m', 'c_m', 'm_m', 'e1_m', 'e2_m'))

I1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(I1) %>% mean()
I2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(I2) %>% mean()
l_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(l) %>% mean()
a1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(a1) %>% mean()
a2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(a2) %>% mean()
u1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(u1) %>% mean()
u2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(u2) %>% mean()
h1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(h1) %>% mean()
h2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(h2) %>% mean()
d1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(d1) %>% mean()
d2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(d2) %>% mean()
g_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(g) %>% mean()
m_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(m) %>% mean()
c_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(c) %>% mean()
e1_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(e1) %>% mean()
e2_m <- ecoCR %>% filter(., Fertility == "Equal" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

###### Attack rate in Ecosystem 1

First, generate values for the focal parameter, _a~1~_.

```{r ivrt-bm-grad-neutral-lsa-a1-value-gen, echo=TRUE, tidy=TRUE}
DATA_E1invert_neutral_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r ivrt-bm-grad-neutral-lsa-a1}
NeutralEq_E1invert_a1 <- NULL

NeutralEq_E1invert_a1 <-rbind(NeutralEq_E1invert_a1, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_neutral_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_E1invert_neutral_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1invert_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, 
# so let's flag them

NeutralEq_E1invert_a1 <- NeutralEq_E1invert_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                                           .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Check for stability.

```{r ivrt-bm-grad-neutral-lsa-a1-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_Neutral_E1invert_a1 <- NULL

# run the stability analysis loop
for (i in 1:nrow(NeutralEq_E1invert_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1invert_a1$I1[i]
  I2 = NeutralEq_E1invert_a1$I2[i]
  l = NeutralEq_E1invert_a1$l[i]
  u1 = NeutralEq_E1invert_a1$u1[i]
  u2 = NeutralEq_E1invert_a1$u2[i]
  a1 = NeutralEq_E1invert_a1$a1[i]
  a2 = NeutralEq_E1invert_a1$a2[i]
  h1 = NeutralEq_E1invert_a1$h1[i]
  h2 = NeutralEq_E1invert_a1$h2[i]
  d1 = NeutralEq_E1invert_a1$d1[i]
  d2 = NeutralEq_E1invert_a1$d2[i]
  g = NeutralEq_E1invert_a1$g[i]
  m = NeutralEq_E1invert_a1$m[i]
  c = NeutralEq_E1invert_a1$c[i]
  e1 = NeutralEq_E1invert_a1$e1[i]
  e2 = NeutralEq_E1invert_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1invert_a1$Q[i]
  dN1 = NeutralEq_E1invert_a1$N1[i]
  dP1 = NeutralEq_E1invert_a1$P1[i]
  dC1 = NeutralEq_E1invert_a1$C1[i]
  dN2 = NeutralEq_E1invert_a1$N2[i]
  dP2 = NeutralEq_E1invert_a1$P2[i]
  dC2 = NeutralEq_E1invert_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_Neutral_E1invert_a1 <- rbind(StabCheck_Neutral_E1invert_a1, 
                                         data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                    a1, a2, h1, h2, d1, d2, g, 
                                                    m, c, e1, e2, dQ, dN1, dP1,
                                                    dC1, dN2, dP2, dC2,
                                                    EiV1 = Re(eigen(Jacob)$values[1]),
                                                    EiV2 = Re(eigen(Jacob)$values[2]),
                                                    EiV3 = Re(eigen(Jacob)$values[3]),
                                                    EiV4 = Re(eigen(Jacob)$values[4]),
                                                    EiV5 = Re(eigen(Jacob)$values[5]),
                                                    EiV6 = Re(eigen(Jacob)$values[6]),
                                                    EiV7 = Re(eigen(Jacob)$values[7]),
                                                    maxEv = max(Re(base::eigen(Jacob)$values)),
                                                    stable = stable,
                                                    biosense = NeutralEq_E1invert_a1$biosense[i]))
  
  # browser()
}

StabCheck_Neutral_E1invert_a1$stable <- as.factor(StabCheck_Neutral_E1invert_a1$stable)

# separate unstable equilibria to work with later
Neutral_E1invert_a1_Unstab <- subset(StabCheck_Neutral_E1invert_a1, 
                                     StabCheck_Neutral_E1invert_a1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1invert_a1_Unstab)/nrow(StabCheck_Neutral_E1invert_a1))*100, digits = 3)`** 
parameter sets produced unstable results.

:::

::: {.panel}

###### Death rate in Ecosystem 1

First, generate some values for _d~1~_.

```{r ivrt-bm-grad-neutral-lsa-d1-value-gen, echo=TRUE, tidy=TRUE}
DATA_E1invert_neutral_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r ivrt-bm-grad-neutral-lsa-d1, echo=TRUE,tidy=TRUE}
NeutralEq_E1invert_d1 <- NULL

NeutralEq_E1invert_d1 <-rbind(NeutralEq_E1invert_d1, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_neutral_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_E1invert_neutral_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1invert_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them 

NeutralEq_E1invert_d1 <- NeutralEq_E1invert_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And, finally, check for stability.

```{r ivrt-bm-grad-neutral-lsa-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Neutral_d1 <- NULL

for (i in 1:nrow(NeutralEq_E1invert_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1invert_d1$I1[i]
  I2 = NeutralEq_E1invert_d1$I2[i]
  l = NeutralEq_E1invert_d1$l[i]
  u1 = NeutralEq_E1invert_d1$u1[i]
  u2 = NeutralEq_E1invert_d1$u2[i]
  a1 = NeutralEq_E1invert_d1$a1[i]
  a2 = NeutralEq_E1invert_d1$a2[i]
  h1 = NeutralEq_E1invert_a1$h1[i]
  h2 = NeutralEq_E1invert_d1$h2[i]
  d1 = NeutralEq_E1invert_d1$d1[i]
  d2 = NeutralEq_E1invert_d1$d2[i]
  g = NeutralEq_E1invert_d1$g[i]
  m = NeutralEq_E1invert_d1$m[i]
  c = NeutralEq_E1invert_d1$c[i]
  e1 = NeutralEq_E1invert_d1$e1[i]
  e2 = NeutralEq_E1invert_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1invert_d1$Q[i]
  dN1 = NeutralEq_E1invert_d1$N1[i]
  dP1 = NeutralEq_E1invert_d1$P1[i]
  dC1 = NeutralEq_E1invert_d1$C1[i]
  dN2 = NeutralEq_E1invert_d1$N2[i]
  dP2 = NeutralEq_E1invert_d1$P2[i]
  dC2 = NeutralEq_E1invert_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Neutral_d1 <- rbind(StabCheck_E1invert_Neutral_d1, 
                                         data.frame(TIME=i, I1, I2, l, u1, u2,
                                                    a1, a2, h1, h2, d1, d2, g,
                                                    m, c, e1, e2, dQ, dN1, dP1,
                                                    dC1, dN2, dP2, dC2,
                                                    EiV1 = Re(eigen(Jacob)$values[1]),
                                                    EiV2 = Re(eigen(Jacob)$values[2]),
                                                    EiV3 = Re(eigen(Jacob)$values[3]),
                                                    EiV4 = Re(eigen(Jacob)$values[4]),
                                                    EiV5 = Re(eigen(Jacob)$values[5]),
                                                    EiV6 = Re(eigen(Jacob)$values[6]),
                                                    EiV7 = Re(eigen(Jacob)$values[7]),
                                                    maxEv = max(Re(base::eigen(Jacob)$values)),
                                                    stable = stable,
                                                    biosense = NeutralEq_E1invert_d1$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Neutral_d1$stable <- as.factor(StabCheck_E1invert_Neutral_d1$stable)

# separate unstable equilibria to work with later
Neutral_E1invert_d1_Unstab <- subset(StabCheck_E1invert_Neutral_d1, 
                                     StabCheck_E1invert_Neutral_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1invert_d1_Unstab)/nrow(StabCheck_E1invert_Neutral_d1))*100, digits = 3)`** parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate into Q

Start by producing some values of _g_.

```{r ivrt-bm-grad-neutral-lsa-g-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1invert_neutral_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r ivrt-bm-grad-neutral-lsa-g, echo=TRUE,tidy=TRUE}
NeutralEq_E1invert_g <- NULL

NeutralEq_E1invert_g <-rbind(NeutralEq_E1invert_g, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_neutral_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_E1invert_neutral_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1invert_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

NeutralEq_E1invert_g <- NeutralEq_E1invert_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

As a final step, check for stability.

```{r ivrt-bm-grad-neutral-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Neutral_g <- NULL

for (i in 1:nrow(NeutralEq_E1invert_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1invert_g$I1[i]
  I2 = NeutralEq_E1invert_g$I2[i]
  l = NeutralEq_E1invert_g$l[i]
  u1 = NeutralEq_E1invert_g$u1[i]
  u2 = NeutralEq_E1invert_g$u2[i]
  a1 = NeutralEq_E1invert_g$a1[i]
  a2 = NeutralEq_E1invert_g$a2[i]
  h1 = NeutralEq_E1invert_g$h1[i]
  h2 = NeutralEq_E1invert_g$h2[i]
  d1 = NeutralEq_E1invert_g$d1[i]
  d2 = NeutralEq_E1invert_g$d2[i]
  g = NeutralEq_E1invert_g$g[i]
  m = NeutralEq_E1invert_g$m[i]
  c = NeutralEq_E1invert_g$c[i]
  e1 = NeutralEq_E1invert_g$e1[i]
  e2 = NeutralEq_E1invert_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1invert_g$Q[i]
  dN1 = NeutralEq_E1invert_g$N1[i]
  dP1 = NeutralEq_E1invert_g$P1[i]
  dC1 = NeutralEq_E1invert_g$C1[i]
  dN2 = NeutralEq_E1invert_g$N2[i]
  dP2 = NeutralEq_E1invert_g$P2[i]
  dC2 = NeutralEq_E1invert_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Neutral_g <- rbind(StabCheck_E1invert_Neutral_g, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                   a1, a2, h1, h2, d1, d2, g, 
                                                   m, c, e1, e2, dQ, dN1, dP1,
                                                   dC1, dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = NeutralEq_E1invert_g$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Neutral_g$stable <- as.factor(StabCheck_E1invert_Neutral_g$stable)

# separate unstable equilibria to work with later
Neutral_E1invert_g_Unstab <- subset(StabCheck_E1invert_Neutral_g, 
                                    StabCheck_E1invert_Neutral_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1invert_g_Unstab)/nrow(StabCheck_E1invert_Neutral_g))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate from Q

Begin by sampling values of _m_.

```{r ivrt-bm-grad-neutral-lsa-m-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1invert_neutral_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Follow up by running the LSA.

```{r ivrt-bm-grad-neutral-lsa-m, echo=TRUE,tidy=TRUE}
NeutralEq_E1invert_m <- NULL

NeutralEq_E1invert_m <-rbind(NeutralEq_E1invert_m, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_neutral_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_E1invert_neutral_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1invert_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

NeutralEq_E1invert_m <- NeutralEq_E1invert_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

And wrap it up by checking for stability.

```{r ivrt-bm-grad-neutral-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Neutral_m <- NULL

for (i in 1:nrow(NeutralEq_E1invert_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1invert_m$I1[i]
  I2 = NeutralEq_E1invert_m$I2[i]
  l = NeutralEq_E1invert_m$l[i]
  u1 = NeutralEq_E1invert_m$u1[i]
  u2 = NeutralEq_E1invert_m$u2[i]
  a1 = NeutralEq_E1invert_m$a1[i]
  a2 = NeutralEq_E1invert_m$a2[i]
  h1 = NeutralEq_E1invert_m$h1[i]
  h2 = NeutralEq_E1invert_m$h2[i]
  d1 = NeutralEq_E1invert_m$d1[i]
  d2 = NeutralEq_E1invert_m$d2[i]
  g = NeutralEq_E1invert_m$g[i]
  m = NeutralEq_E1invert_m$m[i]
  c = NeutralEq_E1invert_m$c[i]
  e1 = NeutralEq_E1invert_m$e1[i]
  e2 = NeutralEq_E1invert_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1invert_m$Q[i]
  dN1 = NeutralEq_E1invert_m$N1[i]
  dP1 = NeutralEq_E1invert_m$P1[i]
  dC1 = NeutralEq_E1invert_m$C1[i]
  dN2 = NeutralEq_E1invert_m$N2[i]
  dP2 = NeutralEq_E1invert_m$P2[i]
  dC2 = NeutralEq_E1invert_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Neutral_m <- rbind(StabCheck_E1invert_Neutral_m, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2,
                                                   a1, a2, h1, h2, d1, d2, g,
                                                   m, c, e1, e2, dQ, dN1, dP1,
                                                   dC1, dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = NeutralEq_E1invert_m$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Neutral_m$stable <- as.factor(StabCheck_E1invert_Neutral_m$stable)

# separate unstable equilibria to work with later
Neutral_E1invert_m_Unstab <- subset(StabCheck_E1invert_Neutral_m, 
                                    StabCheck_E1invert_Neutral_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1invert_m_Unstab)/nrow(StabCheck_E1invert_Neutral_m))*100, digits = 3)`** 
parameter sets appear to be unstable.
:::

::: {.panel}

###### Death rate in Q

Sample values for _c_.

```{r ivrt-bm-grad-neutral-lsa-c-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1invert_neutral_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r ivrt-bm-grad-neutral-lsa-c, echo=TRUE,tidy=TRUE}
NeutralEq_E1invert_c <- NULL

NeutralEq_E1invert_c <-rbind(NeutralEq_E1invert_c, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_neutral_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_E1invert_neutral_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  NeutralEq_E1invert_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

NeutralEq_E1invert_c <- NeutralEq_E1invert_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability.

```{r ivrt-bm-grad-neutral-lsa-c-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Neutral_c <- NULL

for (i in 1:nrow(NeutralEq_E1invert_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = NeutralEq_E1invert_c$I1[i]
  I2 = NeutralEq_E1invert_c$I2[i]
  l = NeutralEq_E1invert_c$l[i]
  u1 = NeutralEq_E1invert_c$u1[i]
  u2 = NeutralEq_E1invert_c$u2[i]
  a1 = NeutralEq_E1invert_c$a1[i]
  a2 = NeutralEq_E1invert_c$a2[i]
  h1 = NeutralEq_E1invert_c$h1[i]
  h2 = NeutralEq_E1invert_c$h2[i]
  d1 = NeutralEq_E1invert_c$d1[i]
  d2 = NeutralEq_E1invert_c$d2[i]
  g = NeutralEq_E1invert_c$g[i]
  m = NeutralEq_E1invert_c$m[i]
  c = NeutralEq_E1invert_c$c[i]
  e1 = NeutralEq_E1invert_c$e1[i]
  e2 = NeutralEq_E1invert_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = NeutralEq_E1invert_c$Q[i]
  dN1 = NeutralEq_E1invert_c$N1[i]
  dP1 = NeutralEq_E1invert_c$P1[i]
  dC1 = NeutralEq_E1invert_c$C1[i]
  dN2 = NeutralEq_E1invert_c$N2[i]
  dP2 = NeutralEq_E1invert_c$P2[i]
  dC2 = NeutralEq_E1invert_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Neutral_c <- rbind(StabCheck_E1invert_Neutral_c, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                   a1, a2, h1, h2, d1, d2, g, 
                                                   m, c, e1, e2, dQ, dN1, dP1,
                                                   dC1, dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = NeutralEq_E1invert_c$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Neutral_c$stable <- as.factor(StabCheck_E1invert_Neutral_c$stable)

# separate unstable equilibria to work with later
Neutral_E1invert_c_Unstab <- subset(StabCheck_E1invert_Neutral_c, 
                                    StabCheck_E1invert_Neutral_c$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Neutral_E1invert_c_Unstab)/nrow(StabCheck_E1invert_Neutral_c))*100, digits = 3)`** 
parameter sets appear to be unstable.
:::

:::::

##### Along-gradient scenario

Let's remove the gradient-neutral mean parameter values objects first, then 
store this scenario's mean parameter values in named objects to use 
in local sensitivity analysis run below.

```{r ivrt-bm-along-lsa-mean-params, echo=TRUE, tidy=TRUE}
rm(list = c('I1_m', 'I2_m', 'l_m', 'a1_m', 'a2_m', 'u1_m', 'u2_m', 'h1_m', 
            'h2_m', 'd1_m', 'd2_m', 'g_m', 'c_m', 'm_m', 'e1_m', 'e2_m'))

I1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(I1) %>% mean()
I2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(I2) %>% mean()
l_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(l) %>% mean()
a1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(a1) %>% mean()
a2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(a2) %>% mean()
u1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(u1) %>% mean()
u2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(u2) %>% mean()
h1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(h1) %>% mean()
h2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(h2) %>% mean()
d1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(d1) %>% mean()
d2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(d2) %>% mean()
g_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(g) %>% mean()
m_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(m) %>% mean()
c_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(c) %>% mean()
e1_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(e1) %>% mean()
e2_m <- ecoCR %>% filter(., Fertility == "Along" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

###### Attack rate in Ecosystem 1

First, sample parameter values for _a~1~_.

```{r ivrt-bm-along-lsa-a1-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1invert_along_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r ivrt-bm-along-lsa-a1, echo=TRUE, tidy=TRUE}
AlongEq_E1invert_a1 <- NULL

AlongEq_E1invert_a1 <-rbind(AlongEq_E1invert_a1, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_along_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_E1invert_along_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1invert_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                       # Nutrient stock in ecosystem 1
                       ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary Producers biomass in ecosystem 1
                       (d1+g)/(a1*e1),
                       # Consumers biomass in ecosystem 1
                       (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Nutrient stock in ecosystem 2
                       (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                       # Primary Producers biomass in ecosystem 2
                       (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Consumer biomass in ecosystem 2
                       ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Consumer biomass in the Dispersers' Pool (Q)
                       (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Nutrient flux for primary producers in Ecosystem 1
                       ((d1+g)*h1)/(a1*e1),
                       # Nutrient flux for consumers in Ecosystem 1
                       (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                       # Nutrient flux for primary producers in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Nutrient flux for consumers in Ecosystem 2
                       (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Total flux in Ecosystem 1
                       (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Total flux in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Nutrient flux in the Dispersers' Pool
                       (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Primary productivity in Ecosystem 1
                       ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Secondary (=consumers) productivity in Ecosystem 1
                       (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary productivity in Ecosystem 2
                       ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                       # Secondary (=consumer) productivity in Ecosystem 2
                       (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_E1invert_a1 <- AlongEq_E1invert_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability.

```{r ivrt-bm-along-lsa-a1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Along_a1 <- NULL

for (i in 1:nrow(AlongEq_E1invert_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1invert_a1$I1[i]
  I2 = AlongEq_E1invert_a1$I2[i]
  l = AlongEq_E1invert_a1$l[i]
  u1 = AlongEq_E1invert_a1$u1[i]
  u2 = AlongEq_E1invert_a1$u2[i]
  a1 = AlongEq_E1invert_a1$a1[i]
  a2 = AlongEq_E1invert_a1$a2[i]
  h1 = AlongEq_E1invert_a1$h1[i]
  h2 = AlongEq_E1invert_a1$h2[i]
  d1 = AlongEq_E1invert_a1$d1[i]
  d2 = AlongEq_E1invert_a1$d2[i]
  g = AlongEq_E1invert_a1$g[i]
  m = AlongEq_E1invert_a1$m[i]
  c = AlongEq_E1invert_a1$c[i]
  e1 = AlongEq_E1invert_a1$e1[i]
  e2 = AlongEq_E1invert_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1invert_a1$Q[i]
  dN1 = AlongEq_E1invert_a1$N1[i]
  dP1 = AlongEq_E1invert_a1$P1[i]
  dC1 = AlongEq_E1invert_a1$C1[i]
  dN2 = AlongEq_E1invert_a1$N2[i]
  dP2 = AlongEq_E1invert_a1$P2[i]
  dC2 = AlongEq_E1invert_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Along_a1 <- rbind(StabCheck_E1invert_Along_a1, 
                                       data.frame(TIME=i, I1, I2, l, u1, u2,
                                                  a1, a2, h1, h2, d1, d2, g,
                                                  m, c, e1, e2, dQ, dN1, dP1,
                                                  dC1, dN2, dP2, dC2,
                                                  EiV1 = Re(eigen(Jacob)$values[1]),
                                                  EiV2 = Re(eigen(Jacob)$values[2]),
                                                  EiV3 = Re(eigen(Jacob)$values[3]),
                                                  EiV4 = Re(eigen(Jacob)$values[4]),
                                                  EiV5 = Re(eigen(Jacob)$values[5]),
                                                  EiV6 = Re(eigen(Jacob)$values[6]),
                                                  EiV7 = Re(eigen(Jacob)$values[7]),
                                                  maxEv = max(Re(base::eigen(Jacob)$values)),
                                                  stable = stable,
                                                  biosense = AlongEq_E1invert_a1$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Along_a1$stable <- as.factor(StabCheck_E1invert_Along_a1$stable)

# separate unstable equilibria to work with later
Along_E1invert_a1_Unstab <- subset(StabCheck_E1invert_Along_a1, 
                                   StabCheck_E1invert_Along_a1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1invert_a1_Unstab)/nrow(StabCheck_E1invert_Along_a1))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Death rate in Ecosystem 1

Start by generating values for _d~1~_.

```{r ivrt-bm-along-lsa-d1-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1invert_along_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r ivrt-bm-along-lsa-d1, echo=TRUE,tidy=TRUE}
AlongEq_E1invert_d1 <- NULL

AlongEq_E1invert_d1 <-rbind(AlongEq_E1invert_d1, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_along_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_E1invert_along_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1invert_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                       # Nutrient stock in ecosystem 1
                       ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary Producers biomass in ecosystem 1
                       (d1+g)/(a1*e1),
                       # Consumers biomass in ecosystem 1
                       (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Nutrient stock in ecosystem 2
                       (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                       # Primary Producers biomass in ecosystem 2
                       (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Consumer biomass in ecosystem 2
                       ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Consumer biomass in the Dispersers' Pool (Q)
                       (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Nutrient flux for primary producers in Ecosystem 1
                       ((d1+g)*h1)/(a1*e1),
                       # Nutrient flux for consumers in Ecosystem 1
                       (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                       # Nutrient flux for primary producers in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                       # Nutrient flux for consumers in Ecosystem 2
                       (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Total flux in Ecosystem 1
                       (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Total flux in Ecosystem 2
                       (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                       # Nutrient flux in the Dispersers' Pool
                       (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Primary productivity in Ecosystem 1
                       ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                       # Secondary (=consumers) productivity in Ecosystem 1
                       (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                       # Primary productivity in Ecosystem 2
                       ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                       # Secondary (=consumer) productivity in Ecosystem 2
                       (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_E1invert_d1 <- AlongEq_E1invert_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability.

```{r ivrt-bm-along-lsa-d1-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Along_d1 <- NULL

for (i in 1:nrow(AlongEq_E1invert_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1invert_d1$I1[i]
  I2 = AlongEq_E1invert_d1$I2[i]
  l = AlongEq_E1invert_d1$l[i]
  u1 = AlongEq_E1invert_d1$u1[i]
  u2 = AlongEq_E1invert_d1$u2[i]
  a1 = AlongEq_E1invert_d1$a1[i]
  a2 = AlongEq_E1invert_d1$a2[i]
  h1 = AlongEq_E1invert_d1$h1[i]
  h2 = AlongEq_E1invert_d1$h2[i]
  d1 = AlongEq_E1invert_d1$d1[i]
  d2 = AlongEq_E1invert_d1$d2[i]
  g = AlongEq_E1invert_d1$g[i]
  m = AlongEq_E1invert_d1$m[i]
  c = AlongEq_E1invert_d1$c[i]
  e1 = AlongEq_E1invert_d1$e1[i]
  e2 = AlongEq_E1invert_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1invert_d1$Q[i]
  dN1 = AlongEq_E1invert_d1$N1[i]
  dP1 = AlongEq_E1invert_d1$P1[i]
  dC1 = AlongEq_E1invert_d1$C1[i]
  dN2 = AlongEq_E1invert_d1$N2[i]
  dP2 = AlongEq_E1invert_d1$P2[i]
  dC2 = AlongEq_E1invert_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Along_d1 <- rbind(StabCheck_E1invert_Along_d1, 
                                       data.frame(TIME=i, I1, I2, l, u1, u2,
                                                  a1, a2, h1, h2, d1, d2, g,
                                                  m, c, e1, e2, dQ, dN1, dP1,
                                                  dC1, dN2, dP2, dC2,
                                                  EiV1 = Re(eigen(Jacob)$values[1]),
                                                  EiV2 = Re(eigen(Jacob)$values[2]),
                                                  EiV3 = Re(eigen(Jacob)$values[3]),
                                                  EiV4 = Re(eigen(Jacob)$values[4]),
                                                  EiV5 = Re(eigen(Jacob)$values[5]),
                                                  EiV6 = Re(eigen(Jacob)$values[6]),
                                                  EiV7 = Re(eigen(Jacob)$values[7]),
                                                  maxEv = max(Re(base::eigen(Jacob)$values)),
                                                  stable = stable,
                                                  biosense = AlongEq_E1invert_d1$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Along_d1$stable <- as.factor(StabCheck_E1invert_Along_d1$stable)

# separate unstable equilibria to work with later
Along_E1invert_d1_Unstab <- subset(StabCheck_E1invert_Along_d1, 
                                   StabCheck_E1invert_Along_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1invert_d1_Unstab)/nrow(StabCheck_E1invert_Along_d1))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate into Q

Generate sample values for _g_.

```{r ivrt-bm-along-lsa-g-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1invert_along_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r ivrt-bm-along-lsa-g, echo=TRUE, tidy=TRUE}
AlongEq_E1invert_g <- NULL

AlongEq_E1invert_g <-rbind(AlongEq_E1invert_g, 
                   data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                              l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                              a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                              h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                              g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                              e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                              P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                              P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                              FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                              FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                              FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                              FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                              PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                              PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_along_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_E1invert_along_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1invert_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_E1invert_g <- AlongEq_E1invert_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability.

```{r ivrt-bm-along-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Along_g <- NULL

for (i in 1:nrow(AlongEq_E1invert_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1invert_g$I1[i]
  I2 = AlongEq_E1invert_g$I2[i]
  l = AlongEq_E1invert_g$l[i]
  u1 = AlongEq_E1invert_g$u1[i]
  u2 = AlongEq_E1invert_g$u2[i]
  a1 = AlongEq_E1invert_g$a1[i]
  a2 = AlongEq_E1invert_g$a2[i]
  h1 = AlongEq_E1invert_g$h1[i]
  h2 = AlongEq_E1invert_g$h2[i]
  d1 = AlongEq_E1invert_g$d1[i]
  d2 = AlongEq_E1invert_g$d2[i]
  g = AlongEq_E1invert_g$g[i]
  m = AlongEq_E1invert_g$m[i]
  c = AlongEq_E1invert_g$c[i]
  e1 = AlongEq_E1invert_g$e1[i]
  e2 = AlongEq_E1invert_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1invert_g$Q[i]
  dN1 = AlongEq_E1invert_g$N1[i]
  dP1 = AlongEq_E1invert_g$P1[i]
  dC1 = AlongEq_E1invert_g$C1[i]
  dN2 = AlongEq_E1invert_g$N2[i]
  dP2 = AlongEq_E1invert_g$P2[i]
  dC2 = AlongEq_E1invert_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Along_g<- rbind(StabCheck_E1invert_Along_g, 
                                     data.frame(TIME=i, I1, I2, l, u1, u2,
                                                a1, a2, h1, h2, d1, d2, g,
                                                m, c, e1, e2, dQ, dN1, dP1,
                                                dC1, dN2, dP2, dC2,
                                                EiV1 = Re(eigen(Jacob)$values[1]),
                                                EiV2 = Re(eigen(Jacob)$values[2]),
                                                EiV3 = Re(eigen(Jacob)$values[3]),
                                                EiV4 = Re(eigen(Jacob)$values[4]),
                                                EiV5 = Re(eigen(Jacob)$values[5]),
                                                EiV6 = Re(eigen(Jacob)$values[6]),
                                                EiV7 = Re(eigen(Jacob)$values[7]),
                                                maxEv = max(Re(base::eigen(Jacob)$values)),
                                                stable = stable,
                                                biosense = AlongEq_E1invert_g$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Along_g$stable <- as.factor(StabCheck_E1invert_Along_g$stable)

# separate unstable equilibria to work with later
Along_E1invert_g_Unstab <- subset(StabCheck_E1invert_Along_g, 
                                  StabCheck_E1invert_Along_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1invert_g_Unstab)/nrow(StabCheck_E1invert_Along_g))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate from Q

Start by generating values for _m_.

```{r ivrt-bm-along-lsa-m-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1invert_along_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Run the LSA.

```{r ivrt-bm-along-lsa-m, echo=TRUE,tidy=TRUE}
AlongEq_E1invert_m <- NULL

AlongEq_E1invert_m <-rbind(AlongEq_E1invert_m, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_along_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_E1invert_along_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1invert_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so
# let's flag them

AlongEq_E1invert_m <- AlongEq_E1invert_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability.

```{r ivrt-bm-along-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Along_m <- NULL

for (i in 1:nrow(AlongEq_E1invert_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1invert_m$I1[i]
  I2 = AlongEq_E1invert_m$I2[i]
  l = AlongEq_E1invert_m$l[i]
  u1 = AlongEq_E1invert_m$u1[i]
  u2 = AlongEq_E1invert_m$u2[i]
  a1 = AlongEq_E1invert_m$a1[i]
  a2 = AlongEq_E1invert_m$a2[i]
  h1 = AlongEq_E1invert_m$h1[i]
  h2 = AlongEq_E1invert_m$h2[i]
  d1 = AlongEq_E1invert_m$d1[i]
  d2 = AlongEq_E1invert_m$d2[i]
  g = AlongEq_E1invert_m$g[i]
  m = AlongEq_E1invert_m$m[i]
  c = AlongEq_E1invert_m$c[i]
  e1 = AlongEq_E1invert_m$e1[i]
  e2 = AlongEq_E1invert_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1invert_m$Q[i]
  dN1 = AlongEq_E1invert_m$N1[i]
  dP1 = AlongEq_E1invert_m$P1[i]
  dC1 = AlongEq_E1invert_m$C1[i]
  dN2 = AlongEq_E1invert_m$N2[i]
  dP2 = AlongEq_E1invert_m$P2[i]
  dC2 = AlongEq_E1invert_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Along_m<- rbind(StabCheck_E1invert_Along_m, 
                                     data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                a1, a2, h1, h2, d1, d2, g, 
                                                m, c, e1, e2, dQ, dN1, dP1,
                                                dC1, dN2, dP2, dC2,
                                                EiV1 = Re(eigen(Jacob)$values[1]),
                                                EiV2 = Re(eigen(Jacob)$values[2]),
                                                EiV3 = Re(eigen(Jacob)$values[3]),
                                                EiV4 = Re(eigen(Jacob)$values[4]),
                                                EiV5 = Re(eigen(Jacob)$values[5]),
                                                EiV6 = Re(eigen(Jacob)$values[6]),
                                                EiV7 = Re(eigen(Jacob)$values[7]),
                                                maxEv = max(Re(base::eigen(Jacob)$values)),
                                                stable = stable,
                                                biosense = AlongEq_E1invert_m$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Along_m$stable <- as.factor(StabCheck_E1invert_Along_m$stable)

# separate unstable equilibria to work with later
Along_E1invert_m_Unstab <- subset(StabCheck_E1invert_Along_m,
                                  StabCheck_E1invert_Along_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1invert_m_Unstab)/nrow(StabCheck_E1invert_Along_m))*100, digits = 3)`** 
parameter sets appear to be unstable.
:::

::: {.panel}

###### Death rate in Q

Sample values for _c_.

```{r ivrt-bm-along-lsa-c-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1invert_along_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r ivrt-bm-along-lsa-c, echo=TRUE, tidy=TRUE}
AlongEq_E1invert_c <- NULL

AlongEq_E1invert_c <-rbind(AlongEq_E1invert_c, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_along_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_E1invert_along_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  AlongEq_E1invert_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                      # Nutrient stock in ecosystem 1
                      ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary Producers biomass in ecosystem 1
                      (d1+g)/(a1*e1),
                      # Consumers biomass in ecosystem 1
                      (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Nutrient stock in ecosystem 2
                      (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                      # Primary Producers biomass in ecosystem 2
                      (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Consumer biomass in ecosystem 2
                      ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Consumer biomass in the Dispersers' Pool (Q)
                      (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Nutrient flux for primary producers in Ecosystem 1
                      ((d1+g)*h1)/(a1*e1),
                      # Nutrient flux for consumers in Ecosystem 1
                      (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                      # Nutrient flux for primary producers in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                      # Nutrient flux for consumers in Ecosystem 2
                      (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Total flux in Ecosystem 1
                      (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Total flux in Ecosystem 2
                      (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                      # Nutrient flux in the Dispersers' Pool
                      (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Primary productivity in Ecosystem 1
                      ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                      # Secondary (=consumers) productivity in Ecosystem 1
                      (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                      # Primary productivity in Ecosystem 2
                      ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                      # Secondary (=consumer) productivity in Ecosystem 2
                      (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AlongEq_E1invert_c <- AlongEq_E1invert_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)

```

And, finally, check for stability.

```{r ivrt-bm-along-lsa-c-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Along_c <- NULL

for (i in 1:nrow(AlongEq_E1invert_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AlongEq_E1invert_c$I1[i]
  I2 = AlongEq_E1invert_c$I2[i]
  l = AlongEq_E1invert_c$l[i]
  u1 = AlongEq_E1invert_c$u1[i]
  u2 = AlongEq_E1invert_c$u2[i]
  a1 = AlongEq_E1invert_c$a1[i]
  a2 = AlongEq_E1invert_c$a2[i]
  h1 = AlongEq_E1invert_c$h1[i]
  h2 = AlongEq_E1invert_c$h2[i]
  d1 = AlongEq_E1invert_c$d1[i]
  d2 = AlongEq_E1invert_c$d2[i]
  g = AlongEq_E1invert_c$g[i]
  m = AlongEq_E1invert_c$m[i]
  c = AlongEq_E1invert_c$c[i]
  e1 = AlongEq_E1invert_c$e1[i]
  e2 = AlongEq_E1invert_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AlongEq_E1invert_c$Q[i]
  dN1 = AlongEq_E1invert_c$N1[i]
  dP1 = AlongEq_E1invert_c$P1[i]
  dC1 = AlongEq_E1invert_c$C1[i]
  dN2 = AlongEq_E1invert_c$N2[i]
  dP2 = AlongEq_E1invert_c$P2[i]
  dC2 = AlongEq_E1invert_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Along_c <- rbind(StabCheck_E1invert_Along_c, 
                                      data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                 a1, a2, h1, h2, d1, d2, g, 
                                                 m, c, e1, e2, dQ, dN1, dP1,
                                                 dC1, dN2, dP2, dC2,
                                                 EiV1 = Re(eigen(Jacob)$values[1]),
                                                 EiV2 = Re(eigen(Jacob)$values[2]),
                                                 EiV3 = Re(eigen(Jacob)$values[3]),
                                                 EiV4 = Re(eigen(Jacob)$values[4]),
                                                 EiV5 = Re(eigen(Jacob)$values[5]),
                                                 EiV6 = Re(eigen(Jacob)$values[6]),
                                                 EiV7 = Re(eigen(Jacob)$values[7]),
                                                 maxEv = max(Re(base::eigen(Jacob)$values)),
                                                 stable = stable,
                                                 biosense = AlongEq_E1invert_c$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Along_c$stable <- as.factor(StabCheck_E1invert_Along_c$stable)

# separate unstable equilibria to work with later
Along_E1invert_c_Unstab <- subset(StabCheck_E1invert_Along_c, 
                                  StabCheck_E1invert_Along_c$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Along_E1invert_c_Unstab)/nrow(StabCheck_E1invert_Along_c))*100, digits = 3)`** 
parameter sets appear to be unstable.
:::

:::::

##### Against-gradient scenario

Remove the along-gradient mean parameter values and store this 
scenario's mean parameter values in named objects to use in local sensitivity 
analysis run below.

```{r ivrt-bm-against-lsa-mean-params, echo=TRUE, tidy=TRUE}
rm(list = c('I1_m', 'I2_m', 'l_m', 'a1_m', 'a2_m', 'u1_m', 'u2_m', 'h1_m', 
            'h2_m', 'd1_m', 'd2_m', 'g_m', 'c_m', 'm_m', 'e1_m', 'e2_m'))

I1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(I1) %>% mean()
I2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(I2) %>% mean()
l_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(l) %>% mean()
a1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(a1) %>% mean()
a2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(a2) %>% mean()
u1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(u1) %>% mean()
u2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(u2) %>% mean()
h1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(h1) %>% mean()
h2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(h2) %>% mean()
d1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(d1) %>% mean()
d2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(d2) %>% mean()
g_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(g) %>% mean()
m_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(m) %>% mean()
c_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(c) %>% mean()
e1_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(e1) %>% mean()
e2_m <- ecoCR %>% filter(., Fertility == "Against" & biosense == "yes" & E1CRabove1 == "Y") %>% pull(e2) %>% mean()
```

The set of five panels below runs a LSA for each focal parameter.

::::: {.panelset}

::: {.panel}

###### Attack rate in Ecosystem 1

Sample values for _a~1~_.

```{r ivrt-bm-against-lsa-a1-values-gen, echo=TRUE,tidy=TRUE}
DATA_E1invert_against_lsa_a1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Run the LSA.

```{r ivrt-bm-against-lsa-a1, echo=TRUE,tidy=TRUE}
AgainstEq_E1invert_a1 <- NULL

AgainstEq_E1invert_a1 <-rbind(AgainstEq_E1invert_a1, 
                  data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                             l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                             a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                             h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                             g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                             e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                             P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                             P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                             FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                             FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                             FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                             FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                             PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                             PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_against_lsa_a1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- DATA_E1invert_against_lsa_a1[i1]
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1invert_a1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AgainstEq_E1invert_a1 <- AgainstEq_E1invert_a1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability.

```{r ivrt-bm-against-lsa-a1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Against_a1 <- NULL

for (i in 1:nrow(AgainstEq_E1invert_a1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1invert_a1$I1[i]
  I2 = AgainstEq_E1invert_a1$I2[i]
  l = AgainstEq_E1invert_a1$l[i]
  u1 = AgainstEq_E1invert_a1$u1[i]
  u2 = AgainstEq_E1invert_a1$u2[i]
  a1 = AgainstEq_E1invert_a1$a1[i]
  a2 = AgainstEq_E1invert_a1$a2[i]
  h1 = AgainstEq_E1invert_a1$h1[i]
  h2 = AgainstEq_E1invert_a1$h2[i]
  d1 = AgainstEq_E1invert_a1$d1[i]
  d2 = AgainstEq_E1invert_a1$d2[i]
  g = AgainstEq_E1invert_a1$g[i]
  m = AgainstEq_E1invert_a1$m[i]
  c = AgainstEq_E1invert_a1$c[i]
  e1 = AgainstEq_E1invert_a1$e1[i]
  e2 = AgainstEq_E1invert_a1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1invert_a1$Q[i]
  dN1 = AgainstEq_E1invert_a1$N1[i]
  dP1 = AgainstEq_E1invert_a1$P1[i]
  dC1 = AgainstEq_E1invert_a1$C1[i]
  dN2 = AgainstEq_E1invert_a1$N2[i]
  dP2 = AgainstEq_E1invert_a1$P2[i]
  dC2 = AgainstEq_E1invert_a1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Against_a1 <- rbind(StabCheck_E1invert_Against_a1, 
                                         data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                    a1, a2, h1, h2, d1, d2, g, 
                                                    m, c, e1, e2, dQ, dN1, dP1,
                                                    dC1, dN2, dP2, dC2,
                                                    EiV1 = Re(eigen(Jacob)$values[1]),
                                                    EiV2 = Re(eigen(Jacob)$values[2]),
                                                    EiV3 = Re(eigen(Jacob)$values[3]),
                                                    EiV4 = Re(eigen(Jacob)$values[4]),
                                                    EiV5 = Re(eigen(Jacob)$values[5]),
                                                    EiV6 = Re(eigen(Jacob)$values[6]),
                                                    EiV7 = Re(eigen(Jacob)$values[7]),
                                                    maxEv = max(Re(base::eigen(Jacob)$values)),
                                                    stable = stable,
                                                    biosense = AgainstEq_E1invert_a1$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Against_a1$stable <- as.factor(StabCheck_E1invert_Against_a1$stable)

# separate unstable equilibria to work with later
Against_E1invert_a1_Unstab <- subset(StabCheck_E1invert_Against_a1, 
                                     StabCheck_E1invert_Against_a1$stable == "unstable")

rm(Jacob)

```

**`r prettyNum((nrow(Against_E1invert_a1_Unstab)/nrow(StabCheck_E1invert_Against_a1))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Death rate in Ecosystem 1

Sample values for _d~1~_. 

```{r ivrt-bm-against-lsa-d1-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1invert_against_lsa_d1 <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r ivrt-bm-against-lsa-d1, echo=TRUE, tidy=TRUE}
AgainstEq_E1invert_d1 <- NULL

AgainstEq_E1invert_d1 <-rbind(AgainstEq_E1invert_d1, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_against_lsa_d1)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- DATA_E1invert_against_lsa_d1[i1]
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1invert_d1[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                         # Nutrient stock in ecosystem 1
                         ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary Producers biomass in ecosystem 1
                         (d1+g)/(a1*e1),
                         # Consumers biomass in ecosystem 1
                         (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Nutrient stock in ecosystem 2
                         (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                         # Primary Producers biomass in ecosystem 2
                         (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Consumer biomass in ecosystem 2
                         ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Consumer biomass in the Dispersers' Pool (Q)
                         (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Nutrient flux for primary producers in Ecosystem 1
                         ((d1+g)*h1)/(a1*e1),
                         # Nutrient flux for consumers in Ecosystem 1
                         (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                         # Nutrient flux for primary producers in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                         # Nutrient flux for consumers in Ecosystem 2
                         (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Total flux in Ecosystem 1
                         (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Total flux in Ecosystem 2
                         (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                         # Nutrient flux in the Dispersers' Pool
                         (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Primary productivity in Ecosystem 1
                         ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                         # Secondary (=consumers) productivity in Ecosystem 1
                         (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                         # Primary productivity in Ecosystem 2
                         ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                         # Secondary (=consumer) productivity in Ecosystem 2
                         (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so 
# let's flag them

AgainstEq_E1invert_d1 <- AgainstEq_E1invert_d1 %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability.

```{r ivrt-bm-against-lsa-d1-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Against_d1 <- NULL

for (i in 1:nrow(AgainstEq_E1invert_d1)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1invert_d1$I1[i]
  I2 = AgainstEq_E1invert_d1$I2[i]
  l = AgainstEq_E1invert_d1$l[i]
  u1 = AgainstEq_E1invert_d1$u1[i]
  u2 = AgainstEq_E1invert_d1$u2[i]
  a1 = AgainstEq_E1invert_d1$a1[i]
  a2 = AgainstEq_E1invert_d1$a2[i]
  h1 = AgainstEq_E1invert_d1$h1[i]
  h2 = AgainstEq_E1invert_d1$h2[i]
  d1 = AgainstEq_E1invert_d1$d1[i]
  d2 = AgainstEq_E1invert_d1$d2[i]
  g = AgainstEq_E1invert_d1$g[i]
  m = AgainstEq_E1invert_d1$m[i]
  c = AgainstEq_E1invert_d1$c[i]
  e1 = AgainstEq_E1invert_d1$e1[i]
  e2 = AgainstEq_E1invert_d1$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1invert_d1$Q[i]
  dN1 = AgainstEq_E1invert_d1$N1[i]
  dP1 = AgainstEq_E1invert_d1$P1[i]
  dC1 = AgainstEq_E1invert_d1$C1[i]
  dN2 = AgainstEq_E1invert_d1$N2[i]
  dP2 = AgainstEq_E1invert_d1$P2[i]
  dC2 = AgainstEq_E1invert_d1$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Against_d1 <- rbind(StabCheck_E1invert_Against_d1, 
                                         data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                    a1, a2, h1, h2, d1, d2, g, 
                                                    m, c, e1, e2, dQ, dN1, dP1,
                                                    dC1, dN2, dP2, dC2,
                                                    EiV1 = Re(eigen(Jacob)$values[1]),
                                                    EiV2 = Re(eigen(Jacob)$values[2]),
                                                    EiV3 = Re(eigen(Jacob)$values[3]),
                                                    EiV4 = Re(eigen(Jacob)$values[4]),
                                                    EiV5 = Re(eigen(Jacob)$values[5]),
                                                    EiV6 = Re(eigen(Jacob)$values[6]),
                                                    EiV7 = Re(eigen(Jacob)$values[7]),
                                                    maxEv = max(Re(base::eigen(Jacob)$values)),
                                                    stable = stable,
                                                    biosense = AgainstEq_E1invert_d1$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Against_d1$stable <- as.factor(StabCheck_E1invert_Against_d1$stable)

# separate unstable equilibria to work with later
Against_E1invert_d1_Unstab <- subset(StabCheck_E1invert_Against_d1, 
                                     StabCheck_E1invert_Against_d1$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_E1invert_d1_Unstab)/nrow(StabCheck_E1invert_Against_d1))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate into Q

Sample values for _g_.

```{r ivrt-bm-against-lsa-g-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1invert_against_lsa_g <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then,run the LSA.

```{r ivrt-bm-against-lsa-g, echo=TRUE,tidy=TRUE}
AgainstEq_E1invert_g <- NULL

AgainstEq_E1invert_g <-rbind(AgainstEq_E1invert_g, 
                     data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                                l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                                a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                                h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                                g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                                e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                                P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                                P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                                FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                                FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                                FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                                FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                                PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                                PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_against_lsa_g)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- DATA_E1invert_against_lsa_g[i1]
  m <- m_m
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1invert_g[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_E1invert_g <- AgainstEq_E1invert_g %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

Finally, check for stability.

```{r ivrt-bm-against-lsa-g-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Against_g <- NULL

for (i in 1:nrow(AgainstEq_E1invert_g)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1invert_g$I1[i]
  I2 = AgainstEq_E1invert_g$I2[i]
  l = AgainstEq_E1invert_g$l[i]
  u1 = AgainstEq_E1invert_g$u1[i]
  u2 = AgainstEq_E1invert_g$u2[i]
  a1 = AgainstEq_E1invert_g$a1[i]
  a2 = AgainstEq_E1invert_g$a2[i]
  h1 = AgainstEq_E1invert_g$h1[i]
  h2 = AgainstEq_E1invert_g$h2[i]
  d1 = AgainstEq_E1invert_g$d1[i]
  d2 = AgainstEq_E1invert_g$d2[i]
  g = AgainstEq_E1invert_g$g[i]
  m = AgainstEq_E1invert_g$m[i]
  c = AgainstEq_E1invert_g$c[i]
  e1 = AgainstEq_E1invert_g$e1[i]
  e2 = AgainstEq_E1invert_g$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1invert_g$Q[i]
  dN1 = AgainstEq_E1invert_g$N1[i]
  dP1 = AgainstEq_E1invert_g$P1[i]
  dC1 = AgainstEq_E1invert_g$C1[i]
  dN2 = AgainstEq_E1invert_g$N2[i]
  dP2 = AgainstEq_E1invert_g$P2[i]
  dC2 = AgainstEq_E1invert_g$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Against_g <- rbind(StabCheck_E1invert_Against_g, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2, 
                                                   a1, a2, h1, h2, d1, d2, g, 
                                                   m, c, e1, e2, dQ, dN1, dP1,
                                                   dC1, dN2, dP2, dC2, 
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = AgainstEq_E1invert_g$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Against_g$stable <- as.factor(StabCheck_E1invert_Against_g$stable)

# separate unstable equilibria to work with later
Against_E1invert_g_Unstab <- subset(StabCheck_E1invert_Against_g, 
                                    StabCheck_E1invert_Against_g$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_E1invert_g_Unstab)/nrow(StabCheck_E1invert_Against_g))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Movement rate from Q

Sample values for _m_.

```{r ivrt-bm-against-lsa-m-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1invert_against_lsa_m <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Then, run the LSA.

```{r ivrt-bm-against-lsa-m, echo=TRUE,tidy=TRUE}
AgainstEq_E1invert_m <- NULL

AgainstEq_E1invert_m <-rbind(AgainstEq_E1invert_m, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_against_lsa_m)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- DATA_E1invert_against_lsa_m[i1]
  c <- c_m
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1invert_m[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_E1invert_m <- AgainstEq_E1invert_m %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability.

```{r ivrt-bm-against-lsa-m-local-stab, echo=TRUE,tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Against_m <- NULL

for (i in 1:nrow(AgainstEq_E1invert_m)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1invert_m$I1[i]
  I2 = AgainstEq_E1invert_m$I2[i]
  l = AgainstEq_E1invert_m$l[i]
  u1 = AgainstEq_E1invert_m$u1[i]
  u2 = AgainstEq_E1invert_m$u2[i]
  a1 = AgainstEq_E1invert_m$a1[i]
  a2 = AgainstEq_E1invert_m$a2[i]
  h1 = AgainstEq_E1invert_m$h1[i]
  h2 = AgainstEq_E1invert_m$h2[i]
  d1 = AgainstEq_E1invert_m$d1[i]
  d2 = AgainstEq_E1invert_m$d2[i]
  g = AgainstEq_E1invert_m$g[i]
  m = AgainstEq_E1invert_m$m[i]
  c = AgainstEq_E1invert_m$c[i]
  e1 = AgainstEq_E1invert_m$e1[i]
  e2 = AgainstEq_E1invert_m$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1invert_m$Q[i]
  dN1 = AgainstEq_E1invert_m$N1[i]
  dP1 = AgainstEq_E1invert_m$P1[i]
  dC1 = AgainstEq_E1invert_m$C1[i]
  dN2 = AgainstEq_E1invert_m$N2[i]
  dP2 = AgainstEq_E1invert_m$P2[i]
  dC2 = AgainstEq_E1invert_m$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Against_m <- rbind(StabCheck_E1invert_Against_m, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2,
                                                   a1, a2, h1, h2, d1, d2, g, 
                                                   m, c, e1, e2, dQ, dN1, dP1,
                                                   dC1, dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = AgainstEq_E1invert_m$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Against_m$stable <- as.factor(StabCheck_E1invert_Against_m$stable)

# separate unstable equilibria to work with later
Against_E1invert_m_Unstab <- subset(StabCheck_E1invert_Against_m, 
                                    StabCheck_E1invert_Against_m$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_E1invert_m_Unstab)/nrow(StabCheck_E1invert_Against_m))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

::: {.panel}

###### Death rate in Q

Start by sampling values for _c_.

```{r ivrt-bm-against-lsa-c-values-gen, echo=TRUE, tidy=TRUE}
DATA_E1invert_against_lsa_c <- sample(seq(0.01, 10, 0.01), size = 1000, replace = FALSE)
```

Now, run the LSA.

```{r ivrt-bm-against-lsa-c, echo=TRUE, tidy=TRUE}
AgainstEq_E1invert_c <- NULL

AgainstEq_E1invert_c <-rbind(AgainstEq_E1invert_c, 
                    data.frame(TIME=seq(0,100,1), I1 = seq(0,100,1), I2 = seq(0,100,1), 
                               l = seq(0,100,1), u1 = seq(0,100,1), u2 = seq(0,100,1), 
                               a1 = seq(0,100,1), a2 = seq(0,100,1), h1 = seq(0,100,1), 
                               h2 = seq(0,100,1), d1 = seq(0,100,1), d2 = seq(0,100,1), 
                               g = seq(0,100,1), m = seq(0,100,1), c = seq(0,100,1), 
                               e1 = seq(0,100,1), e2 = seq(0,100,1), N1 = seq(0,100,1), 
                               P1 = seq(0,100,1), C1 = seq(0,100,1), N2 = seq(0,100,1), 
                               P2 = seq(0,100,1), C2 = seq(0,100,1), Q = seq(0,100,1), 
                               FLUX_P1 = seq(0,100,1), FLUX_C1 = seq(0,100,1), 
                               FLUX_P2 = seq(0,100,1), FLUX_C2 = seq(0,100,1), 
                               FLUX_Eco_1 = seq(0,100,1), FLUX_Eco_2 = seq(0,100,1), 
                               FLUX_Q = seq(0,100,1), PROD_P1 = seq(0,100,1), 
                               PROD_C1 = seq(0,100,1), PROD_P2 = seq(0,100,1), 
                               PROD_C2 = seq(0,100,1)))

# We want to start simulations at 0
i1 = 0

for (i in 1:length(DATA_E1invert_against_lsa_c)){
  # go to the next row
  i1 = i1 + 1
  
  # assign parameter values
  I1 <- I1_m
  I2 <- I2_m
  l_m <- l_m
  a1 <- a1_m
  a2 <- a2_m
  u1 <- u1_m
  u2 <- u2_m
  h1 <- h1_m
  h2 <- h2_m
  d1 <- d1_m
  d2 <- d2_m
  g <- g_m
  m <- m_m
  c <- DATA_E1invert_against_lsa_c[i1]
  e1 <- e1_m
  e2 <- e2_m
  
  AgainstEq_E1invert_c[i1,] <- c(i1, I1, I2, l, u1, u2, a1, a2, h1, h2, d1, d2, g, m, c, e1, e2,
                        # Nutrient stock in ecosystem 1
                        ((d1-d1*e1+g)*h1+a1*e1*I1)/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary Producers biomass in ecosystem 1
                        (d1+g)/(a1*e1),
                        # Consumers biomass in ecosystem 1
                        (e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Nutrient stock in ecosystem 2
                        (-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)),
                        # Primary Producers biomass in ecosystem 2
                        (l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Consumer biomass in ecosystem 2
                        ((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Consumer biomass in the Dispersers' Pool (Q)
                        (e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Nutrient flux for primary producers in Ecosystem 1
                        ((d1+g)*h1)/(a1*e1),
                        # Nutrient flux for consumers in Ecosystem 1
                        (d1*e1*(-h1*l + I1*u1))/(a1*e1*l+(d1-d1*e1 + g)*u1),
                        # Nutrient flux for primary producers in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2),
                        # Nutrient flux for consumers in Ecosystem 2
                        (d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Total flux in Ecosystem 1
                        (((d1+g)*h1)/(a1*e1))+(d1*e1*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Total flux in Ecosystem 2
                        (h2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)+(d2*((e1*g*m*(-h1*l+I1*u1)*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1))+e2*(-h2*l+I2*u2)))/(a2*e2*l-d2*(-1+e2)*u2),
                        # Nutrient flux in the Dispersers' Pool
                        (c*e1*g*(-h1*l+I1*u1))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Primary productivity in Ecosystem 1
                        ((d1+g)*((d1-d1*e1+g)*h1+a1*e1*I1)*u1)/(a1*e1*(a1*e1*l+(d1-d1*e1+g)*u1)),
                        # Secondary (=consumers) productivity in Ecosystem 1
                        (e1*(d1+g)*(-h1*l+I1*u1))/(a1*e1*l+(d1-d1*e1+g)*u1),
                        # Primary productivity in Ecosystem 2
                        ((-a1*e1*(d2*(-1+e2)*h2-a2*e2*I2)*l*(c+m)+d2*(-1+e2)*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*(e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1))))*u2*(l*(-d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(-h1*l+I1*u1))+d2*(d1*e1*I2*(c+m)*u1-(d1+g)*I2*(c+m)*u1+e1*g*m*(h1*l-I1*u1))*u2+a1*d2*e1*l*(c+m)*(h2*l-I2*u2)))/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2)*(a2*e2*h2*l*(c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)-a2*(a1*e1*e2*I2*l*(c+m)+e2*(d1+g)*I2*(c+m)*u1-e1*(d1*e2*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)),
                        # Secondary (=consumer) productivity in Ecosystem 2
                        (e2*l*(-a1*d2*e1*h2*l*(c+m)+d2*(d1*(-1+e1)-g)*h2*(c+m)*u1+a2*e1*g*m*(h1*l-I1*u1))+d2*e2*(a1*e1*I2*l*(c+m)+(d1+g)*I2*(c+m)*u1-e1*(d1*I2*(c+m)*u1+g*m*(h1*l-I1*u1)))*u2)/((c+m)*(a1*e1*l+(d1-d1*e1+g)*u1)*(a2*e2*l-d2*(-1+e2)*u2))
  )
}

# Equilibrium stocks less than or equal to 0 make no biological sense, so let's 
# flag them

AgainstEq_E1invert_c <- AgainstEq_E1invert_c %>% 
  dplyr::mutate(., biosense = ifelse(N1 > 0 & P1 > 0 & C1 > 0 & N2 > 0 & 
                                       P2 > 0 & C2 > 0 & Q > 0, "yes", "no"), 
                .after = Q) %>% 
  dplyr::mutate_at(vars(biosense), factor)
```

And then check for stability.

```{r ivrt-bm-against-lsa-c-local-stab, echo=TRUE, tidy=TRUE}
# create an empty dataframe
StabCheck_E1invert_Against_c <- NULL

for (i in 1:nrow(AgainstEq_E1invert_c)) {
  
  # fetch parameter values from the equilibrium simulations df
  I1 = AgainstEq_E1invert_c$I1[i]
  I2 = AgainstEq_E1invert_c$I2[i]
  l = AgainstEq_E1invert_c$l[i]
  u1 = AgainstEq_E1invert_c$u1[i]
  u2 = AgainstEq_E1invert_c$u2[i]
  a1 = AgainstEq_E1invert_c$a1[i]
  a2 = AgainstEq_E1invert_c$a2[i]
  h1 = AgainstEq_E1invert_c$h1[i]
  h2 = AgainstEq_E1invert_c$h2[i]
  d1 = AgainstEq_E1invert_c$d1[i]
  d2 = AgainstEq_E1invert_c$d2[i]
  g = AgainstEq_E1invert_c$g[i]
  m = AgainstEq_E1invert_c$m[i]
  c = AgainstEq_E1invert_c$c[i]
  e1 = AgainstEq_E1invert_c$e1[i]
  e2 = AgainstEq_E1invert_c$e2[i]
  
  # Put in the solutions to the equilibrium values here:
  dQ = AgainstEq_E1invert_c$Q[i]
  dN1 = AgainstEq_E1invert_c$N1[i]
  dP1 = AgainstEq_E1invert_c$P1[i]
  dC1 = AgainstEq_E1invert_c$C1[i]
  dN2 = AgainstEq_E1invert_c$N2[i]
  dP2 = AgainstEq_E1invert_c$P2[i]
  dC2 = AgainstEq_E1invert_c$C2[i]
  
  # create the Jacobian from Mathematica
  # NOTE: in transposing from Mathematica, the Jacobian is here assembled by row
  Jacob <- rbind(c(-c-m, 0, 0, g, 0, 0, 0),
                 c(0, -l-dP1*u1, h1-dN1*u1, d1, 0, 0, 0), 
                 c(0, dP1*u1, -a1*dC1-h1+dN1*u1, -a1*dP1, 0, 0, 0), 
                 c(0, 0, a1*dC1*e1, -d1-g+a1*e1*dP1, 0, 0, 0), 
                 c(0, 0, 0, 0, -l-dP2*u2, h2-dN2*u2, d2), 
                 c(0, 0, 0, 0, dP2*u2, -a2*dC2-h2+dN2*u2, -a2*dP2), 
                 c(m, 0, 0, 0, 0, a2*dC2*e2, -d2+a2*e2*dP2))
  
  # Check to see if the real part of the leading eigenvalue is less than 0 or not
  # if it is then the system is stable.
  if (max(Re(base::eigen(Jacob)$values)) < 0 ){ 
    stable <- "stable"
  } else {
    stable <- "unstable"
  }
  
  StabCheck_E1invert_Against_c <- rbind(StabCheck_E1invert_Against_c, 
                                        data.frame(TIME=i, I1, I2, l, u1, u2, a1, 
                                                   a2, h1, h2, d1, d2, g, m, c, 
                                                   e1, e2, dQ, dN1, dP1, dC1, 
                                                   dN2, dP2, dC2,
                                                   EiV1 = Re(eigen(Jacob)$values[1]),
                                                   EiV2 = Re(eigen(Jacob)$values[2]),
                                                   EiV3 = Re(eigen(Jacob)$values[3]),
                                                   EiV4 = Re(eigen(Jacob)$values[4]),
                                                   EiV5 = Re(eigen(Jacob)$values[5]),
                                                   EiV6 = Re(eigen(Jacob)$values[6]),
                                                   EiV7 = Re(eigen(Jacob)$values[7]),
                                                   maxEv = max(Re(base::eigen(Jacob)$values)),
                                                   stable = stable,
                                                   biosense = AgainstEq_E1invert_c$biosense[i]))
  
  # browser()
}

StabCheck_E1invert_Against_c$stable <- as.factor(StabCheck_E1invert_Against_c$stable)

# separate unstable equilibria to work with later
Against_E1invert_c_Unstab <- subset(StabCheck_E1invert_Against_c, 
                                    StabCheck_E1invert_Against_c$stable == "unstable")

rm(Jacob)
```

**`r prettyNum((nrow(Against_E1invert_c_Unstab)/nrow(StabCheck_E1invert_Against_c))*100, digits = 3)`** 
parameter sets appear to be unstable.

:::

:::::

## Visual Deliverables---Sensitivity Analyses

Here, we produce visual deliverables from the local sensitivity analyses run 
above. The code below produces figures reported in the Manuscript 
(**Figures 5**, **6**, **7**, and **8**) and in the Appendices (**Figures D.7**,
**D.8**, **D.9**, **D.10**, **D.11**, **D.12**), as well as other figures that
appear only the present document. As before (see above, 
[Visual Deliverables---Ecosystem Functions] and 
[Visual Deliverables---Biomass distributions]), for figures that appear in 
either the Manuscript or the Appendices, we report only the code necessary to 
reproduce them without showing the actual figure.

### Consumer movement scenario

#### Focal parameter influence on state variables 

The set of figures produced by the code chunks in the tabs below show the 
influence of each focal parameter listed above (see 
[Sensitivity analyses by consumer movement scenario]) on 
each state variable in the model, for each consumer movement scenario 
investigated.

Some of the figures below use a custom facet design, created using function
`facet_manual()` in package `ggh4x`. We create this design in the code chunk below.

```{r lsa-graphs-setup, echo=TRUE, tidy=TRUE}
design <- "A##
           BCD
           EFG"
```

::::: {.panelset}

::: {.panel}

##### Attack rate in Ecosystem 1

This code chunk produces **Figure D.7** in the Appendices, showing the influence
of the consumers' attack rate in the donor ecosystem 1 (_a~1~_) on the seven state 
variables included in our model. Note that, to avoid graphical artifact, we 
remove the top and bottom 5% of values for _P~1~_; graphing these values would 
make it impossible to see distance between the lines in the `y = 0` region of 
the graph.

```{r lsa-graphs-eq-SV-a1, echo=TRUE, tidy=TRUE}
LSA_a1 <- bind_rows(NeutralEq_a1, 
                    AlongEq_a1, 
                    AgainstEq_a1, 
                    .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  dplyr::filter(., between(P1,
                           quantile(P1, 0.05, na.rm = T),
                           quantile(P1, 0.95, na.rm = T))) %>%
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_a1") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(a1, dStock_a1)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer attack rate in the donor ecosystem 1 (", a[1], ")"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_a1

ggsave(filename = "../Results/Equilibrium_LSA_a1.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

::: {.panel}

##### Death rate in Ecosystem 1

Here, we produce **Figure 6** in the Manuscript, showing the influence of the 
consumers' death rate in the donor ecosystem 1 (_d~1~_) on the model's state 
variables.

```{r lsa-graphs-eq-SV-d1, echo=TRUE,tidy=TRUE}
LSA_d1 <- bind_rows(NeutralEq_d1, 
                    AlongEq_d1, 
                    AgainstEq_d1, 
                    .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_d1") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(d1, dStock_d1)) + 
  geom_line(aes(color = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer death rate in the donor ecosystem 1 (", d[1], ")"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_d1

ggsave(filename = "../Results/Equilibrium_LSA_d1.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

::: {.panel}

##### Movement rate into Q

This code chunk produces **Figure 5** in the Manuscript, showing how the 
consumers' movement rate from the donor ecosystem 1 into the dispersers' pool 
_Q_ (_g_) influences the model's state variables.

```{r lsa-graphs-eq-SV-g, echo=TRUE, tidy=TRUE}
LSA_g <- bind_rows(NeutralEq_g, 
                   AlongEq_g, 
                   AgainstEq_g, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_g") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(g, dStock_g)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer movement rate from the donor ecosystem 1 to Q (g)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_g

ggsave(filename = "../Results/Equilibrium_LSA_g.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

::: {.panel}

##### Movement rate from Q

Here, we produce **Figure D.9** in the Appendices, showing how the consumers'
movement rate from the dispersers' pool _Q_ into the recipient ecosystem 2 (_m_)
influences the model's state variables.

```{r lsa-graphs-eq-SV-m, echo=TRUE, tidy=TRUE}
LSA_m <- bind_rows(NeutralEq_m, 
                   AlongEq_m, 
                   AgainstEq_m, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_m") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(m, dStock_m)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer movement rate from Q to the recipient ecosystem 2 (m)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_m

ggsave(filename = "../Results/Equilibrium_LSA_m.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

::: {.panel}

##### Death rate in Q

This code chunk produces **Figure D.11** in the Appendices, showing how the 
death rate of consumers in the dispersers' pool (_c_) influences each state 
variable in the model.

```{r lsa-graphs-eq-SV-c, echo=TRUE, tidy=TRUE}
LSA_c <- bind_rows(NeutralEq_c, 
                   AlongEq_c, 
                   AgainstEq_c, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_c") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(c, dStock_c)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer death rate in the Dispersers' Pool (c)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_c

ggsave(filename = "../Results/Equilibrium_LSA_c.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

:::::

#### Focal parameters influence on ecosystem functions

Here, we produce graphs for the influence of the five focal parameters on nutrient
flux and trophic compartment productivity. Again, these figures are reported in
both the Manuscript and Appendices, so we will show only the code needed to
produce them.

Some of the figures below use a custom palette based of palette 
`Isfahan2` contained in package `MetBrewer` [@metbrewer]. We create this custom 
palette, `lsa_combi_palette`, below using function `met.brewer()` from the same 
package.

```{r lsa-graphs-combi-palette-gen, echo=TRUE, tidy=TRUE}
# create palette
lsa_combi_palette <- met.brewer(name="Isfahan2", n=5, type="discrete")
lsa_combi_palette <- lsa_combi_palette[-c(1,2)]
lsa_combi_palette2 <- c(lsa_combi_palette[1], lsa_combi_palette[3], lsa_combi_palette[2])
```

::::: {.panelset}

::: {.panel}

##### Attack rate in Ecosystem 1

Here, we produce **Figure D.8** in the Appendices, showing the influence of
the consumers' attack rate in the donor ecosystem 1 (_a~1~_) on the nutrient flux
(solid lines) and trophic compartment productivity (dashed lines) of the primary
producers (green) and consumers (blue) compartments. Panels are organized by 
spatial scale on the x-axis (top facet labels) and consumer movement scenario on
the y-axis (right side facet labels). Note that, as in Figure \@ref(fig:lsa-graphs-eq-SV-a1), we remove the top and bottom 5% of values for _P~1~_ to avoid graphical artifacts.

```{r lsa-graphs-eq-EF-a1, echo=TRUE, tidy=TRUE}
LSA_a1_combi <- bind_rows(NeutralEq_a1,
                         AlongEq_a1,
                         AgainstEq_a1,
                         .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  dplyr::filter(., between(P1,
                           quantile(P1, 0.05, na.rm = T),
                           quantile(P1, 0.95, na.rm = T))) %>%
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(a1, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer attack rate in the donor ecosystem 1 (", a[1], ")"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_a1_combi

ggsave(filename = "../Results/LSA_a1_eq_combi.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

::: {.panel}

##### Death rate in Ecosystem 1

This code chunk produces **Figure 8** in the Manuscript, showing the influence of
the consumers' death rate in the donor ecosystem 1 (_d~1~_) on the nutrient flux
(solid lines) and trophic compartment productivity (dashed lines) of the primary
producers (green) and consumers (blue) compartments. Panels are organized by 
spatial scale on the x-axis (top facet labels) and consumer movement scenario on
the y-axis (right side facet labels). 

```{r lsa-graphs-eq-EF-d1, echo=TRUE, tidy=TRUE}
LSA_d1_combi <- bind_rows(NeutralEq_d1,
                         AlongEq_d1,
                         AgainstEq_d1,
                         .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(d1, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer death rate in the donor ecosystem 1 (", d[1], ")"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_d1_combi

ggsave(filename = "../Results/LSA_d1_eq_combi.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

::: {.panel}

##### Movement rate into Q

The next code chunk produces **Figure 7** in the Manuscript, showing the influence of
the consumers' movement rate from the donor ecosystem 1 into the dispersers' 
pool _Q_ (_g_) on nutrient flux (solid lines) and trophic compartment productivity
(dashed lines) of the primary producers (green) and consumers (blue) compartments. 
Panels are organized by spatial scale on the x-axis (top facet labels) and 
consumer movement scenario on the y-axis (right side facet labels). 

```{r lsa-graphs-eq-EF-g, echo=TRUE, tidy=TRUE}
LSA_g_combi <- bind_rows(NeutralEq_g,
                             AlongEq_g,
                             AgainstEq_g,
                             .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(g, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer movement rate from the donor ecosystem 1 to Q (g)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_g_combi

ggsave(filename = "../Results/LSA_g_eq_combi.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

::: {.panel}

##### Movement rate from Q

Below, we produce **Figure D.10** in the Appendices, showing the influence of
the consumers' movement rate from the disperses' pool _Q_ into the recipient 
ecosystem 2 (_m_) on nutrient flux (solid lines) and trophic compartment productivity
(dashed lines) of the primary producers (green) and consumers (blue) compartments. 
Panels are organized by spatial scale on the x-axis (top facet labels) and 
consumer movement scenario on the y-axis (right side facet labels). 

```{r lsa-graphs-eq-EF-m, echo=TRUE, tidy=TRUE}
LSA_m_combi <- bind_rows(NeutralEq_m,
                         AlongEq_m,
                         AgainstEq_m,
                         .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(m, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer movement rate from Q to the recipient ecosystem 2 (m)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_m_combi

ggsave(filename = "../Results/LSA_m_eq_combi.svg", device = "svg", dpi = 300, width = width, height = height)
```

:::

::: {.panel}

##### Death rate in Q

This code chunk produces **Figure D.12** in the Appendices, showing the influence of
the consumers' death rate in the disperses' pool _Q_ (_c_) on nutrient flux 
(solid lines) and trophic compartment productivity (dashed lines) of the 
primary producers (green) and consumers (blue) compartments. Panels are 
organized by spatial scale on the x-axis (top facet labels) and 
consumer movement scenario on the y-axis (right side facet labels). 

```{r lsa-graphs-eq-EF-c, echo=TRUE, tidy=TRUE}
LSA_c_combi <- bind_rows(NeutralEq_c,
                         AlongEq_c,
                         AgainstEq_c,
                         .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(c, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer death rate in Q (c)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))

# LSA_c_combi

ggsave(filename = "../Results/LSA_c_eq_combi.svg", device = "svg", dpi = 300, width = width, height = height)
```
:::

:::::

### Biomass distribution

#### Focal parameter influence on state variables 

Here, we produce figures for the results of the [Sensitivity analyses by biomass distribution]. 
In each tab below, for each focal parameter, we produce two figures. The first 
one is  for the results from the LSA run using non-focal parameter mean values 
from the subset of `ecoCR` where the donor ecosystem 1 has a classic, pyramidal 
biomass distribution. The second one, uses the results from the LSA run using
non-focal parameter mean values from the `ecoCR` subset where the donor 
ecosystem 1 has an inverted, top-heavy biomass distribution.

Note that, in some of the figures below, lines may not span the whole
range of values on the x-axis and appear truncated. This is an 
analyses artifact. Recall that, when running our 
[Sensitivity analysis by biomass distribution], we subsetted `ecoCR` 
to isolate bottom- and top-heavy biomass distribution in the donor 
ecosystem 1. The seemingly missing values in the plots below reflect 
this.

::::: {.panelset}

::: {.panel}

##### Attack rate in Ecosystem 1

This code chunk produces the equivalent of **Figure D.7** in the Appendices, but 
for the case where the donor ecosystem 1 has a bottom-heavy biomass distribution. Note that, as in Figure \@ref(fig:lsa-graphs-eq-SV-a1), we remove the top and bottom 5% of values for _P~1~_ to avoid graphical artifacts.

```{r cls-bm-lsa-graphs-eq-SV-a1, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_a1, 
          AlongEq_E1pyram_a1, 
          AgainstEq_E1pyram_a1, 
          .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  dplyr::filter(., between(P1,
                           quantile(P1, 0.05, na.rm = T),
                           quantile(P1, 0.95, na.rm = T))) %>%
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_a1") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(a1, dStock_a1)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer attack rate in the donor ecosystem 1 (", a[1], ")"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

And the next figure shows instead the results for the donor ecosystem 1 having 
a top-heavy biomass distribution. Again, compare this with **Figure D.7** in the
Appendices. Note that, as in Figure \@ref(fig:lsa-graphs-eq-SV-a1), we remove the top and bottom 5% of values for _P~1~_ to avoid graphical artifacts.

```{r ivrt-bm-lsa-graphs-eq-SV-a1, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_a1, 
          AlongEq_E1invert_a1, 
          AgainstEq_E1invert_a1, 
          .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  dplyr::filter(., between(P1,
                           quantile(P1, 0.05, na.rm = T),
                           quantile(P1, 0.95, na.rm = T))) %>%
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_a1") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(a1, dStock_a1)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer attack rate in the donor ecosystem 1 (", a[1], ")"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

::: {.panel}

##### Death rate in Ecosystem 1

Here, we reproduce **Figure 6** in the Manuscript but using only the results when
the donor ecosystem 1 has a bottom-heavy biomass distribution (i.e., pyramidal).

```{r cls-bm-lsa-graphs-eq-SV-d1, echo=TRUE,tidy=TRUE}
bind_rows(NeutralEq_E1pyram_d1, 
          AlongEq_E1pyram_d1, 
          AgainstEq_E1pyram_d1, 
          .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_d1") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(d1, dStock_d1)) + 
  geom_line(aes(color = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer death rate in the donor ecosystem 1 (", d[1], ")"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

And here is the counterpart to the previous figure, where the donor ecosystem 1
has a top-heavy biomass distribution. 

```{r ivrt-bm-lsa-graphs-eq-SV-d1, echo=TRUE,tidy=TRUE}
bind_rows(NeutralEq_E1invert_d1, 
          AlongEq_E1invert_d1, 
          AgainstEq_E1invert_d1, 
          .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_d1") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(d1, dStock_d1)) + 
  geom_line(aes(color = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                           name = "Consumer movement", 
                           labels = c("Equal", 
                                      "Along-gradient", 
                                      "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer death rate in the donor ecosystem 1 (", d[1], ")"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

::: {.panel}

##### Movement rate into Q

This code chunk reproduces **Figure 5** in the Manuscript, but for cases of the 
donor ecosystem 1 having a bottom-heavy, pyramidal biomass distribution.

```{r cls-bm-lsa-graphs-eq-SV-g, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_g, 
                   AlongEq_E1pyram_g, 
                   AgainstEq_E1pyram_g, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_g") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(g, dStock_g)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer movement rate from the donor ecosystem 1 to Q (g)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

Below, we show the same figure but for when the donor ecosystem 1 has a top-heavy
biomass distribution.

```{r ivrt-bm-lsa-graphs-eq-SV-g, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_g, 
                   AlongEq_E1invert_g, 
                   AgainstEq_E1invert_g, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_g") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(g, dStock_g)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer movement rate from the donor ecosystem 1 to Q (g)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

::: {.panel}

##### Movement rate from Q

The code chunk below reproduces **Figure D.9** in the Appendices, but only for
a donor ecosystem 1 with a bottom-heavy biomass distribution.

```{r cls-bmlsa-graphs-eq-SV-m, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_m, 
                   AlongEq_E1pyram_m, 
                   AgainstEq_E1pyram_m, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_m") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(m, dStock_m)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer movement rate from Q to the recipient ecosystem 2 (m)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

And here is the counterpart, for a donor ecosystem 1 with a top-heavy biomass
distribution.

```{r ivrt-bm-lsa-graphs-eq-SV-m, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_m, 
                   AlongEq_E1invert_m, 
                   AgainstEq_E1invert_m, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_m") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(m, dStock_m)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer movement rate from Q to the recipient ecosystem 2 (m)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

::: {.panel}

##### Death rate in Q

This code chunk reproduces **Figure D.11** in the Appendices, when the donor
ecosystem 1 has a classical, bottom-heavy biomass distribution.

```{r cls-bm-lsa-graphs-eq-SV-c, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_c, 
                   AlongEq_E1pyram_c, 
                   AgainstEq_E1pyram_c, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_c") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(c, dStock_c)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer death rate in the Dispersers' Pool (c)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

The following, instead, shows the case of the donor ecosystem 1 having a top-heavy
biomass distribution.

```{r ivrt-bm-lsa-graphs-eq-SV-c, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_c, 
                   AlongEq_E1invert_c, 
                   AgainstEq_E1invert_c, 
                   .id = "Scenario") %>% 
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(N1:Q), 
               names_to = "Compartment", 
               values_to = "dStock_c") %>% 
  mutate(., Compartment = fct_relevel(.f = Compartment, "Q",
                                      "N1", "P1", "C1", "N2", "P2", "C2")) %>%
  ggplot(aes(c, dStock_c)) + 
  geom_line(aes(col = Scenario), linewidth = 1) + 
  khroma::scale_color_highcontrast(reverse = F, 
                                   name = "Consumer movement", 
                                   labels = c("Equal", 
                                              "Along-gradient", 
                                              "Against-gradient")) +
  scale_linetype_manual(values = c(1, 2, 4),
                        name = "Consumer movement", 
                        labels = c("Equal", 
                                   "Along-gradient", 
                                   "Against-gradient")) +
  ylab("Stock") +
  xlab(expression(paste("Consumer death rate in the Dispersers' Pool (c)"))) +
  ggh4x::facet_manual(.~Compartment,
                      design = design,
                      scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

:::::

#### Focal parameters influence on ecosystem functions

Here, reproduce the figures showing the influence of focal parameters on 
nutrient flux and trophic compartment productivity. As above, we present two
figures per focal parameter, showing results for when the donor ecosystem 1 has
a classic, bottom-heavy biomass distribution and for when it has an inverted, 
top-heavy biomass distribution.

::::: {.panelset}

::: {.panel}

##### Attack rate in Ecosystem 1

Here, we reproduce **Figure D.8** in the Appendices, showig first the results 
for the case of the donor ecosystem 1 having a classical, bottom-heavy biomass
distribution. Note that, as in Figure \@ref(fig:lsa-graphs-eq-SV-a1), we remove the top and bottom 5% of values for _P~1~_ to avoid graphical artifacts.

```{r cls-bm-lsa-graphs-eq-EF-a1, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_a1,
          AlongEq_E1pyram_a1,
          AgainstEq_E1pyram_a1,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  dplyr::filter(., between(P1,
                           quantile(P1, 0.05, na.rm = T),
                           quantile(P1, 0.95, na.rm = T))) %>%
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(a1, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer attack rate in the donor ecosystem 1 (", a[1], ")"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

This next figure shows the case of the donor ecosystem 1 having an inverted,
top-heavy biomass distribution. Note that, as in Figure \@ref(fig:lsa-graphs-eq-SV-a1), we remove the top and bottom 5% of values for _P~1~_ to avoid graphical artifacts.

```{r ivrt-bm-lsa-graphs-eq-EF-a1, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_a1,
          AlongEq_E1invert_a1,
          AgainstEq_E1invert_a1,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  dplyr::filter(., between(P1,
                           quantile(P1, 0.05, na.rm = T),
                           quantile(P1, 0.95, na.rm = T))) %>%
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(a1, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer attack rate in the donor ecosystem 1 (", a[1], ")"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

::: {.panel}

##### Death rate in Ecosystem 1

This code chunk reproduces **Figure 8** in the Manuscript, again showing first
the case of the donor ecosystem 1 having a bottom-heavy biomass distribtuion. 

```{r cls-bm-lsa-graphs-eq-EF-d1, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_d1,
          AlongEq_E1pyram_d1,
          AgainstEq_E1pyram_d1,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(d1, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer death rate in the donor ecosystem 1 (", d[1], ")"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

Compare the figure above with **Figure 8** in the Manuscript and with the 
following one, where the donor ecosystem 1 has a top-heavy biomass distribution.

```{r ivrt-bm-lsa-graphs-eq-EF-d1, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_d1,
          AlongEq_E1invert_d1,
          AgainstEq_E1invert_d1,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(d1, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer death rate in the donor ecosystem 1 (", d[1], ")"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

::: {.panel}

##### Movement rate into Q

Here we reproduce **Figure 7** in the Manuscript, but for different biomass
distributions in the donor ecosystem 1. Here is the figure for when the donor
ecosystem 1 has a bottom-heavy biomass distribution.

```{r cls-bm-lsa-graphs-eq-EF-g, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_g,
          AlongEq_E1pyram_g,
          AgainstEq_E1pyram_g,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(g, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer movement rate from the donor ecosystem 1 to Q (g)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

And here the donor ecosystem 1 has a top-heavy biomass distribution.

```{r ivrt-bm-lsa-graphs-eq-EF-g, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_g,
          AlongEq_E1invert_g,
          AgainstEq_E1invert_g,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(g, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer movement rate from the donor ecosystem 1 to Q (g)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

::: {.panel}

##### Movement rate from Q

Below, we reproduce **Figure D.10** in the Appendices. As for other focal 
parameters, we show first the case of the donor ecosystem 1 having a bottom-heavy
biomass distribution.

```{r cls-bm-lsa-graphs-eq-EF-m, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_m,
          AlongEq_E1pyram_m,
          AgainstEq_E1pyram_m,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(m, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer movement rate from Q to the recipient ecosystem 2 (m)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

The next code chunk produces the same figure, but for when the donor ecosystem 1
has a top-heavy biomass distribution.

```{r ivrt-bm-lsa-graphs-eq-EF-m, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_m,
          AlongEq_E1invert_m,
          AgainstEq_E1invert_m,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(m, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer movement rate from Q to the recipient ecosystem 2 (m)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

::: {.panel}

##### Death rate in Q

This code chunk reproduces **Figure D.12** in the Appendices. The first figure
shows the case of the donor ecosystem 1 having a bottom-heavy biomass distribution.

```{r cls-bm-lsa-graphs-eq-EF-c, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1pyram_c,
          AlongEq_E1pyram_c,
          AgainstEq_E1pyram_c,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(c, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer death rate in Q (c)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

And this next one shows the case of the donor ecosystem 1 having a top-heavy 
biomass distribution.

```{r ivrt-bm-lsa-graphs-eq-EF-c, echo=TRUE, tidy=TRUE}
bind_rows(NeutralEq_E1invert_c,
          AlongEq_E1invert_c,
          AgainstEq_E1invert_c,
          .id = "Scenario") %>%
  mutate(., 
         Scenario = fct_recode(.f = Scenario, 
                               Neutral = "1", 
                               Along = "2", 
                               Against = "3")) %>% 
  pivot_longer(., 
               cols = c(FLUX_P1:FLUX_C2, PROD_P1:PROD_C2, FLUX_Q), 
               names_to = "Function", 
               values_to = "Value") %>% 
  separate(., Function, 
           into = c("Function",
                    "Compartment"),
           sep = "_") %>% 
  mutate(., 
         Scale = ifelse(Compartment == "C1" | Compartment == "P1", 
                        "Ecosystem 1", ifelse(Compartment == "Q", 
                                              "Dispersers' Pool", "Ecosystem 2")),
         Scale = fct_relevel(.f = Scale, "Ecosystem 1", "Ecosystem 2", "Dispersers' Pool"),
         Function = fct_recode(.f = Function,
                               Productivity = "PROD",
                               "Nutrient flux" = "FLUX"),
         Compartment = fct_recode(.f = Compartment, Consumers = "C1", 
                                  Consumers = "C2", Producers = "P1", 
                                  Producers = "P2", Dispersers = "Q"),
         Compartment = fct_relevel(.f = Compartment, "Producers", "Consumers")
  ) %>%
  ggplot(aes(c, Value)) + 
  geom_line(aes(col = Compartment, linetype = Function), linewidth = 1) + 
  scale_color_manual(values = lsa_combi_palette2) +
  xlab(expression(paste("Consumer death rate in Q (c)"))) +
  facet_grid(Scenario~Scale, scales = "free_y") +
  theme(legend.position = "bottom",
        text = element_text(size = 14))
```

:::

:::::

# Compilation Time

```{r end-timer, include=FALSE}
total_time <- tictoc::toc()
elapsed_time <- (total_time$toc - total_time$tic)/60
names(elapsed_time) <- NULL
```

This notebook was compiled in `r prettyNum(elapsed_time, digits = 2)` minutes.

# Acknowledgments {.appendix}

We are grateful to [Dr. Anne McLeod](https://scholar.google.ca/citations?user=Ruyr3McAAAAJ&hl=en)
for her help in developing the stability and sensitivity analyses code, and for 
suggesting useful reference on both topics. We thank [Dr. Robert Buchkowski](https://robertwbuchkowski.github.io) 
for his insights in designing and evaluating the stability analyses. Finally, 
we thank [Dr. A. Z. Andis Arietta](https://www.azandisresearch.com) for his help
in developing the code for the biomass distribution plots.

# Author Contributions {.appendix}

MR and SJL conceptualized the model; MR, SJL, OJS, EVW, YFW, and TRH designed the 
study; MR wrote the code and run the analyses; MR and SJL run and proofread the 
code; MR, SJL, OJS interpreted the results; all authors contributed critically to 
the manuscript.